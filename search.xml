<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>googled7f4d1b467875402</title>
    <url>/posts/e573ea39.html</url>
    <content><![CDATA[google-site-verification: googled7f4d1b467875402.html]]></content>
  </entry>
  <entry>
    <title>JavaReview 笔记</title>
    <url>/posts/49e6f07c.html</url>
    <content><![CDATA[<h2 id="1-oop-learning-01"><a href="#1-oop-learning-01" class="headerlink" title="1. oop learning 01"></a>1. oop learning 01</h2><h3 id="1-1-OOP-thinking"><a href="#1-1-OOP-thinking" class="headerlink" title="1.1 OOP thinking"></a>1.1 OOP thinking</h3><ol>
<li>面向对象学习的3条主线<ol>
<li>Java类及类的成员： 成员变量, 方法, 构造器, 代码块, 内部类</li>
<li>面向对象的3大特征: 封装, 继承, 多态</li>
<li>其他关键字: this, super, static, final, abstract, interface, package, import,etc.  </li>
</ol>
</li>
<li>面向对象与面向过程  <ul>
<li>面向过程: 强调的是功能行为, 以函数为最小单位, 考虑怎么做</li>
<li>面向对象: 强调了具备功能的对象, 以类/对象为最小单位, 考虑谁来做</li>
</ul>
</li>
<li>面向对象分析方法问题的思路:  <ul>
<li>根据问题需要, 选择问题所针对的<strong>现实世界的实体</strong></li>
<li>从实体中寻找解决问题相关的属性和功能, 这些属性和功能构成了<strong>类</strong></li>
<li>把抽象的实体用计算机语言进行描述, 形成<strong>计算机世界中类的定义</strong>,即借助某种编程语言,把类构造成计算机能够识别和处理的数据结构</li>
<li>将<strong>类实例化成计算机世界中的对象</strong>, 对象是计算机世界中解决问题的最终工具  </li>
</ul>
</li>
<li>面向对象中两个重要概念<br> 类: 对一类事物的描述, 是抽象的, 概念上的定义<br> 对象: 对实际存在的该类事物的每个个体, 因此也称为实例(instance)<blockquote>
<p>面向对象程序设计的重点是类的设计<br>设计类, 就是设计类的成员</p>
</blockquote>
</li>
<li>面向对象思想规则落地的过程<ol>
<li>创建类, 设计类的成员</li>
<li>创建类的对象</li>
<li>调用对象的结构  <a id="more"></a>
<h3 id="1-2-对象内存解析"><a href="#1-2-对象内存解析" class="headerlink" title="1.2 对象内存解析"></a>1.2 对象内存解析</h3></li>
</ol>
</li>
</ol>
<ul>
<li>Heap:<ul>
<li>存放对象实例, 即所有new出来的东西(对象, 数组, 对象的属性(<em>非static的</em>)也加载在堆中)</li>
</ul>
</li>
<li>Stack:<ul>
<li>虚拟机栈, 用于存储局部变量等.  </li>
<li>局部变量表存放了编译期可知长度的各种基本数据类型,对象引用(reference类型,是对象在堆内存的首地址)</li>
<li>方法执行完自动释放</li>
</ul>
</li>
<li>Method Area<ul>
<li>存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据,<br>简单来说就是类的加载信息, 常量池, 静态域  </li>
</ul>
</li>
</ul>
<h3 id="1-3-属性与局部变量的对比"><a href="#1-3-属性与局部变量的对比" class="headerlink" title="1.3 属性与局部变量的对比"></a>1.3 属性与局部变量的对比</h3><p>成员变量(属性)    vs    局部变量(方法内, 方法形参, 构造器内, 构造器形参, 代码块内 )</p>
<ol>
<li><p>相同点</p>
<ol>
<li>声明格式相同</li>
<li>先声明, 后使用</li>
<li>变量都有对应的作用域</li>
</ol>
</li>
<li><p>不同点:</p>
<ol>
<li>在类中声明的位置不同<br>成员变量(属性): 直接定义在类的一对{}内<br>局部变量: 声明在方法内, 方法形参, 代码块内, 构造器形参, 构造器内部变量</li>
<li>权限修饰符的不同<br>成员变量(属性): 可以在声明属性时, 指明其权限, 使用权限修饰符<br>局部变量: 不可以使用权限修饰符  </li>
<li>默认初始化值:<br>成员变量(属性): 根据其类型, 有默认初始化值({byte, short, int, long : 0}, {float, double : 0.0}, {char : 0(‘\u0000’)}, {boolean : flase})<br>局部变量: 没有默认初始化值, 在调用前必须手动初始化(形参可以在调用时进行赋值)</li>
<li>在内存中加载的位置:<br>成员变量(属性): 加载到堆空间中(非static)<br>局部变量: 加载到栈空间</li>
</ol>
</li>
</ol>
<h3 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h3><h4 id="1-方法声明"><a href="#1-方法声明" class="headerlink" title="1. 方法声明"></a>1. 方法声明</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">      方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>权限修饰符<ul>
<li>private</li>
<li>public</li>
<li>缺省(protected)</li>
</ul>
</li>
<li>返回值类型<ul>
<li>有返回值: 必须在方法声明时指定返回值的类型, 用return关键字返回数据</li>
<li>无返回值: void</li>
</ul>
</li>
</ul>
<h4 id="2-方法的使用"><a href="#2-方法的使用" class="headerlink" title="2. 方法的使用"></a>2. 方法的使用</h4><ul>
<li>在方法中可以调用当前类的成员变量(属性)或方法</li>
<li>方法中不可以定义新的方法  </li>
</ul>
<h3 id="1-5-“万事万物皆对象”"><a href="#1-5-“万事万物皆对象”" class="headerlink" title="1.5 “万事万物皆对象”"></a>1.5 “万事万物皆对象”</h3><ol>
<li>在Java语言中, 将功能,结构等封装到实体类中, 通过类的实例化, 来调用具体的功能结构.</li>
<li>涉及到Java语言与前端HTML, 后端的数据库交互时, 前后端的结构在Java层面交互时, 都体现为类与对象.  </li>
</ol>
<h3 id="1-6-匿名对象"><a href="#1-6-匿名对象" class="headerlink" title="1.6 匿名对象"></a>1.6 匿名对象</h3><ol>
<li><p>匿名对象的使用  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        p.sendEmail();</span><br><span class="line">        p.playGame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象, 只能调用一次, 没有显式的变量名</span></span><br><span class="line">        <span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line">        <span class="keyword">new</span> Phone().playGame();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">        <span class="keyword">new</span> Phone().showPrice(); <span class="comment">// 0.0</span></span><br><span class="line"></span><br><span class="line">        PhoneFactory pf = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">        pf.show(<span class="keyword">new</span> Phone());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send emails"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play games"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"price is "</span> + <span class="keyword">this</span>.price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">        phone.showPrice();</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-7-方法重载overload"><a href="#1-7-方法重载overload" class="headerlink" title="1.7 方法重载overload"></a>1.7 方法重载overload</h3><ul>
<li>在一个类中, 允许存在一个以上的同名方法, 只要他们的参数个数或者参数类型不同即可<ul>
<li><strong>“两同一不同”</strong> : 同一个类, 相同方法名<br>参数列表不同, 参数个数不同, 参数类型不同</li>
<li>与方法的权限修饰符, 返回值类型, 形参变量名, 方法体均无关  </li>
</ul>
</li>
<li>通过对象调用方法时, 在编译期就会确定是具体调用哪个方法<ul>
<li>方法名 –&gt; 参数列表  </li>
</ul>
</li>
</ul>
<h3 id="1-8-可变个数的形参"><a href="#1-8-可变个数的形参" class="headerlink" title="1.8 可变个数的形参"></a>1.8 可变个数的形参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可变个数形参的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. jdk 5.0 新增的内容</span></span><br><span class="line"><span class="comment"> * 2. 具体使用</span></span><br><span class="line"><span class="comment"> *    1. 可变个数的形参格式: 数据类型... 变量名</span></span><br><span class="line"><span class="comment"> *    2. 调用可变个数形参的方法时, 传入的参数的个数可以是 0,1,2..</span></span><br><span class="line"><span class="comment"> *    3. 可变个数形参的方法与本类中方法名相同, 形参列表不同的方法之间构成重载  </span></span><br><span class="line"><span class="comment"> *    4. 可变个数形参的方法与本类中方法名形态, 形参类型相同的数组之间不构成重载, 即不能共存</span></span><br><span class="line"><span class="comment"> *    5. 可变个数形参在方法形参中必须声明在末尾, 且只能有一个</span></span><br><span class="line"><span class="comment"> * 3. 应用场景</span></span><br><span class="line"><span class="comment"> *    在写SQL语句时, 查询语句的条件不知道具体是几个, 可用可变参数接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodArgsTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MethodArgsTest test = <span class="keyword">new</span> MethodArgsTest();</span><br><span class="line">        test.show(<span class="number">12</span>);</span><br><span class="line">        test.show(<span class="string">"hellos"</span>);</span><br><span class="line">        test.show(<span class="string">"hellos"</span>, <span class="string">"worlds"</span>, <span class="string">"shows"</span>);</span><br><span class="line">        test.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show(int i)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show(String s)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String... strs)</span></span>&#123; <span class="comment">// 可变个数的形参</span></span><br><span class="line">        System.out.println(<span class="string">"show(String... strs)"</span>);</span><br><span class="line">        <span class="comment">// strs 可看作String[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            System.out.println(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:<br>public void test(int a, int… arr); 与 public void test(int a, int[] arr);<br>编译器看来int… 与 int[] 是一样的  </p>
</blockquote>
<h3 id="1-9-方法参数的值传递机制"><a href="#1-9-方法参数的值传递机制" class="headerlink" title="1.9 方法参数的值传递机制"></a>1.9 方法参数的值传递机制</h3><ul>
<li><p>Java的实参值是如何传入方法的呢?</p>
<ul>
<li>Java中方法的参数传递只有一种方式: <strong>值传递</strong>.<br>即将实际参数值的副本传入方法内, 参数本身不受影响</li>
</ul>
</li>
<li><p>方法的形参的传递机制:  值传递</p>
<ul>
<li>形参是基本数据类型: 将实参基本数据类型变量的”==数据值==”传递给形参</li>
<li>形参是引用数据类型: 将实参引用数据类型变量的”==地址值==”传递给形参</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = m;</span><br><span class="line"></span><br><span class="line">        System.out.println(m, n); <span class="comment">// 10, 10</span></span><br><span class="line">        n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(m, n); <span class="comment">// 10, 20</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============="</span>);  </span><br><span class="line">        Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">        o1.id = <span class="number">1001</span>;</span><br><span class="line">        Order o2 = o1;</span><br><span class="line">        System.out.println(o1.id, o2.id); <span class="comment">// 1001, 1001</span></span><br><span class="line"></span><br><span class="line">        o2.id = <span class="number">1002</span>;</span><br><span class="line">        System.out.println(o1.id, o2.id);  <span class="comment">// 1002, 1002  </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-10-面向对象的三大特征之”封装和隐藏”"><a href="#1-10-面向对象的三大特征之”封装和隐藏”" class="headerlink" title="1.10 面向对象的三大特征之”封装和隐藏”"></a>1.10 面向对象的三大特征之”封装和隐藏”</h3><ul>
<li><p>程序设计追求”高内聚, 低耦合”</p>
<ul>
<li>高内聚 : 类的内部数据操作细节自己完成, 不允许外部干涉</li>
<li>低耦合 : 仅对外暴露少量的方法用于使用.  </li>
</ul>
</li>
<li><p>隐藏对象内部的复杂性, 只对外公开简单的接口. 便于外界调用, 从而提高系统的可扩展性、可维护性. 通俗的说,  把该隐藏的隐藏起来, 该暴露的暴露出来. 这就是封装性的设计思想.  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 封装性的体现:</span></span><br><span class="line"><span class="comment">*   将类的成员变量(属性)私有化(private), 同时, 提供共有的方法来获取和设置成员变量(属性)的值, 即getter和setter方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   拓展:</span></span><br><span class="line"><span class="comment">*   封装性的体现:</span></span><br><span class="line"><span class="comment">*     1. 上述</span></span><br><span class="line"><span class="comment">*     2. 不对外暴露的私有的方法</span></span><br><span class="line"><span class="comment">*     3. 单例模式(将构造器私有化)</span></span><br><span class="line"><span class="comment">* 2. 封装性的体现,需要权限修饰符配合</span></span><br><span class="line"><span class="comment">*    1. private, 缺省, protected, public</span></span><br><span class="line"><span class="comment">*      修饰符             类内部     同一个包    不同包的子类     同一个工程</span></span><br><span class="line"><span class="comment">*      private             y</span></span><br><span class="line"><span class="comment">*      缺省                y         y</span></span><br><span class="line"><span class="comment">*      protected           y         y            y</span></span><br><span class="line"><span class="comment">*      public              y         y            y             y</span></span><br><span class="line"><span class="comment">*    2. 对class的权限修饰只可以用public或缺省</span></span><br><span class="line"><span class="comment">*       public: 可以在任意地方被访问</span></span><br><span class="line"><span class="comment">*       缺省: 只可以北同一个包内部的类访问</span></span><br><span class="line"><span class="comment">*    3. 权限修饰符可以用来修饰类的内部结构, 成员变量(属性), 方法, 构造器, 内部类.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/29 23:10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">//        a.name = "dog";</span></span><br><span class="line"><span class="comment">//        a.age = 3;</span></span><br><span class="line">        a.setName(<span class="string">"dog"</span>);</span><br><span class="line">        a.setAge(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        a.legs = 4;</span></span><br><span class="line">        a.show();</span><br><span class="line"><span class="comment">//        a.legs = -2; // 不合逻辑</span></span><br><span class="line">        a.setLegs(-<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> legs; <span class="comment">// 私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> legs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (legs &gt;= <span class="number">0</span> &amp;&amp; legs % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.legs = legs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.legs = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat foods"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", legs="</span> + legs +</span><br><span class="line">                <span class="string">'&#125;'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-11-构造器"><a href="#1-11-构造器" class="headerlink" title="1.11 构造器"></a>1.11 构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造器(constructor) / 构造方法</span></span><br><span class="line"><span class="comment"> *   1. 作用:  创建对象; 初始化对象的成员变量(属性)</span></span><br><span class="line"><span class="comment"> *   2. 如果没有显式的定义构造方法, 系统会默认提供一个空参的构造方法</span></span><br><span class="line"><span class="comment"> *   3. 一个类中的多个构造方法构成重载</span></span><br><span class="line"><span class="comment"> *   4. 一旦提供了构造方法, 系统就不会提供默认的空参构造方法</span></span><br><span class="line"><span class="comment"> *   5. 一个类中至少有1个构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/1/30 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        p1.setName(<span class="string">"hee"</span>);</span><br><span class="line">        p1.setAge(<span class="number">10</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"java"</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        p2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>成员变量(属性)赋值的先后顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 成员变量(属性)赋值的先后顺序</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 1. 默认初始化</span></span><br><span class="line"><span class="comment">* 2. 显式初始化 / 代码块, 按书写的先后顺序赋值</span></span><br><span class="line"><span class="comment">* 3. 构造器中赋值</span></span><br><span class="line"><span class="comment">* 4. 通过"对象.方法", "对象.成员变量(属性)"赋值</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 以上操作的先后顺序: 1 --&gt; 2 --&gt; 3 --&gt; 4</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/30 10:29</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(u.age);</span><br><span class="line"></span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">        System.out.println(u2.age);</span><br><span class="line">        u2.setAge(<span class="number">4</span>);</span><br><span class="line">        System.out.println(u2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-12-Java-bean-与-一些关键字的使用"><a href="#1-12-Java-bean-与-一些关键字的使用" class="headerlink" title="1.12 Java bean 与 一些关键字的使用"></a>1.12 Java bean 与 一些关键字的使用</h3><ul>
<li><p>JavaBean是一种Java语言写成的可重用组件</p>
</li>
<li><p>JavaBean是指符合以下标准的Java类</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共构造器</li>
<li>有成员变量(属性), 且有对应的get,set方法  </li>
</ul>
</li>
<li><p>this 关键字的使用:</p>
<ul>
<li>this 可以修饰成员变量(属性), 方法, 构造器<ol>
<li>this 修饰成员变量(属性)和方法:<br>this 理解为当前对象或当前正在创建的对象</li>
<li>this 调用构造器: 可以调用本类中指定的其他构造器  <ul>
<li>this(); 调用空参的构造器</li>
<li>this(参数列表); 调用相应参数的构造器  </li>
<li>不能自己调用自己, 如果一个类中有n个构造器, 最多有n-1个构造器中调用this(形参列表)</li>
<li>this(形参类别) 必须声明在当前构造器首行  </li>
<li>构造器内部最多只能声明一个this() 用来调用其他构造方法</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>package 关键字的使用</p>
<ol>
<li>为了更好的实现项目中类的管理, 提供包的概念</li>
<li>使用package声明类或接口所属的包, 声明在源文件的首行</li>
<li>包: 属于标识符, 遵循标识符的命名规则,每”.”一次, 代表一层文件目录<ul>
<li>同一个包下, 不能命名同名的接口,类</li>
<li>不同的包下, 可以命名同名的接口,类</li>
</ul>
</li>
</ol>
</li>
<li><p>import 关键字的使用</p>
<ol>
<li>在源文件中显式的使用import导入指定包下的类或接口</li>
</ol>
</li>
</ul>
<h3 id="1-13-MVC设计模式初见"><a href="#1-13-MVC设计模式初见" class="headerlink" title="1.13 MVC设计模式初见"></a>1.13 MVC设计模式初见</h3><ul>
<li>MVC是常用的设计模式之一. 将程序分为三个层次: 视图模型层(Model), 控制器层(Controller), 数据模型层(View).</li>
<li>这种将程序输入输出, 数据处理, 以及数据的展示分离开的设计模式是程序结构变得灵活且清晰, 同时也描述了程序的各个对象见的通信方式, 降低了程序的耦合性</li>
<li><strong>模型层 model</strong> 主要处理数据<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li><strong>控制层 controller</strong> 处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
<li><strong>视图层 View</strong> 显示数据<ul>
<li>相关工具类 view.utils  </li>
</ul>
</li>
</ul>
<h2 id="2-oop-learning-02"><a href="#2-oop-learning-02" class="headerlink" title="2. oop learning 02"></a>2. oop learning 02</h2><h3 id="2-1-面向对象的三大特征之继承性-inheritance"><a href="#2-1-面向对象的三大特征之继承性-inheritance" class="headerlink" title="2.1 面向对象的三大特征之继承性(inheritance)"></a>2.1 面向对象的三大特征之继承性(inheritance)</h3><ul>
<li>继承性的好处:<ol>
<li>减少了代码的冗余</li>
<li>便于功能的扩展</li>
<li>为多态性的使用, 提供了前提</li>
</ol>
</li>
<li>继承性的格式: class A extends B{}<ul>
<li>A: 子类, 派生类, subclass</li>
<li>B: 父类, 超类, 基类, superclass</li>
<li>一旦子类A继承父类B后, 子类A中就获取了B中声明的所有结构(属性, 方法)<ul>
<li>特别的, 父类中声明为private的属性或方法, 子类继承父类后, 也认为获取了父类的私有的结构, 只是因为封装性,使得子类不能直接调用父类的结构而已</li>
</ul>
</li>
<li>子类继承父类后, 还可以定义或声明自己的结构,实现功能的扩展</li>
<li>子类和父类的关系, 不同于子集和集合的关系.</li>
</ul>
</li>
<li>Java只支持单继承和多层继承, 不允许多重继承<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
<li>子父类是相对的概念</li>
<li>Java.lang.Object类是所有Java类的共有父类</li>
</ul>
</li>
</ul>
<h3 id="2-2-方法重写-Override"><a href="#2-2-方法重写-Override" class="headerlink" title="2.2 方法重写(Override)"></a>2.2 方法重写(Override)</h3><ul>
<li>重写(override):<br>子类继承父类后,可以对父类中同名同参数的方法, 进行覆盖操作  </li>
<li>重写的规定:<ol>
<li>子类重写的方法名和形参列表与被重写的方法的方法名和形参列表相同</li>
<li>子类重写的方法的权限修饰符不小于父类被重写方法的权限修饰符<ul>
<li>特殊情况, 子类中不能重写父类中private的方法</li>
</ul>
</li>
<li>返回值类型:<br>父类被重写的方法的返回值类型是void, 子类重写的方法的返回值类型只能是void<br> 父类被重写的方法的返回值类型是A类, 子类重写的方法的返回值类型可以是A类或A类的子类<br> 父类被重写的方法的返回值类型是基本数据类型, 子类重写的方法的返回值类型必须是相同的基本数据类型  </li>
<li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</li>
</ol>
</li>
<li>子类和父类中同名同参数的方法要么都是非static的(考虑重写), 要么都是static的(不是重写)</li>
</ul>
<blockquote>
<p><strong>重写与重载的区别</strong>:</p>
<ol>
<li>从二者的定义细节：<br>重载:2同一不同; 重写: 上述4点</li>
<li>从编译和运行的角度看:<br>重载: 是指允许存在多个同名方法, 而这些方法的参数不同.  编译器根据方法不同的参数表, 对同名方法的名称做修饰. 对于编译器而言, 这些同名方法就成了不同的方法. 它们的调用地址在编译期就绑定了. Java的重载是可以包括父类和子类的, 即子类可以重载父类的同名不同参数的方法.<br>所以：对于重载而言, 在方法调用之前, 编译器就已经确定了所要调用的方法, 这称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”<br>而对于重写, 即表现为多态, 只有等到方法调用的那一刻, 解释运行器才会确定所要调用的具体方法, 这称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>” .<br>引用一句Bruce Eckel的话： “*<em>不要犯傻, 如果它不是晚绑定,  它就不是多态. *</em>”</li>
</ol>
</blockquote>
<h3 id="2-3-super关键字"><a href="#2-3-super关键字" class="headerlink" title="2.3 super关键字"></a>2.3 super关键字</h3><ul>
<li>super 可以调用属性, 方法, 构造器</li>
<li>可以在子类的方法或构造器中, 通过super.属性, super.方法, 调用父类中声明的属性或方法</li>
<li>super(形参列表) 调用父类中指定的构造器, 必须写在构造方法的第一行, 且不能与this共存</li>
<li>在构造器的首行, 没有显式的声明this(形参列表) 或super(形参列表) , 默认调用super()空参构造.</li>
<li>在类的多个构造器中, 至少有一个构造器中使用了”super(形参列表)”, 调用父类的构造方法  </li>
</ul>
<h3 id="2-4-子类对象实例化的全过程"><a href="#2-4-子类对象实例化的全过程" class="headerlink" title="2.4 子类对象实例化的全过程"></a>2.4 子类对象实例化的全过程</h3><ol>
<li>从结果上看, (继承性)<br> 子类继承父类后, 就获取了父类中声明的属性或方法<br> 创建子类的对象,在堆空间中就会加载所有父类中声明的属性</li>
<li>从过程上看<br> 通过子类的构造器创建子类对象时, 一定会直接或间接的调用父类的构造器, 进而调用父类的构造器, 直到调用了Object类的空参构造为止. 所以内存中会有父类的结构, 子类对象才可以考虑调用  <blockquote>
<p>注: 虽然创建子类对象时调用了父类的构造方法, 但是自始至终只创建过一个对象, 即new的那个子类对象  </p>
</blockquote>
</li>
</ol>
<h3 id="2-5-面向对象三大特征之多态-Polymorphism"><a href="#2-5-面向对象三大特征之多态-Polymorphism" class="headerlink" title="2.5 面向对象三大特征之多态(Polymorphism)"></a>2.5 面向对象三大特征之多态(Polymorphism)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多态性:</span></span><br><span class="line"><span class="comment"> *   1. 一个事物的多种形态</span></span><br><span class="line"><span class="comment"> *   2. 父类引用指向子类对象</span></span><br><span class="line"><span class="comment"> *   3. 调用子父类同名的方法时, 执行的时子类重写的方法 ---- 虚拟方法调用</span></span><br><span class="line"><span class="comment"> *      总结; 编译看左边, 运行看右边</span></span><br><span class="line"><span class="comment"> *   4. 多态的前提: 继承和重写</span></span><br><span class="line"><span class="comment"> *   5. 对象的多态性, 只适用于方法, 不适用于属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      虚拟方法调用(Virtual Method Invocation)</span></span><br><span class="line"><span class="comment"> *   正常的方法调用</span></span><br><span class="line"><span class="comment"> *      Person e = new Person();</span></span><br><span class="line"><span class="comment"> *      e.getInfo();</span></span><br><span class="line"><span class="comment"> *      Student e = new Student();</span></span><br><span class="line"><span class="comment"> *      e.getInfo();</span></span><br><span class="line"><span class="comment"> *   虚拟方法调用(多态情况下)</span></span><br><span class="line"><span class="comment"> *      子类中定义了与父类同名同参数的方法, 在多态情况下, 将此时父类的方法称为虚拟方法, 父类根据赋给它的不同子类对象, 动态调用属于子类的该方法. 这样的方法调用在编译期是无法确定的.</span></span><br><span class="line"><span class="comment"> *      Person e = new Student();</span></span><br><span class="line"><span class="comment"> *      e.getInfo(); //调用Student类的getInfo()方法</span></span><br><span class="line"><span class="comment"> *   编译时类型和运行时类型</span></span><br><span class="line"><span class="comment"> *      编译时e为Person类型, 而方法的调用是在运行时确定的, 所以调用的是Student类的getInfo()方法.  ——动态绑定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/1/30 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line"></span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        man.eat();</span><br><span class="line">        man.age = <span class="number">20</span>;</span><br><span class="line">        man.learn();</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Man(); <span class="comment">// 对象的多态</span></span><br><span class="line">        p2.eat();</span><br><span class="line">        p2.walk();</span><br><span class="line"><span class="comment">//        p2.learn(); 不能调用Man类独有的方法</span></span><br><span class="line">        Person p3 = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line">        System.out.println(p2.id); <span class="comment">// 1001, 父类的id</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-自动向下转型"><a href="#2-6-自动向下转型" class="headerlink" title="2.6 自动向下转型"></a>2.6 自动向下转型</h3><ul>
<li><p>在多态中如何调用子类特有的属性和方法?</p>
<ul>
<li><p>向下转型: 强制类型转换  </p>
<ul>
<li>使用强制类型转换时, 可能出现ClassCastException异常<ul>
<li>为了避免异常, 在转型前使用 instanceof 关键字判断</li>
<li>a instanceof A : 判断 a对象 是否是 A类的实例, 是返回true, 反之为false.</li>
<li>若 类B是A的父类, a instanceof A 返回true, 则a instanceof B 也返回true</li>
</ul>
</li>
<li>要求a所属的类与A类必须是子父类的关系, 否则编译报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译不过</span></span><br><span class="line">Man man = <span class="keyword">new</span> Woman(); <span class="comment">// 错</span></span><br><span class="line">String str = <span class="keyword">new</span> Date(); <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译可以通过, 但是运行会报错</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line">Man m1 = (Man)p1; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Man m2 = (Man)p2; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过, 运行也通过</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Woman();</span><br><span class="line">Person p = (Person)obj; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考查多态的题目：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Sub();</span><br><span class="line">        base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 此时是 sub_1  因为调用父类的虚方法, 执行的是子类重写后的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sub s = (Sub)base;</span></span><br><span class="line">    <span class="comment">// s.add(1,2,3); // sub_2 , 因为这是子类调用自己的方法, 优先选择确定参数的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] arr)</span> </span>&#123; <span class="comment">// int[] 与 int... 在编译器看来是一样的, 所以这里是重写</span></span><br><span class="line">        System.out.println(<span class="string">"sub_1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void add(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">// System.out.println("sub_2");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-7-Object类的使用"><a href="#2-7-Object类的使用" class="headerlink" title="2.7 Object类的使用"></a>2.7 Object类的使用</h3><ul>
<li><p>Object类是所有Java类的根父类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        System.out.println(order.getClass().getSuperclass()); <span class="comment">// class java.lang.Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object类中的功能(属性, 方法)具有通用性</p>
<ul>
<li>只有一个空参构造器</li>
<li>clone() 方法, 克隆的方法</li>
<li>equals() 方法, 比较的方法</li>
<li>finalize() 方法, 垃圾回收时自动调用的方法, 建议不要主动调用该方法</li>
<li>getClass() 方法,  获取当前类</li>
<li>hashCode() 方法 返回对象的哈希值</li>
<li>toString() 方法</li>
<li>notify() 方法</li>
<li>notifyAll() 方法</li>
<li>wait() 方法</li>
</ul>
</li>
<li><p>重写equals方法:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* == 和 equals() 区别</span></span><br><span class="line"><span class="comment">*   一. 回顾 == :</span></span><br><span class="line"><span class="comment">*      == 运算符:</span></span><br><span class="line"><span class="comment">*        1. 可以使用在基本数据类型变量和引用数据类型变量中</span></span><br><span class="line"><span class="comment">*        2. 如果比较的是基本数据类型变量, 比较的是两个变量保存的数据是否相等(数据类型不一定相同)</span></span><br><span class="line"><span class="comment">*        3. 如果比较的是引用数据类型变量, 比较的是两个变量的地址是否相同</span></span><br><span class="line"><span class="comment">*   二. equals()方法</span></span><br><span class="line"><span class="comment">*     1. 是一个方法.</span></span><br><span class="line"><span class="comment">*     2. 只适用于引用数据类型</span></span><br><span class="line"><span class="comment">*     3. Object类中定义的equals方法</span></span><br><span class="line"><span class="comment">*           public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">*              return (this == obj);</span></span><br><span class="line"><span class="comment">*           &#125;</span></span><br><span class="line"><span class="comment">*       即Object类中的equals方法和 == 是一样的</span></span><br><span class="line"><span class="comment">*     4. 像String, date, File, 包装类等都重写了Object类中的equals()方法, 重写后比较的是两个对象的"属性内容"</span></span><br><span class="line"><span class="comment">*     5. 自定义类重写equals()方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 11:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">        System.out.println(i == j); <span class="comment">// true</span></span><br><span class="line">        System.out.println(i == d); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        System.out.println( b == i); // 基本数据类型运算跟boolean无关, 其他7种都可以用 == 进行比较</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">10</span>;</span><br><span class="line">        System.out.println(c == i); <span class="comment">// true</span></span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">char</span> c2 = <span class="number">65</span>;</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"tom"</span>,<span class="number">21</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"tom"</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">        String str3 = <span class="string">"java"</span>;</span><br><span class="line">        String str4 = <span class="string">"java"</span>;</span><br><span class="line">        System.out.printf(<span class="string">"str1 == str3 ? %s \n"</span>, str1 == str3); <span class="comment">// false</span></span><br><span class="line">        System.out.printf(<span class="string">"str3 == str4 ? %s \n"</span>,str4 == str3); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"++++++++++++++++"</span>);</span><br><span class="line">        <span class="comment">// equals() 方法</span></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(p1.equals(p2)); <span class="comment">// 没重写equals的时候, false; 重写后: true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写toString() 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* toString() 方法</span></span><br><span class="line"><span class="comment">*  1. 输出一个对象的引用时, 是调用对象的 toString()方法</span></span><br><span class="line"><span class="comment">*  2. Object类的toString()方法</span></span><br><span class="line"><span class="comment">*     public String toString() &#123;</span></span><br><span class="line"><span class="comment">*         return getClass().getName() + "@" + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*  3. 像String, date, File, 包装类等都重写了Object类中的toString()方法, 返回"实体内容"信息</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 14:19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"java"</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(p1.toString()); <span class="comment">// 没重写的时候,cn.ckh.oop02.test3.Person@6039df1</span></span><br><span class="line">        System.out.println(p1); <span class="comment">// 没重写的时候,cn.ckh.oop02.test3.Person@6039df1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写toString() 后</span></span><br><span class="line">        System.out.println(p1); <span class="comment">// 自定义的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-8-包装类的使用"><a href="#2-8-包装类的使用" class="headerlink" title="2.8 包装类的使用"></a>2.8 包装类的使用</h3><ul>
<li><p>针对八种基本数据类型定义相应的引用数据类型– 包装类(封装类)</p>
</li>
<li><p>有了类的特点, 就可以调用类的方法</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">- 前6种包装类都是继承自Number类的子类</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>基本类型, 包装类与String类之间的转换</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 包装类的使用</span></span><br><span class="line"><span class="comment">* 1. Java提供的8种基本数据类型对于的包装类, 使得基本数据类型变量具有类的特征</span></span><br><span class="line"><span class="comment">* 2. 掌握基本数据类型, 包装类, String三者之间的转换</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 14:37</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型 --&gt; 包装类 : 调用包装类的构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        Integer integer = <span class="keyword">new</span> Integer(num1);</span><br><span class="line">        System.out.println(integer.toString()); <span class="comment">// 10</span></span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(integer1); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">//        Integer integer2 = new Integer("123av"); // 报异常</span></span><br><span class="line">        Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3f</span>);</span><br><span class="line">        Float f2 = <span class="keyword">new</span> Float(<span class="string">"12.3f"</span>);</span><br><span class="line">        System.out.println(f1); <span class="comment">// 12.3</span></span><br><span class="line">        System.out.println(f2); <span class="comment">// 12.3</span></span><br><span class="line"></span><br><span class="line">        Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">        Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">"true123"</span>); <span class="comment">// false, 因为Boolean进行过优化, 不是true都是false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装类 --&gt; 基本数据类型 : 调用包装类的xxxValue()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">int</span> i1 = in1.intValue();</span><br><span class="line">        System.out.println(i1 + <span class="number">1</span>); <span class="comment">// 13</span></span><br><span class="line">        Float aFloat = <span class="keyword">new</span> Float(<span class="number">12.3f</span>);</span><br><span class="line">        <span class="keyword">float</span> v = aFloat.floatValue();</span><br><span class="line">        System.out.println(v + <span class="number">1.1</span>); <span class="comment">// 13.4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * JDK 5.0新特性, 自动装箱与自动拆箱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        method(num1); <span class="comment">// int 自动装箱为 Integer, Integer --&gt; Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动装箱 : 基本数据类型 --&gt; 包装类</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">13</span>;</span><br><span class="line">        Integer in1 = num2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean b2 = b1; <span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动拆箱 : 包装类 --&gt; 基本数据类型</span></span><br><span class="line">        System.out.println(in1.toString()); <span class="comment">// 13</span></span><br><span class="line">        <span class="keyword">int</span> num3 = in1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型, 包装类 --&gt; String类</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 方式1: 加连接符</span></span><br><span class="line">        String str1 = num1 + <span class="string">""</span>; <span class="comment">// "10"</span></span><br><span class="line">        <span class="comment">// 方式2: String类的valueOf()方法</span></span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">        String s1 = String.valueOf(f1); <span class="comment">// "12.3"</span></span><br><span class="line"></span><br><span class="line">        Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">        String.valueOf(d1); <span class="comment">// "12.4"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String类 --&gt; 基本数据类型, 包装类 : 调用包装类的parseXXX()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//        int num1 = (int)str1; // 错误</span></span><br><span class="line"><span class="comment">//        Integer in1 = (Integer)str1; // 强转必有有子父类关系</span></span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(str1);</span><br><span class="line">        System.out.println(i+<span class="number">2</span>); <span class="comment">// 125</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">"true"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = Boolean.parseBoolean(s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b1; <span class="comment">// 默认为false</span></span><br><span class="line">    Boolean b2; <span class="comment">// 默认是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试题</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(o1); <span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为三元运算符要求,编译时":"前后的类型是统一的一个类型, 所以Integer对应的int类提升为double类型</span></span><br><span class="line"><span class="comment">    所以是 1.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(o2); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y); <span class="comment">// false 常量池的原因</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li><p>Java为很多基本类型的包装类/字符串都建立了常量池<br>常量池： 相同的值值存储一份, 节省内存, 共享访问  </p>
<ul>
<li><p>基本类型的包装类：(有常量池的)<br>Boolean, Byte, Short, Integer, Long, Character<br>Boolean: true, false<br>Byte: -128<del>127,<br>Character: 0</del>127<br>Short, Integer, Long: -128~127<br>Float,Double 没有缓存(常量池)  </p>
</li>
<li><p>常量式(字面量)赋值创建, 放在方法区常量池空间(将被常量化)<br>Integer a = 10;<br>String b = “abc”;<br>String e = “abc” + “defsf”;  </p>
</li>
<li><p>new 对象进行创建, 将放在堆空间(不会常量化)<br>Integer c = new Integer(10);<br>String d = new String(“abc”);  </p>
</li>
</ul>
</li>
</ul>
<h2 id="3-oop-learing-03"><a href="#3-oop-learing-03" class="headerlink" title="3. oop learing 03"></a>3. oop learing 03</h2><h3 id="3-1-static-关键字"><a href="#3-1-static-关键字" class="headerlink" title="3.1 static 关键字"></a>3.1 static 关键字</h3><ul>
<li><p>Static 关键字的使用</p>
<ol>
<li><p>static 静态的</p>
</li>
<li><p>static可以用来修饰: 成员变量(属性), 方法, 代码块, 内部类</p>
</li>
<li><p>使用static修饰成员变量(属性): 静态变量(类变量)</p>
<ul>
<li>成员变量(属性), 按是否使用static修饰, 又分为静态变量(类变量) 和 非静态变量(实例变量)</li>
<li>实例变量: 我们创建了一个类的多个对象, 每个对象独立拥有一套类中的非静态变量<br>当修改其中一个对象的非静态变量时,不会导致其他对象中的同样的变量值修改</li>
<li>静态变量: 我们创建了一个类的多个对象, 多个对象共同拥有同一个静态变量<br>当其中一个对象修改静态变量时,其他对象调用此静态变量时,是修改过的</li>
<li>static修饰成员变量(属性)的其他说明:<ul>
<li>静态变量随着类的加载而加载, 实例变量是随着对象的创建而加载的. 可通过”类名.静态变量名”调用</li>
<li>即静态变量的加载早于对象的创建</li>
<li>由于类只会加载一次, 则静态变量在内存中也只会存在一份, 存在方法区的静态域中.  <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类对象</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
<li>静态属性举例 : System.out, Math.PI,</li>
</ul>
</li>
</ul>
</li>
<li><p>使用static修饰方法: 静态方法</p>
<ul>
<li>随着类的加载而加载, 可以通过”类名.方法名”进行调用  <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类对象</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
<li>静态方法中, 只能调用静态的方法或属性</li>
<li>非静态方法中, 可以随便调用静态或非静态的方法和属性</li>
</ul>
</li>
<li><p>static 注意点<br> 在静态的方法中, 不能使用this和super关键字.<br> 因为这两个关键字都是基于当前对象的, 而静态方法加载时还没有对象</p>
<blockquote>
<p>可以从生命周期的角度理解</p>
</blockquote>
</li>
<li><p>在开发中如何确定一个属性是否要声明为static的?  </p>
<ul>
<li>属性是可以被多个对象所共享的, 不会随着对象的不同而不同  </li>
<li>类中的常量也常常声明为static  </li>
</ul>
</li>
<li><p>在开发中如何确定一个方法是否要声明为static的?</p>
<ul>
<li>操作静态属性的方法, 通常设置为static的</li>
<li>工具类中的方法, 通常设置为static的, 比如Math, Arrays, Collections</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="单例-Singleton-设计模式"><a href="#单例-Singleton-设计模式" class="headerlink" title="单例(Singleton)设计模式"></a>单例(Singleton)设计模式</h4><ul>
<li><p><strong>设计模式</strong>是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式.<br>设计模免去我们自己再思考和摸索. 就像是经典的棋谱, 不同的棋局, 我们用不同的”套路”</p>
</li>
<li><p>所谓类的单例设计模式, 就是采取一定的方法保证在整个的软件系统中, 对某个类<strong>只能存在一个对象实例</strong>, 并且该类只提供一个取得其对象实例的方法.<br>如果我们要让类在一个虚拟机中只能产生一个对象, 我们首先必须将类的构造器的访问权限设置为private, 这样, 就不能用new操作符在类的外部产生类的对象了, 但在类内部仍可以产生该类的对象.<br>因为在类的外部开始还无法得到类的对象, 只能调用该类的某个静态方法以返回类内部创建的对象, 静态方法只能访问类中的静态成员变量, 所以, 指向类内部产生的该类对象的变量也必须定义成静态的  </p>
<blockquote>
<p>设计模式:<br>创建型模式: 5种, 工厂方法模式, 抽象工厂模式, 单例模式, 建造者模式, 原型模式<br>结构型模式: 7种, 适配器模式, 装饰器模式, 代理模式, 外观模式, 桥接模式, 组合模式, 享元模式<br>行为型模式: 11种, 策略模式, 模板方法模式, 观察者模式, 迭代子模式, 责任链模式, 命令模式, 备忘录模式, 状态模式, 访问者模式, 中介者模式, 解释器模式</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单例设计模式:</span></span><br><span class="line"><span class="comment">*    1. 采取一定的方法保证在整个的软件系统中, 对某个类**只能存在一个对象实例**, 并且该类只提供一个取得其对象实例的方法.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    2. 如何实现?</span></span><br><span class="line"><span class="comment">*          饿汉式实现</span></span><br><span class="line"><span class="comment">*          懒汉式实现</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    3. 区分 饿汉式 和 懒汉式</span></span><br><span class="line"><span class="comment">*          饿汉式:</span></span><br><span class="line"><span class="comment">*            坏处: 对象加载时间过长</span></span><br><span class="line"><span class="comment">*            好处: 线程安全</span></span><br><span class="line"><span class="comment">*          懒汉式:</span></span><br><span class="line"><span class="comment">*            好处: 延迟对象的创建</span></span><br><span class="line"><span class="comment">*            坏处: 目前的写法是线程不安全的 --&gt; 到多线程内容时,再修改</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 饿汉式实现单例设计模式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 19:52</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank instance1 = Bank.getInstance();</span><br><span class="line">        Bank instance2 = Bank.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式 实现 单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 私有化类的构造器, 为了避免在外面造对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 内部创建类的对象</span></span><br><span class="line">    <span class="comment">// 4. 要求对象必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供公共的方法,返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式 实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 声明当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此对象必须为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 声明 public static 的返回当前类对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-2-理解main方法"><a href="#3-2-理解main方法" class="headerlink" title="3.2 理解main方法"></a>3.2 理解main方法</h3><ul>
<li><p>main()方法的使用说明:</p>
<ol>
<li><p>main()方法是程序的入口</p>
</li>
<li><p>main()方法也是一个普通的静态方法</p>
</li>
<li><p>main()方法也可以作为与控制台交互的方式(之前使用的是Scanner), 了解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main.main(<span class="keyword">new</span> String[<span class="number">10</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="comment">// 普通的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = <span class="string">"args_"</span> + i;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="3-3-代码块-初始化块"><a href="#3-3-代码块-初始化块" class="headerlink" title="3.3 代码块(初始化块)"></a>3.3 代码块(初始化块)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  代码块(初始化块)</span></span><br><span class="line"><span class="comment"> *    1. 代码块的作用: 用来初始化类或对象</span></span><br><span class="line"><span class="comment"> *    2. 只能用static修饰代码块, 即静态代码块, 与非静态代码块</span></span><br><span class="line"><span class="comment"> *    3. 静态代码块</span></span><br><span class="line"><span class="comment"> *       可以有输出语句</span></span><br><span class="line"><span class="comment"> *       随着类的加载而执行, 只执行一次</span></span><br><span class="line"><span class="comment"> *       作用: 初始化类的信息</span></span><br><span class="line"><span class="comment"> *       如果一个类中有多个静态代码块, 按先后顺序执行</span></span><br><span class="line"><span class="comment"> *       静态代码块先于非静态代码块执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4. 非静态代码块</span></span><br><span class="line"><span class="comment"> *       可以有输出语句</span></span><br><span class="line"><span class="comment"> *       随着对象的创建而执行, 每创建一个对象, 就执行一次</span></span><br><span class="line"><span class="comment"> *       作用: 可以在创建对象时, 对对象的属性进行初始化</span></span><br><span class="line"><span class="comment"> *       如果一个类中有多个非静态代码块, 按先后顺序执行</span></span><br><span class="line"><span class="comment"> *       非静态代码块中可以调用静态或非静态的方法和属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/1/31 20:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String desc = Person.desc;</span><br><span class="line"><span class="comment">//        Person.info();</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String desc = <span class="string">"i'm a person"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非static代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"instance initializer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static initializer"</span>);</span><br><span class="line">        desc = <span class="string">"i'm a good people"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-final-关键字"><a href="#3-4-final-关键字" class="headerlink" title="3.4 final 关键字"></a>3.4 final 关键字</h3><ul>
<li>final 关键字 : 最终的<ol>
<li>final 可以修饰 类, 方法, 变量</li>
<li>final 修饰类 : 此类不能被其他类所继承<br> 比如String, System, StringBuffer类</li>
<li>final 修饰方法 : 表明此方法不能被重写<br> 比如Object类的getClass()方法<br> (如果有native 关键字, 表明调用的是系统底层的方法)</li>
<li>finla 修饰变量: 此时的”变量”就称为常量, 不可以再次改变<ul>
<li>final 修饰成员变量(属性): 显式初始化, 代码块初始化, 构造器初始化</li>
<li>final 修饰局部变量:  <ul>
<li>尤其是final修饰形参时, 表明此形参是一个常量, 在调用方法时一旦赋值后, 在方法体内不能修改该参数</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>static final 修饰  <ul>
<li>成员变量(属性): 全局常量</li>
<li>方法</li>
</ul>
</li>
</ul>
<h3 id="3-5-抽象类与抽象方法"><a href="#3-5-抽象类与抽象方法" class="headerlink" title="3.5 抽象类与抽象方法"></a>3.5 抽象类与抽象方法</h3><ul>
<li><p>abstract 关键字</p>
<ol>
<li>用<code>abstract</code>关键字来修饰一个类,  这个类叫做<strong>抽象类</strong><ul>
<li>抽象类不能被实例化.</li>
<li>抽象类是用来被继承的, 抽象类的子类必须重写父类的抽象方法, 并提供方法体.</li>
<li>子类重写了父类所有的抽象方法后, 此子类方可实例化<br>若没有重写全部的抽象方法, 仍为抽象类</li>
<li>抽象类中可以定义构造器</li>
</ul>
</li>
<li>用<code>abstract</code>来修饰一个方法,  该方法叫做<strong>抽象方法</strong><ul>
<li>抽象方法：只有方法的声明, 没有方法的实现. 以分号结束：<br><code>public abstract void talk();</code></li>
<li>含有抽象方法的类必须被声明为抽象类, 反之, 抽象类中可以没有抽象方法</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>不能用<code>abstract</code>修饰 变量、代码块、构造器</strong></p>
</li>
<li><p><strong>不能用<code>abstract</code>修饰 私有方法、静态方法、 <code>final</code>的方法、 <code>final</code>的类</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A类中定义的m2方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B类中定义的m1方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.m1();</span><br><span class="line">        a.m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类的匿名子类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了一个匿名子类的对象,p</span></span><br><span class="line">    Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"AnnoTest.eat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"AnnoTest.walk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    p.eat();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="多态的应用-模板方法设计模式-TemplateMethod"><a href="#多态的应用-模板方法设计模式-TemplateMethod" class="headerlink" title="多态的应用: 模板方法设计模式(TemplateMethod)"></a>多态的应用: 模板方法设计模式(TemplateMethod)</h4><ul>
<li>抽象类体现的就是一种模板模式的设计, 抽象类作为多个子类的通用模板, 子类在抽象类的基础上进行扩展、改造, 但子类总体上会保留抽象类的行为方式.</li>
<li>解决的问题:<ul>
<li>当功能内部一部分实现是确定的,  一部分实现是不确定的. 这时可以把不确定的部分暴露出去, 让子类去实现</li>
<li>换句话说, 在软件开发中实现一个算法时, 整体步骤很固定、通用, 这些步骤已经在父类中写好了. 但是某些部分易变, 易变部分可以抽象出来, 供不同子类实现. 这就是一种模板模式</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类的应用, 模板方法的设计模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/2/1 13:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubTemplate t = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">        t.spendTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFlag)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算某段代码的执行时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">// 不确定的部分</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"spend time is (ms): "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-接口-interface"><a href="#3-6-接口-interface" class="headerlink" title="3.6 接口(interface)"></a>3.6 接口(interface)</h3><blockquote>
<p>接口就是规范, 定义的是一组规则, 体现了现实世界中“如果你是/要…则必须能…”的思想.  继承是一个”是不是”的关系, 而接口实现则是 “能不能”的关系.<br>接口的本质是契约, 标准, 规范, 就像我们的法律一样. 制定好后大家都要遵守.<br>有了接口, 就可以起到多继承的关系</p>
</blockquote>
<ul>
<li>接口(<code>interface</code>)是抽象方法和常量值定义的集合</li>
<li>接口的特点:<ul>
<li>用interface来定义</li>
<li>接口中的所有成员变量都<em>默认是由public static final</em>修饰的</li>
<li>接口中的所有抽象方法都<em>默认是由public abstract</em>修饰的</li>
<li><strong>接口中没有构造器</strong></li>
<li>接口采用多继承机制</li>
</ul>
</li>
<li>接口的使用<ol>
<li>使用interface 定义</li>
<li>Java中接口和类是并列的两个结构</li>
<li>定义接口<ol>
<li><strong>JDK7及以前</strong>, 只能定义全局常量和抽象方法<ul>
<li>全局常量 : public static final, 默认就是, 可以不写</li>
<li>抽象方法 : public abstract,  默认就是, 可以不写</li>
</ul>
</li>
<li><strong>JDK8</strong>: 除了定义全局常量和抽象方法, 还可以定义静态方法, 默认方法</li>
</ol>
</li>
<li>接口中不可以定义构造器, 即接口不可以实例化</li>
<li>Java开发中, 类通过实现(implements)接口, 来遵守接口中的规则<br> 如果实现类, 实现了接口中所有的抽象方法, 则该实现类可以实例化<br> 如果实现类, 有抽象方法没有实现, 则该实现类为抽象类</li>
<li>Java中可以实现多个接口, 实现了多继承</li>
<li>接口与接口之间也可以多继承  </li>
</ol>
</li>
</ul>
<h4 id="JDK8-接口特性"><a href="#JDK8-接口特性" class="headerlink" title="JDK8 接口特性"></a>JDK8 接口特性</h4><ul>
<li><p>除了定义全局常量和抽象方法, 还可以定义静态方法, 默认方法</p>
<ul>
<li><p>接口中定义的静态方法, 只能通过接口来调用, (类似工具类的用法)</p>
</li>
<li><p>通过实现类的对象, 可以调用接口中定义的默认方法</p>
</li>
<li><p>可以在实现类中重写接口的默认方法</p>
</li>
<li><p>如果子类(实现类) 继承的父类和实现的接口中定义了同名同参数的方法, 在子类没有重写该方法的前提下, 默认调用父类中的方法 <code>--&gt;</code> 类优先原则(针对方法)</p>
</li>
<li><p>如果实现类实现了多个接口, 多个接口中定义了同名同参数的默认方法, 在实现类没有重写此方法时, 报错 <code>--&gt;</code> 接口冲突 <code>--&gt;</code> 必须在实现类中重写此方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类(实现类)的方法中, 调用父类接口中重写的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"override method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method2(); <span class="comment">// 自己重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method2(); <span class="comment">// 父类声明的同名方法</span></span><br><span class="line">        CompareA.<span class="keyword">super</span>.method2(); <span class="comment">// 调用接口中的同名默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="接口中的代理模式-Proxy-基础知识"><a href="#接口中的代理模式-Proxy-基础知识" class="headerlink" title="接口中的代理模式(Proxy)基础知识"></a>接口中的代理模式(Proxy)基础知识</h4><ul>
<li><p>代理模式是Java开发中使用较多的一种设计模式. 代理设计就是为其他对象提供一种代理以控制对这个对象的访问</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  接口的应用: 代理模式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/1 16:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line"></span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"真实的服务器访问网络"</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.work = work;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"check service"</span>);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        work.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<ul>
<li>安全代理： 屏蔽对真实角色的直接访问</li>
<li>远程代理： 通过代理类处理远程方法调用(RMI)</li>
<li>延迟加载： 先加载轻量级的代理对象,  真正需要再加载真实对象比如你要开发一个大文档查看软件,  大文档中有大的图片,  有可能一个图片有100MB,  在打开文件时,  不可能将所有的图片都显示出来,  这样就可以使用代理模式,  当需要查看图片时,  用proxy来进行大图片的打开</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>静态代理(静态定义代理类)</li>
<li>动态代理(动态生成代理类): JDK自带的动态代理,  需要反射等知识</li>
</ul>
</li>
</ul>
<h4 id="工厂模式简介"><a href="#工厂模式简介" class="headerlink" title="工厂模式简介"></a>工厂模式简介</h4><ul>
<li>工厂模式： 实现了创建者(new对象)与调用者的分离,  即将创建对象的具体过程屏蔽隔离起来, 达到提高灵活性的目的.</li>
<li>其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护, 解决方式就是一个“分工”</li>
<li>详见文档.</li>
</ul>
<h3 id="3-7-内部类"><a href="#3-7-内部类" class="headerlink" title="3.7 内部类"></a>3.7 内部类</h3><ul>
<li><p>内部类</p>
<ol>
<li><p>Java中允许将一个类A声明在类B中, 类A就是内部类, B称为外部类</p>
</li>
<li><p>内部类的分类:<br> 成员内部类: 静态与非静态成员内部类<br> 局部内部类: (方法内, 代码块内, 构造器内)</p>
</li>
<li><p>成员内部类:</p>
<ul>
<li><p>一方面, 作为外部类的成员  </p>
<ul>
<li>可以调用外部类的结构(在权限允许的情况下)</li>
<li>可以被static修饰</li>
<li>可以被权限修饰符修饰</li>
</ul>
</li>
<li><p>另一方面, 作为一个类  </p>
<ul>
<li>类内可以定义属性, 方法, 构造器等</li>
<li>可以被final修饰, 表示此类不能被继承, 即一般情况可以被继承</li>
<li>可以把abstract修饰</li>
</ul>
</li>
</ul>
</li>
<li><p>关注的点:</p>
<ol>
<li><p>如何实例化成员内部类的对象</p>
</li>
<li><p>如果在成员内部类中区分调用外部类的结构</p>
</li>
<li><p>开发中局部内部类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  内部类  1</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/2 11:22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建静态成员内部类实例</span></span><br><span class="line">        Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建非静态成员内部类实例</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Person.Cat cat = p.<span class="keyword">new</span> Cat();</span><br><span class="line">        cat.hana();</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        cat.display(<span class="string">"maomaoma"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Dog.show"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态成员内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">        String name = <span class="string">"cat"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hana</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Cat.hana"</span>);</span><br><span class="line">            Person.<span class="keyword">this</span>.eat(); <span class="comment">// 调用外部类的非静态属性</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"name = "</span> + name); <span class="comment">// 方法的形参</span></span><br><span class="line">            System.out.println(<span class="string">"this.name = "</span> + <span class="keyword">this</span>.name); <span class="comment">// 内部类的属性</span></span><br><span class="line">            System.out.println(<span class="string">"Person.this.name = "</span> + Person.<span class="keyword">this</span>.name); <span class="comment">// 外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开发中的应用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实现了Comparable接口的类,  局部内部类</span></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    方式二</span></span><br><span class="line"><span class="comment">//    return new Comparable() &#123;</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>内部类的加载顺序</p>
<ol>
<li>外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。</li>
<li>实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。</li>
<li>直接调用静态内部类时，外部类不会加载</li>
</ol>
</li>
</ul>
<h2 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h2><h3 id="4-1-异常处理概述"><a href="#4-1-异常处理概述" class="headerlink" title="4.1 异常处理概述"></a>4.1 异常处理概述</h3><ul>
<li>异常：在Java语言中, 将程序执行中发生的不正常情况称为”异常”(开发过程中的语法错误和逻辑错误不是异常)</li>
<li>Java程序在执行过程中所发生的异常事件可分为两类:  <ul>
<li><strong>Error</strong>： Java虚拟机无法解决的严重问题<br>如： JVM系统内部错误、 资源耗尽等严重情况. 比如：StackOverflowError和OOM.  <em>一般不编写针对性的代码进行处理</em>.</li>
<li><strong>Exception</strong>: 其它因编程错误或偶然的外在因素导致的一般性问题, 可以使用针对性的代码进行处理.  <ul>
<li>空指针访问  </li>
<li>试图读取不存在的文件  </li>
<li>网络连接中断  </li>
<li>数组角标越界  </li>
</ul>
</li>
<li>对于这些错误, 一般有两种解决方法：  <ul>
<li>一是遇到错误就终止程序的运行.  </li>
<li>另一种方法是由程序员在编写程序时, 就考虑到错误的检测、 错误消息的提示, 以及错误的处理.</li>
</ul>
</li>
<li>捕获错误最理想的是在编译期间, 但有的错误只有在运行时才会发生. 比如： 除数为0, 数组下标越界等<ul>
<li>分类: <strong>编译时异常</strong>和<strong>运行时异常</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-常见异常"><a href="#4-2-常见异常" class="headerlink" title="4.2 常见异常"></a>4.2 常见异常</h3><ul>
<li><p>异常体系结构</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.lang.Throwoable</span></span><br><span class="line"><span class="comment">    |----java.lang.Error: 一般不编写代码处理</span></span><br><span class="line"><span class="comment">    |---- java.lang.Exception: 可以进行异常的处理</span></span><br><span class="line"><span class="comment">        |----编译时异常(checked)</span></span><br><span class="line"><span class="comment">            |----IOException</span></span><br><span class="line"><span class="comment">                |----FileNotFoundException</span></span><br><span class="line"><span class="comment">            |----ClassNotFoundException</span></span><br><span class="line"><span class="comment">        |----运行时异常(unchecked)</span></span><br><span class="line"><span class="comment">            |----NullPointException</span></span><br><span class="line"><span class="comment">            |----ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">            |----ClassCastExction</span></span><br><span class="line"><span class="comment">            |----NumberFormatException</span></span><br><span class="line"><span class="comment">            |----InputMismatchException</span></span><br><span class="line"><span class="comment">            |----ArithmeticException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-3-异常处理机制一-try-catch-finally"><a href="#4-3-异常处理机制一-try-catch-finally" class="headerlink" title="4.3 异常处理机制一: try-catch-finally"></a>4.3 异常处理机制一: try-catch-finally</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally 是可选的, 不是必须的, finally中是一定会执行的代码,(不管try中是否有return, catch中还有异常)<ul>
<li>一般用于释放资源</li>
</ul>
</li>
<li>常用的异常处理的方法: <code>String getMessage()</code>  <code>void printStackTrace()</code></li>
</ul>
<h3 id="4-4-异常处理机制二-throws-异常类型"><a href="#4-4-异常处理机制二-throws-异常类型" class="headerlink" title="4.4 异常处理机制二: throws + 异常类型"></a>4.4 异常处理机制二: throws + 异常类型</h3><ul>
<li>throws + 异常类型 写在方法的声明处, 指明此方法执行时, 可能会抛出的异常类型. 一旦方法执行时, 出现异常, 仍会在异常代码处生成一个异常类的对象, 此对象满足 throws 后异常类型时, 就会被抛出. 异常代码后续的代码就不再执行</li>
<li>手动抛出异常: <code>throw new RuntimeException(&quot;错误信息&quot;)</code></li>
</ul>
<h3 id="4-6-自定义异常类"><a href="#4-6-自定义异常类" class="headerlink" title="4.6 自定义异常类"></a>4.6 自定义异常类</h3><ul>
<li>如何自定义异常类<ol>
<li>继承于现有的异常结构: <code>RuntimeException</code>  <code>Exception</code></li>
<li>提供全区常量serialVersionUID, 类的唯一标识, 序列号</li>
<li>提供重载的构造器</li>
</ol>
</li>
</ul>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5. 多线程"></a>5. 多线程</h2><h3 id="5-1-基本概念-程序-进程-线程"><a href="#5-1-基本概念-程序-进程-线程" class="headerlink" title="5.1 基本概念: 程序, 进程, 线程"></a>5.1 基本概念: 程序, 进程, 线程</h3><ul>
<li><p>程序(program): 是为完成特定任务、用某种语言编写的一组指令的集合. 即指一段静态的代码, 静态对象</p>
</li>
<li><p>进程(process): 是程序的一次执行过程, 或是正在运行的一个程序. 是一个动态的过程：有它自身的产生、存在和消亡的过程.  ——生命周期</p>
<ul>
<li>程序是静态的, 进程是动态的</li>
<li>进程作为资源分配的单位,  系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li><p>线程(thread), 进程可进一步细化为线程, 是一个程序内部的一条执行路径</p>
<ul>
<li>若一个进程同一时间并行执行多个线程, 就是支持多线程的</li>
<li>线程作为调度和执行的单位, 每个线程拥有独立的运行栈和程序计数器(pc), 线程切换的开销小  </li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象, 可以访问相同的变量和对象. 这就使得线程间通信更简便、高效. 但多个线程操作共享的系统资源可能就会带来安全的隐患</li>
</ul>
</li>
<li><p>单核CPU和多核CPU的理解  </p>
<ul>
<li>单核CPU, 其实是一种假的多线程, 因为在一个时间单元内, 也只能执行一个线程的任务.</li>
<li>多核CPU, 才能更好的发挥多线程的效率. (现在的服务器都是多核的)</li>
<li>一个Java应用程序java.exe, 其实至少有三个线程： main()主线程,  gc()垃圾回收线程, 异常处理线程. 当然如果发生异常, 会影响主线程.</li>
</ul>
</li>
<li><p>并行与并发  </p>
<ul>
<li>并行： 多个CPU同时执行多个任务. 比如：多个人同时做不同的事</li>
<li>并发： 一个CPU(采用时间片)同时执行多个任务</li>
</ul>
</li>
<li><p>使用多线程的优点</p>
<ol>
<li>提高应用程序的响应. 对图形化界面更有意义, 可增强用户体验</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构. 将既长又复杂的进程分为多个线程, 独立运行, 利于理解和修改</li>
</ol>
</li>
<li><p>何时需要多线程</p>
<ul>
<li>程序需要同时执行两个或多个任务</li>
<li>程序需要实现一些需要等待的任务时, 如用户输入、文件读写操作、网络操作、搜索等</li>
<li>需要一些后台运行的程序时</li>
</ul>
</li>
</ul>
<h3 id="5-2-线程的创建和使用"><a href="#5-2-线程的创建和使用" class="headerlink" title="5.2 线程的创建和使用"></a>5.2 线程的创建和使用</h3><ul>
<li><p>Java语言的JVM允许程序运行多个线程, 它通过<code>java.lang.Thread</code>类来体现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一. 创建多线程的方法一 : 继承于Thread类</span></span><br><span class="line"><span class="comment">*    1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="comment">*    2. 重写Thread类的run()方法 --&gt; 此线程想要执行的操作</span></span><br><span class="line"><span class="comment">*    3. 创建Thread子类的对象</span></span><br><span class="line"><span class="comment">*    4. 通过此对象调用start():  </span></span><br><span class="line"><span class="comment">*       a. 启动当前前程</span></span><br><span class="line"><span class="comment">*       b. 调用当前线程的run()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    注: 不能通过直接调用run()方法的方式启动线程</span></span><br><span class="line"><span class="comment">*        再启动一个线程, 不能用已经start()的线程去执行, 会报IllegalThreadStatusException异常</span></span><br><span class="line"><span class="comment">*        需要创新创建一个线程的对象</span></span><br><span class="line"><span class="comment">* 二. 创建多线程的方法二 : 实现Runnable接口</span></span><br><span class="line"><span class="comment">*    1. 创建一个实现Runnable接口的类</span></span><br><span class="line"><span class="comment">*    2. 实现类中实现抽象方法run()</span></span><br><span class="line"><span class="comment">*    3. 创建实现类的对象</span></span><br><span class="line"><span class="comment">*    4. 将此对象作为参数传递到Thread类的构造器中, 创建Thread类的对象</span></span><br><span class="line"><span class="comment">*    5. 通过Thread类的对象调用start()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 三. 比较2种创建多线程的区别:</span></span><br><span class="line"><span class="comment">*    开发中, 优先选择实现的Runnable接口的方式,</span></span><br><span class="line"><span class="comment">*      1. 实现的方式没有类的单继承的局限性</span></span><br><span class="line"><span class="comment">*      2. 实现的方式适合处理有共享数据的情况, 不用声明为static的</span></span><br><span class="line"><span class="comment">*    联系:</span></span><br><span class="line"><span class="comment">*      Thread类本身也实现了Runnable接口</span></span><br><span class="line"><span class="comment">*      两种方式都要重写run()方法, 将线程执行的逻辑声明在方法种</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/2/3 11:16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Thread类中的常用方法</span></span><br><span class="line"><span class="comment">*    1. start() : 启动当前线程; 执行run()方法</span></span><br><span class="line"><span class="comment">*    2. run() : 通常要重写Thread类中的此����法, 将创建线程想要�����行的功能声明在该方法中</span></span><br><span class="line"><span class="comment">*    3. currentThread() : 静态方法, 返回执行当前代码的线程</span></span><br><span class="line"><span class="comment">*    4. getName() : 获取当前线程的名字</span></span><br><span class="line"><span class="comment">*    5. setName() : 设置当前线程的名字</span></span><br><span class="line"><span class="comment">*    6. yield() : 释放当前CPU的执行权, 但下一秒是谁执行就看谁抢到执行权</span></span><br><span class="line"><span class="comment">*    7. join() : 在线程A中调用线程B的join()方法, 线程A进入阻塞状态, 直到线程B执行完后, 线程A才结束阻塞状态</span></span><br><span class="line"><span class="comment">*    8. stop() : 已过时. 强制结束当前线程</span></span><br><span class="line"><span class="comment">*    9. sleep(long millisTime) : 让当前线程"睡眠"指定的millisTime毫秒, 在指定的时间内, 当前线程是阻塞状态</span></span><br><span class="line"><span class="comment">*    10. isAlive() : 判断当前线程是否还存活</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   线程的优先级:</span></span><br><span class="line"><span class="comment">*      MIN_PRIORITY = 1;  低优先级</span></span><br><span class="line"><span class="comment">*      NORM_PRIORITY = 5; 默认优先级</span></span><br><span class="line"><span class="comment">*      MAX_PRIORITY = 10; 高优先级</span></span><br><span class="line"><span class="comment">*   如何获得和设置当前线程的优先级:</span></span><br><span class="line"><span class="comment">*     getPriority() : 获取</span></span><br><span class="line"><span class="comment">*     setPriority(int p): 设置</span></span><br><span class="line"><span class="comment">*   优先级高只是有可能会优先执行, 不是优先级高的执行完后再执行优先级低的</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/2/3 11:42</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>); <span class="comment">// 该操作是在主线程中执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-3-线程的生命周期"><a href="#5-3-线程的生命周期" class="headerlink" title="5.3 线程的生命周期"></a>5.3 线程的生命周期</h3><ul>
<li><p>JDK中用Thread.State类定义了线程的几种状态</p>
<ul>
<li>新建(new): 当一个Thread类或其子类的对象被声明并创建时, 新生的线程对象处于新建状态</li>
<li>就绪: 处于新建状态的线程被start()后, 将进入线程队列等待CPU时间片, 此时它已具备了运行的条件, 只是没分配到CPU资源</li>
<li>运行: 当就绪的线程被调度并获得CPU资源时,便进入运行状态, run()方法定义了线程的操作和功能</li>
<li>阻塞: 在某种特殊情况下, 被人为挂起或执行输入输出操作时, 让出 CPU 并临时中止自己的执行, 进入阻塞状态</li>
<li>死亡: 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><img src="https://i.loli.net/2020/03/20/J24ajVgFIp5Yhvr.png" alt="线程的声明周期.png"></p>
</li>
</ul>
<h3 id="5-4-线程的同步"><a href="#5-4-线程的同步" class="headerlink" title="5.4 线程的同步"></a>5.4 线程的同步</h3><ul>
<li><p>线程安全问题  </p>
<ul>
<li><p>多个线程执行的不确定性引起执行结果的不稳定</p>
</li>
<li><p>多个线程对数据的共享, 会造成操作的不完整性, 会破坏数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  创建3个卖票窗口, 总票数 100, 存在线程安全问题</span></span><br><span class="line"><span class="comment">*    解决线程安全:</span></span><br><span class="line"><span class="comment">*      1. 问题出现的原因:</span></span><br><span class="line"><span class="comment">*        当某个线程在操作车票的过程中, 尚未完成操作时 ,其他线程参与进来, 也操作车票</span></span><br><span class="line"><span class="comment">*      2. 如何解决:</span></span><br><span class="line"><span class="comment">*        当一个线程A在操作共享数据时, 其他线程不能参与进来, 直到A操作完成, 其他线程才可以开始操作</span></span><br><span class="line"><span class="comment">*        即使A出现了阻塞也不能被改变.</span></span><br><span class="line"><span class="comment">*      3. Java中, 通过同步机制解决线程的安全问题</span></span><br><span class="line"><span class="comment">*        方式一: 同步代码块</span></span><br><span class="line"><span class="comment">*          synchronized(同步监视器)&#123;</span></span><br><span class="line"><span class="comment">*              // 需要同步的代码</span></span><br><span class="line"><span class="comment">*          &#125;</span></span><br><span class="line"><span class="comment">*          说明:</span></span><br><span class="line"><span class="comment">*            1. 操作共享数据的代码, 即是需要同步的代码, 不能括多了(出错), 也不能括少了(没有解决安全问题)</span></span><br><span class="line"><span class="comment">*            2. 共享数据 : 多个线程共同操作的变量, 比如本问题中的 ticket</span></span><br><span class="line"><span class="comment">*            3. 同步监视器 : 俗称, 锁. 任何一个类的对象, 都可以充当锁</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*               要求: 多个线程必须共用一把锁, 即只有一个锁对象</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*               补充: 在实现Runnable接口创建多线程的方式中, 可以考虑使用this充当同步监视器</span></span><br><span class="line"><span class="comment">*                    在继承Thread类创建多线程的方式中, 慎用this充当同步监视器, 考虑使用当前类充当同步监视器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        方式二: 同步方法</span></span><br><span class="line"><span class="comment">*            如果操作共享数据的代码完整的声明在一个方法中, 不妨将该方法声明为同步的, 则该方法为同步方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*            1. 同步方法仍然涉及到同步监视器, 只是不用我们显式的声明</span></span><br><span class="line"><span class="comment">*            2. 非静态的同步方法, 同步监视器是: this</span></span><br><span class="line"><span class="comment">*               静态的同步方法, 同步监视器是: 当前类本身</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        方式三: Lock锁 --- <span class="doctag">@since</span> jdk5.0</span></span><br><span class="line"><span class="comment">*           通过显式定义同步锁对象来实现同步. 同步锁使用Lock对象充当</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        synchronized 与 lock 的区别</span></span><br><span class="line"><span class="comment">*          相同 : 二者都可以解决线程安全问题</span></span><br><span class="line"><span class="comment">*          不同 : synchronized 机制在执行完相应的同步代码后, 自动释放同步监视器</span></span><br><span class="line"><span class="comment">*                 lock 需要手动的启动同步, 同时也要手动结束同步, 更灵活</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*      5. 同步优劣:</span></span><br><span class="line"><span class="comment">*         好处 : 解决了线程安全问题</span></span><br><span class="line"><span class="comment">*         局限 : 操作同步代码时, 相当于是一个单线程的过程, 效率降低</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/2/3 14:42</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window w = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123; <span class="comment">// obj  同步监视器</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">": 卖票, 票号为: "</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化lock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock(); <span class="comment">// 调用lock(); 上锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"售票, 票号为: "</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>死锁:</p>
<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃, 都在等待对方放弃自己需要的同步资源, 就形成了线程的死锁</li>
<li>出现死锁后, 不会出现异常, 不会出现提示, 只是所有的线程都处于阻塞状态, 无法继续, 使用时要注意避免出现死锁</li>
</ul>
</li>
</ul>
<h3 id="5-5-线程的通信"><a href="#5-5-线程的通信" class="headerlink" title="5.5 线程的通信"></a>5.5 线程的通信</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程通信举例: 使用两个线程打印 1-100, 线程1,2 交替打印</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 涉及到的方法:</span></span><br><span class="line"><span class="comment"> *   wait() : 一旦执行此方法, 当前线程就进入阻塞状态, 并释放同步监视器</span></span><br><span class="line"><span class="comment"> *   notify() : 一旦执行此方法, 就会唤醒被wait的一个线程, 如果有多个线程被wait, 就会唤醒优先级高那个</span></span><br><span class="line"><span class="comment"> *   notifyAll() : 一旦执行此方法, 就会唤醒被wait的所有线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *     说明:</span></span><br><span class="line"><span class="comment"> *        1. wait() notify() notifyAll() 三个方法, 必须使用在同步代码块或同步方法中</span></span><br><span class="line"><span class="comment"> *        2. wait() notify() notifyAll() 三个方法的调用者必须是同步代码块或同步方法中的同步监视器</span></span><br><span class="line"><span class="comment"> *           否则会出现IllegalMonitorStateException异常</span></span><br><span class="line"><span class="comment"> *        3. wait() notify() notifyAll() 三个方法定义在Object类中, (与之前说的任何一个类都可以当同步监视器联系起来)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/3 20:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number n = <span class="keyword">new</span> Number();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(n);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(n);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"thread-1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"thread-2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((i--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.notify();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 使得调用如下wait()方法的线程进入阻塞状态, wait()会释放锁, sleep()不会释放锁</span></span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait() 与 sleep() 方法的区别<ol>
<li>相同点: 都可以使当前线程进入阻塞状态</li>
<li>不同点:  <ol>
<li>两个方法声明的位置不同, Thread类中声明sleep(), wait()是在Object类中声明的</li>
<li>调用的范围不同:<br>sleep() 没有要求, 可以在任何需要的情况下调用<br>wait()方法必须使用同步监视器调用, 即必须在同步代码块或同步方法中调用  </li>
<li>slee()方法不会释放锁, 而wait()方法会自动释放锁对象</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="5-6-JDK-5-0新增的线程创建方式"><a href="#5-6-JDK-5-0新增的线程创建方式" class="headerlink" title="5.6 JDK 5.0新增的线程创建方式"></a>5.6 JDK 5.0新增的线程创建方式</h3><h4 id="1-实现Callable接口"><a href="#1-实现Callable接口" class="headerlink" title="1. 实现Callable接口"></a>1. 实现Callable接口</h4><ul>
<li><p>与使用Runnable相比, Callable功能更强大些</p>
<ul>
<li>相比run()方法, 可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类, 比如获取返回结果<ul>
<li>Future接口<ul>
<li>可以对具体Runnable、 Callable任务的执行结果进行取消、查询是否完成、获取结果等.  </li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口. 它既可以作为Runnable被线程执行, 又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤:</p>
<ol>
<li><p>创建一个实现Callable接口的实现类</p>
</li>
<li><p>重写call方法, 将此线程要执行的操作声明在call中</p>
</li>
<li><p>创建callable接口的实现类对象</p>
</li>
<li><p>将此callable接口的实现类对象作为参数传递到FutureTask构造器中,创建FutureTask对象</p>
</li>
<li><p>将FutureTask对象传入Thread类的构造器中, 开启线程</p>
</li>
<li><p>获取Callable中call方法的返回值(可选)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建新城的方式三: 实现Callable接口</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> jdk 5.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/4 16:55</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 1. 创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 2. 重写call方法, 将此线程要执行的操作声明在call中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3, 创建callable接口的实现类对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">// 4. 将此callable接口的实现类对象作为参数传递到FutureTask构造器中,创建FutureTask对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">// 5. 将FutureTask对象传入Thread类的构造器中, 开启线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 获取Callable中call方法的返回值(可选)</span></span><br><span class="line">            <span class="comment">// get()方法的返回值即为 futureTask构造器参数Callable实现类重写的call()方法的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"sum = "</span>+sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="2-使用线程池"><a href="#2-使用线程池" class="headerlink" title="2. 使用线程池"></a>2. 使用线程池</h4><ul>
<li><p>背景:<br>经常创建和销毁、使用量特别大的资源, 比如并发情况下的线程, 对性能影响很大</p>
</li>
<li><p>思路:<br>提前创建好多个线程, 放入线程池中, 使用时直接获取, 使用完放回池中. 可以避免频繁创建销毁、实现重复利用. 类似生活中的公共交通工具</p>
</li>
<li><p>好处:  </p>
<ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程, 不需要每次都创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK 5.0起提供了线程池相关API： <code>ExecutorService</code> 和 <code>Executors</code></p>
</li>
<li><p><code>ExecutorService</code>：真正的线程池接口.常见子类<code>ThreadPoolExecutor</code></p>
<ul>
<li><code>void execute(Runnable command)</code> ：执行任务/命令, 没有返回值, 一般用来执行<code>Runnable</code></li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务, 有返回值, 一般又来执行<code>Callable</code></li>
<li><code>void shutdown()</code> ：关闭连接池</li>
</ul>
</li>
<li><p><code>Executors</code>：工具类、线程池的工厂类, 用于创建并返回不同类型的线程池</p>
<ul>
<li><p><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</p>
</li>
<li><p><code>Executors.newFixedThreadPool(n)</code>; 创建一个可重用固定线程数的线程池</p>
</li>
<li><p><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</p>
</li>
<li><p><code>Executors.newScheduledThreadPool(n)</code>：创建一个线程池, 它可安排在给定延迟后运行命令或者定期地执行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池创建线程</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/4 17:20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 提供只当线程数量的连接池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">// 设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line">        service1.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 执行指定线程的操作, 需要提供实现Runnable或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread()); <span class="comment">// 适合Runnable</span></span><br><span class="line"><span class="comment">//        service.submit(); // 适合使用Callable</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="6-Java常用类"><a href="#6-Java常用类" class="headerlink" title="6. Java常用类"></a>6. Java常用类</h2><h3 id="6-1-字符串相关的类"><a href="#6-1-字符串相关的类" class="headerlink" title="6.1 字符串相关的类"></a>6.1 字符串相关的类</h3><ul>
<li><p>String类： 代表字符串. Java 程序中的所有字符串字面值(如 “abc” )都作为此类的实例实现</p>
<ul>
<li><p>String是一个final类, 不可被继承</p>
</li>
<li><p>字符串是常量, 用双引号引起来表示. 它们的值在创建之后不能更改</p>
</li>
<li><p>String对象的字符内容是存储在一个字符数组value[]中的</p>
</li>
<li><p>String 实现了serializable接口, 表示支持序列化</p>
<pre><code>实现了Comparable接口, 表示可以比较大小</code></pre></li>
<li><p>String内部定义了final char[] value用于存储字符串数据</p>
</li>
<li><p>String 代表不可变的字符序列, 即不可变性</p>
<ul>
<li>对字符串重新赋值时, 重写指定内区区域, 不是对原有的value进行赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// default to 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常量式(字面量)赋值创建, 放在方法区常量池空间(将被常量化)  </p>
</li>
<li><p>常量池中不会存放相同内容的字符串</p>
</li>
</ul>
</li>
<li><p>String类的创建</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>; <span class="comment">// 声明在字符串常量池中</span></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(); <span class="comment">// 在堆空间中开辟地址</span></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(String original);</span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>string创建内存结构1<br><img src="https://i.loli.net/2020/03/20/iIxaUHAV6ZcJWXO.png" alt="string1.png"></p>
</li>
<li><p>string创建内存结构2<br><img src="https://i.loli.net/2020/03/20/e3cDtNvZF8r4mnS.png" alt="string2.png"></p>
</li>
<li><p><strong>常量与常量</strong>的拼接结果在常量池中</p>
</li>
<li><p>只要其中一个是变量, 那么结果就在堆中</p>
</li>
<li><p>如果拼接的结果调用intern()方法, 返回值就在常量池中</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a7 = <span class="string">"helloWorld"</span>;</span><br><span class="line">String a3 = <span class="string">"hello"</span> + <span class="string">"World"</span>;</span><br><span class="line">String a4 = a1 + <span class="string">"World"</span>;</span><br><span class="line">String a5 = <span class="string">"hello"</span> + a2;</span><br><span class="line">String a6 = a1 + a2;</span><br><span class="line"><span class="keyword">final</span> String a9 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">String a11 = a9+ <span class="string">"World"</span>; <span class="comment">// 常量拼接常量, 在常量池中</span></span><br><span class="line">System.out.println(a11 == a7); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(a3 == a7); <span class="comment">// true</span></span><br><span class="line">System.out.println(a4 == a3); <span class="comment">// false</span></span><br><span class="line">System.out.println(a5 == a3); <span class="comment">// false</span></span><br><span class="line">System.out.println(a6 == a3); <span class="comment">// false</span></span><br><span class="line">System.out.println(a4 == a6); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String a8 = a6.intern(); <span class="comment">// 此时返回的是在常量池中存在的内容的地址</span></span><br><span class="line">System.out.println(a8 == a3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>： 返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>： 判断是否是空字符串： return value.length </span>== <span class="number">0</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>： 使用默认语言环境,  将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>： 使用默认语言环境,  将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span>： 返回字符串的副本,  忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>： 比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>： 与equals方法类似,  忽略大小写</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>： 将指定字符串连接到此字符串的结尾. 等价于用“+”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>： 比较两个字符串的大小</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>： 返回一个新的字符串,  它是此字符串的从beginIndex开始截取到最后的一个子字符串.</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ： 返回一个新字符串,  它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>： 测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>： 测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>： 测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>： 当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时, 返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>： 返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>： 返回指定子字符串在此字符串中第一次出现处的索引, 从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>： 返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>： 返回指定子字符串在此字符串中最后一次出现处的索引, 从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注： indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>： 返回一个新的字符串,  它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的.</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>： 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串.</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串.</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>： 告知此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span>： 根据给定正则表达式的匹配拆分此字符串.</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>： 根据匹配给定的正则表达式来拆分此字符串,  最多不超过limit个,  如果超过了,  剩下的全部都放到最后一个元素中</span></span><br></pre></td></tr></table></figure>

<h4 id="StringBuffer-与-StringBuilder"><a href="#StringBuffer-与-StringBuilder" class="headerlink" title="StringBuffer 与 StringBuilder"></a>StringBuffer 与 StringBuilder</h4><ul>
<li><p>String 与 StringBuffer 和 StringBuilder 的区别</p>
<ul>
<li><p>String: 不可变的字符序列, 底层使用char[]存储</p>
</li>
<li><p>StringBuffer:可变的字符序列, 线程安全的(都是同步方法),效率低, 底层使用char[]存储</p>
</li>
<li><p>StringBuilder:可变的字符序列, JDK5.0新增的, 线程不安全, 效率高, 底层使用char[]存储</p>
</li>
<li><p>源码分析</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(); <span class="comment">// char[] value = new char[0];</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// char[] value = new char[]&#123;'a', 'b', 'c'&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16]; 底层创建了长度16的数组</span></span><br><span class="line">sb1.append(<span class="string">'a'</span>); <span class="comment">// value[0] = 'a';</span></span><br><span class="line">sb1.append(<span class="string">'b'</span>); <span class="comment">// value[1] = 'b';</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">// char[] value = new char["abc".length() + 16];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容问题, 如果要添加的数据底层数组放不下, 就需要扩容底层数组</span></span><br><span class="line"><span class="comment">// 默认情况下, 扩容为原来的2倍+2, 同时将原有数组的元素复制到新的数组中</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>效率排序:<br>StringBuilder &gt; StringBuffer &gt; String</p>
</li>
</ul>
<h3 id="6-2-JDK-8之前的日期时间API"><a href="#6-2-JDK-8之前的日期时间API" class="headerlink" title="6.2 JDK 8之前的日期时间API"></a>6.2 JDK 8之前的日期时间API</h3><ul>
<li>计算世界时间的主要标准有：<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
</li>
</ul>
<ol>
<li><p>java.lang.System类  </p>
<ul>
<li>System类提供的<code>public static long currentTimeMillis()</code></li>
<li>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差 — 称为时间戳</li>
<li>此方法适于计算时间差</li>
</ul>
</li>
<li><p>java.util.Date类 : 表示特定的瞬间, 精确到毫秒</p>
<ul>
<li><p>构造器：</p>
<ul>
<li>Date()： 使用无参构造器创建的对象可以获取本地当前时间.</li>
<li>Date(long date)</li>
</ul>
</li>
<li><p>常用方法:  </p>
<ul>
<li><p>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</p>
</li>
<li><p>toString():把此 Date 对象转换为以下形式的 <code>String： dow mon ddhh:mm:ss zzz yyyy</code> 其中： <code>dow</code> 是一周中的某一天 <code>(Sun, Mon, Tue,Wed, Thu, Fri, Sat)</code>, <code>zzz</code>是时间标准</p>
</li>
<li><p>其它很多方法都过时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">System.out.println(date.getTime());</span><br><span class="line"></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date(date.getTime());</span><br><span class="line">System.out.println(date1.getTime());</span><br><span class="line">System.out.println(date1.toString());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>java.text.SimpleDateFormat类</p>
<ul>
<li><p>Date类的API不易于国际化, 大多被废弃了  </p>
</li>
<li><p><code>java.text.SimpleDateFormat</code>类是一个不与语言环境有关的方式来格式化和解析日期的具体类.</p>
<ul>
<li>格式化：日期-&gt;文本</li>
<li>解析：  文本-&gt;日期</li>
</ul>
</li>
<li><p>格式化：</p>
<ul>
<li><code>SimpleDateFormat()</code> ：默认的模式和语言环境创建对象</li>
<li><code>public SimpleDateFormat(String pattern)</code>： 该构造方法可以用参数pattern指定的格式创建一个对象</li>
<li><code>SimpleDateFormat</code>对象调用：<code>public String format(Date date)</code>： 方法格式化时间对象date</li>
</ul>
</li>
<li><p>解析：</p>
<ul>
<li><code>public Date parse(String source)</code> ： 从给定字符串的开始解析文本, 以生成一个日期.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// 产生一个Date实例</span></span><br><span class="line"><span class="comment">// 产生一个formater格式化的实例</span></span><br><span class="line">SimpleDateFormat formater = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">System.out.println(formater.format(date));<span class="comment">// 打印输出默认的格式</span></span><br><span class="line">SimpleDateFormat formater2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 EEE HH:mm:ss"</span>);</span><br><span class="line">System.out.println(formater2.format(date));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个指定的格式对象</span></span><br><span class="line">    Date date2 = formater2.parse(<span class="string">"2008年08月08日 星期一 08:08:08"</span>);</span><br><span class="line">    <span class="comment">// 将指定的日期解析后格式化按指定的格式输出</span></span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>java.util.Calendar(日历)类</p>
<ul>
<li><p><code>Calendar</code>是一个抽象基类, 主用用于完成日期字段之间相互操作的功能  </p>
</li>
<li><p>获取Calendar实例的方法</p>
<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器</li>
</ul>
</li>
<li><p>一个Calendar的实例是系统时间的抽象表示, 通过<code>get(int field)</code>方法来取得想要的时间信息.比如<code>YEAR、 MONTH、 DAY_OF_WEEK、 HOUR_OF_DAY 、MINUTE、 SECOND</code></p>
<ul>
<li><code>public void set(int field,int value)</code></li>
<li><code>public void add(int field,int amount)</code></li>
<li><code>public final Date getTime()</code></li>
<li><code>public final void setTime(Date date)</code><blockquote>
<p>注:<br>获取月份时： 一月是0, 二月是1, 以此类推,  12月是11<br>获取星期时： 周日是1, 周二是2 ,  . …周六是7</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 从一个 Calendar 对象中获取 Date 对象</span></span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line"><span class="comment">// 使用给定的 Date 设置此 Calendar 的时间</span></span><br><span class="line">date = <span class="keyword">new</span> Date(<span class="number">234234235235L</span>);</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"当前时间日设置为8后,时间是:"</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.HOUR, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"当前时间加2小时后,时间是:"</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"当前日期减2个月后,时间是:"</span> + calendar.getTime());</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="6-3-JDK-8中新日期时间API"><a href="#6-3-JDK-8中新日期时间API" class="headerlink" title="6.3 JDK 8中新日期时间API"></a>6.3 JDK 8中新日期时间API</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    如果我们可以跟别人说：“我们在1502643933071见面, 晚了！”那么就再简单不过了.但是我们希望时间与昼</span><br><span class="line">夜和四季有关, 于是事情就变复杂了.JDK 1.0中包含了一个java.util.Date类, 但是它的大多数方法已经在JDK 1.1</span><br><span class="line">引入Calendar类之后被弃用了.而Calendar并不比Date好多少.</span><br><span class="line">    它们面临的问题是：</span><br><span class="line">        可变性：像日期和时间这样的类应该是不可变的.</span><br><span class="line">        偏移性： Date中的年份是从1900开始的, 而月份都从0开始.</span><br><span class="line">        格式化：格式化只对Date有用,  Calendar则不行.</span><br><span class="line">    此外, 它们也不是线程安全的；不能处理闰秒等.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>LocalDate、 LocalTime、 LocalDateTime 类是其中较重要的几个类, 它们的实例是不可变的对象, 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间.</p>
</li>
<li><p>它们提供了简单的本地日期或时间, 并不包含当前的时间信息, 也不包含与时区相关的信息  </p>
<ul>
<li><p><code>now() / * now(ZoneId zone)</code> 静态方法,  根据当前时间创建对象/指定时区的对象</p>
</li>
<li><p><code>of()</code> 静态方法,  根据指定日期/时间创建对象</p>
</li>
<li><p><code>getDayOfMonth()/getDayOfYear()</code> 获得月份天数(1-31) /获得年份天数(1-366)</p>
</li>
<li><p><code>getDayOfWeek()</code> 获得星期几(返回一个 DayOfWeek 枚举值)</p>
</li>
<li><p><code>getMonth()</code> 获得月份, 返回一个 Month 枚举值</p>
</li>
<li><p><code>getMonthValue() / getYear()</code> 获得月份(1-12) /获得年份</p>
</li>
<li><p><code>getHour()/getMinute()/getSecond()</code> 获得当前对象对应的小时、 分钟、 秒</p>
</li>
<li><p><code>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</code> 将月份天数、 年份天数、 月份、 年份修改为指定的值并返回新的对象</p>
</li>
<li><p><code>plusDays(), plusWeeks(),plusMonths(), plusYears(),plusHours()</code> 向当前对象添加几天、 几周、 几个月、 几年、 几小时</p>
</li>
<li><p><code>minusMonths() / minusWeeks()/ minusDays()/minusYears()/minusHours()</code> 从当前对象减去几月、 几周、 几天、 几年、 几小时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  LocalDate、 LocalTime、 LocalDateTime的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now() 静态方法获取当前日期, 时间, 日期+时间</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate); <span class="comment">// 2020-02-05</span></span><br><span class="line">    System.out.println(localTime); <span class="comment">// 15:54:14.344</span></span><br><span class="line">    System.out.println(localDateTime); <span class="comment">// 2020-02-05T15:54:14.344</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// of() 指定日期时间, 没有偏移量</span></span><br><span class="line">    LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">20</span>, <span class="number">23</span>);</span><br><span class="line">    System.out.println(localDateTime1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getXXX() 获取相关属性</span></span><br><span class="line">    System.out.println(<span class="string">"localDateTime.getDayOfMonth() = "</span> + localDateTime.getDayOfMonth());</span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">    System.out.println(localDateTime.getDayOfYear());</span><br><span class="line">    System.out.println(localDateTime.getMonth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 体现不可变性</span></span><br><span class="line">    <span class="comment">// withXxx() 设置相关属性</span></span><br><span class="line">    LocalDateTime localDateTime2 = localDateTime.withDayOfMonth(<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">"localDateTime = "</span> + localDateTime);</span><br><span class="line">    System.out.println(<span class="string">"localDateTime2 = "</span> + localDateTime2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在现有的基础上进行加减操作</span></span><br><span class="line">    LocalDateTime localDateTime3 = localDateTime.plusMonths(<span class="number">2</span>); <span class="comment">// 加</span></span><br><span class="line">    System.out.println(<span class="string">"localDateTime3 = "</span> + localDateTime3);</span><br><span class="line">    LocalDateTime localDateTime4 = localDateTime.minusHours(<span class="number">20</span>); <span class="comment">// 减</span></span><br><span class="line">    System.out.println(<span class="string">"localDateTime4 = "</span> + localDateTime4);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="瞬时：-Instant"><a href="#瞬时：-Instant" class="headerlink" title="瞬时： Instant"></a>瞬时： Instant</h4><ul>
<li><p>Instant：时间线上的一个瞬时点. 这可能被用来记录应用程序中的事件时间戳.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instant 的使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now()  本初子午线的时间</span></span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"instant = "</span> + instant);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加时间偏移量</span></span><br><span class="line">        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">"offsetDateTime = "</span> + offsetDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toEpochMilli() 获取1970年1月1日0分0秒(UTC)至今的毫秒数  ==&gt; Date类的getTime()方法</span></span><br><span class="line">        <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">        System.out.println(<span class="string">"milli = "</span> + milli);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过给定的毫秒数, 获取一个  Instant 实例  ==&gt; Date(long millis)</span></span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(<span class="number">1580890452829L</span>);</span><br><span class="line">        System.out.println(<span class="string">"instant1 = "</span> + instant1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DateTimeFormat类 : 格式化与解析日期或时间</p>
<ul>
<li>详见文件…, 懒得敲了</li>
</ul>
</li>
</ul>
<h3 id="6-4-Java比较器"><a href="#6-4-Java比较器" class="headerlink" title="6.4 Java比较器"></a>6.4 Java比较器</h3><ul>
<li>Java实现对象排序的方式有两种：<ul>
<li>自然排序 : <code>java.lang.Comparable</code></li>
<li>定制排序 : <code>java.util.Comparator</code></li>
</ul>
</li>
</ul>
<ol>
<li><p>自然排序 ： java.lang.Comparable</p>
<ul>
<li><p>实现 <code>Comparable</code> 的类必须实现 <code>compareTo(Object obj)</code> 方法, 两个对象即通过 <code>compareTo(Object obj)</code> 方法的返回值来比较大小  </p>
</li>
<li><p>如果当前对象this大于形参对象obj,  则返回正整数, 如果当前对象this小于形参对象obj,  则返回负整数, 如果当前对象this等于形参对象obj,  则返回零</p>
</li>
<li><p>实现<code>Comparable</code>接口的对象列表(和数组)可以通过 <code>Collections.sort</code> 或<code>Arrays.sort</code>进行自动排序.实现此接口的对象可以用作有序映射中的键或有序集合中的元素, 无需指定比较器.</p>
</li>
<li><p>对于类 C 的每一个 e1 和 e2 来说, 当且仅当 <code>e1.compareTo(e2) == 0</code> 与<code>e1.equals(e2)</code> 具有相同的 boolean 值时, 类 C 的自然排序才叫做与 equals一致.</p>
<ul>
<li>建议(虽然不是必需的) 最好使自然排序与 equals 一致.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="comment">//按照价格, 比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            Goods other = (Goods) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.price &lt; other.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的数据类型不一致"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、 getter、 setter、 toString()方法略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goods[] all = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">        all[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"《红楼梦》 "</span>, <span class="number">100</span>);</span><br><span class="line">        all[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"《西游记》 "</span>, <span class="number">80</span>);</span><br><span class="line">        all[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"《三国演义》 "</span>, <span class="number">140</span>);</span><br><span class="line">        all[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"《水浒传》 "</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(all));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定制排序： java.util.Comparator</p>
<ul>
<li><p>当元素的类型没有实现<code>java.lang.Comparable</code>接口而又不方便修改代码, 或者实现了<code>java.lang.Comparable</code>接口的排序规则不适合当前的操作, 那么可以考虑使用 <code>Comparator</code> 的对象来排序,  强行对多个对象进行整体排序的比较</p>
</li>
<li><p>重写<code>compare(Object o1,Object o2)</code>方法, 比较o1和o2的大小： 如果方法返回正整数, 则表示o1大于o2；如果返回0, 表示相等；返回负整数, 表示o1小于o2</p>
</li>
<li><p>可以将 <code>Comparator</code> 传递给 sort 方法(如 <code>Collections.sort</code> 或 <code>Arrays.sort</code>), 从而允许在排序顺序上实现精确控制.</p>
</li>
<li><p>还可以使用 <code>Comparator</code> 来控制某些数据结构(如有序 set或有序映射)的顺序, 或者为那些没有自然顺序的对象 <code>collection</code> 提供排序.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"War and Peace"</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"Childhood"</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"Scarlet and Black"</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"Notre Dame de Paris"</span>, <span class="number">120</span>);</span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Goods g1 = (Goods) o1;</span><br><span class="line">        Goods g2 = (Goods) o2;</span><br><span class="line">        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(all));</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="7-枚举类和注解"><a href="#7-枚举类和注解" class="headerlink" title="7 枚举类和注解"></a>7 枚举类和注解</h2><h3 id="7-1-枚举类的使用"><a href="#7-1-枚举类的使用" class="headerlink" title="7.1 枚举类的使用"></a>7.1 枚举类的使用</h3><ul>
<li>类的对象只有有限个, 确定的. 举例:<ul>
<li>星期： Monday(星期一)、 ……、 Sunday(星期天)</li>
<li>性别： Man(男)、 Woman(女)</li>
<li>季节： Spring(春节)……Winter(冬天)</li>
<li>支付方式： Cash(现金)、 WeChatPay(微信)、 Alipay(支付宝)、 BankCard(银行卡)、 CreditCard(信用卡)</li>
<li>就职状态： Busy、 Free、 Vocation、 Dimission</li>
<li>订单状态： Nonpayment(未付款)、 Paid(已付款) 、 Delivered(已发货)、Return(退货)、 Checked(已确认) Fulfilled(已配货)</li>
<li>线程状态：创建、就绪、运行、阻塞、死亡</li>
</ul>
</li>
<li>当需要定义一组常量时, 强烈建议使用枚举类</li>
</ul>
<ol>
<li>枚举类的实现<ul>
<li>JDK1.5之前需要自定义枚举类</li>
<li>JDK 1.5 新增的 enum 关键字用于定义枚举类</li>
</ul>
</li>
<li>若枚举只有一个对象, 则可以作为一种单例模式的实现方式</li>
<li>枚举类的属性<ul>
<li>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰</li>
<li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</li>
<li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p>自定义枚举类</p>
<ol>
<li><p>私有化类的构造器, 保证不能在类的外部创建其对象</p>
</li>
<li><p>在类的内部创建枚举类的实例.声明为： public static final</p>
</li>
<li><p>对象如果有实例变量, 应该声明为private final, 并在构造器中初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 声明Season类的属性 private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME; <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC; <span class="comment">// 描述</span></span><br><span class="line">    <span class="comment">// 私有化构造器, 给对象赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>, <span class="string">"春暖花开"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>, <span class="string">"夏日炎炎"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>, <span class="string">"秋高气爽"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>, <span class="string">"白雪皑皑"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如何使用关键字enum定义枚举类</p>
<ul>
<li><p>使用说明:</p>
<ul>
<li>使用 enum 定义的枚举类默认继承了 <strong>java.lang.Enum</strong>类, 因此不能再继承其他类</li>
<li>枚举类的构造器只能使用 private 权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾).列出的实例系统会自动添加 public static final 修饰</li>
<li>必须在枚举类的第一行声明枚举类对象</li>
</ul>
</li>
<li><p>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</span><br><span class="line">    SPRING(<span class="string">"春天"</span>,<span class="string">"春风又绿江南岸"</span>),</span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>,<span class="string">"映日荷花别样红"</span>),</span><br><span class="line">    AUTUMN(<span class="string">"秋天"</span>,<span class="string">"秋水共长天一色"</span>),</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>,<span class="string">"窗含西岭千秋雪"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Enum类的主要方法</p>
<ul>
<li><code>values()</code>方法：返回枚举类型的对象数组.该方法可以很方便地遍历所有的枚举值.</li>
<li><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象.要求字符串必须是枚举类对象的“名字”.如不是, 会有运行时异常：<code>IllegalArgumentException</code></li>
<li><code>toString()</code>：返回当前枚举类对象常量的名称</li>
</ul>
</li>
<li><p>实现接口的枚举类</p>
<ul>
<li>和普通 Java 类一样, 枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式, 则只要统一实现该方法即可.</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法</li>
</ul>
</li>
</ol>
<h3 id="7-2-注解的使用"><a href="#7-2-注解的使用" class="headerlink" title="7.2 注解的使用"></a>7.2 注解的使用</h3><ol>
<li><p>注解 (Annotation) 概述</p>
<ul>
<li>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</li>
<li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理.通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息. 代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署.</li>
<li>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation的 “name=value” 对中</li>
<li>在JavaSE中, 注解的使用目的比较简单, 例如标记过时的功能, 忽略警告等.在JavaEE/Android中注解占据了更重要的角色, 例如用来配置应用程序的任何切面,  代替JavaEE旧版中所遗留的繁冗代码和XML配置等.</li>
<li>未来的开发模式都是基于注解的,  JPA是基于注解的,  Spring2.5以上都是基于注解的,  Hibernate3.x以后也是基于注解的, 现在的Struts2有一部分也是基于注解的了, 注解是一种趋势, 一定程度上可以说： <strong>框架 = 注解 + 反射 + 设计模式.</strong></li>
</ul>
</li>
<li><p>常见的Annotation示例</p>
<ul>
<li><p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用. 用于修饰它支持的程序元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 标明开发该类模块的作者,  多个作者之间使用,分割</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 标明该类模块的版本</span></span><br><span class="line"><span class="comment"><span class="doctag">@see</span> 参考转向,  也就是相关主题</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 从哪个版本开始增加的</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> 对方法中某参数的说明,  如果没有参数就不能写</span></span><br><span class="line"><span class="comment"><span class="doctag">@return</span> 对方法返回值的说明,  如果方法的返回值类型是void就不能写</span></span><br><span class="line"><span class="comment"><span class="doctag">@exception</span> 对方法可能抛出的异常进行说明 ,  如果方法没有用throws显式抛出的异常就不能写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以上</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> <span class="doctag">@return</span> 和 <span class="doctag">@exception</span> 这三个标记都是只用于方法的.</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span>的格式要求： <span class="doctag">@param</span> 形参名 形参类型 形参说明</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span> 的格式要求： <span class="doctag">@return</span> 返回值类型 返回值说明</span></span><br><span class="line"><span class="comment">    <span class="doctag">@exception</span>的格式要求： <span class="doctag">@exception</span> 异常类型 异常说明</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span>和<span class="doctag">@exception</span>可以并列多个</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成文档相关的注解</p>
</li>
<li><p>在编译时进行格式检查(JDK内置的三个基本注解)</p>
<ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时.通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ul>
</li>
<li><p>跟踪代码依赖性, 实现替代配置文件功能</p>
</li>
</ul>
</li>
<li><p>自定义 Annotation</p>
<ul>
<li><p>定义新的 Annotation 类型使用 @interface 关键字</p>
</li>
<li><p>自定义注解自动继承了<code>java.lang.annotation.Annotation</code>接口</p>
</li>
<li><p><code>Annotation</code> 的成员变量在 <code>Annotation</code> 定义中以无参数方法的形式来声明. 其方法名和返回值定义了该成员的名字和类型. 我们称为配置参数. 类型只能是八种基本数据类型、 String类型、 Class类型、 enum类型、 Annotation类型、以上所有类型的数组.</p>
</li>
<li><p>可以在定义 <code>Annotation</code> 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 <code>default</code> 关键字</p>
</li>
<li><p>如果只有一个参数成员,  建议使用参数名为value</p>
</li>
<li><p>如果定义的注解含有配置参数,  那么使用时必须指定参数值,  除非它有默认值. 格式是“参数名 = 参数值” ,  如果只有一个参数成员,  且名称为value, 可以省略“value=”</p>
</li>
<li><p>没有成员定义的 <code>Annotation</code> 称为标记; 包含成员变量的 <code>Annotation</code> 称为元数据 <code>Annotation</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(value=<span class="string">"尚硅谷"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = MyAnnotationTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Annotation a = clazz.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        MyAnnotation m = (MyAnnotation) a;</span><br><span class="line">        String info = m.value();</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "auguigu"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK 中的元注解</p>
<ul>
<li><p>元注解, 对现有注解修饰的注解</p>
</li>
<li><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义</p>
</li>
<li><p>JDK5.0提供了4个标准的meta-annotation类型,  分别是：</p>
<ul>
<li><p>Retention : 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期</p>
<ul>
<li>@Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值<ul>
<li>RetentionPolicy.SOURCE:在源文件中有效(即源文件保留)</li>
<li>RetentionPolicy.CLASS:在class文件中有效(即class保留)默认行为</li>
<li>RetentionPolicy.RUNTIME:在运行时有效(即运行时保留),当运行 Java 程序时, JVM 会保留注释.程序可以通过反射获取该注释.</li>
</ul>
</li>
</ul>
</li>
<li><p>Target : 指定被修饰的 Annotation 能用于修饰哪些程序元素</p>
<ul>
<li>@Target 也包含一个名为 value 的成员变量<br><img src="https://i.loli.net/2020/03/20/ixvFTZJVjOdNDqg.png" alt="target.png"></li>
</ul>
</li>
<li><p>Documented : (使用较少)用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档. 默认情况下, javadoc是不包括注解的</p>
<ul>
<li>定义为Documented的注解必须设置Retention值为RUNTIME</li>
</ul>
</li>
<li><p>Inherited : (使用较少)被它修饰的 Annotation 将具有继承性.如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解</p>
</li>
</ul>
</li>
<li><p>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上, 子类则可以继承父类类级别的注解</p>
<blockquote>
<p>元数据(对现有数据修饰的数据)的理解：<br>String name = “atguigu”; 中的String 和 name</p>
</blockquote>
</li>
<li><p>自定义注解通常会指明Retention 和 Target</p>
</li>
</ul>
</li>
<li><p>通过反射获取注解信息 — 反射时再写</p>
</li>
<li><p>jdk 8 中注解的新特性: 可重复注解, 类型注解</p>
<ol>
<li>可重复注解 : 可重复定义多个<ul>
<li>在MyAnnotation上声明@Repeatable(), 成员值为MyAnnotations.class</li>
<li>MyAnnotation的@Target,@Retention等和MyAnnotations的相同</li>
</ul>
</li>
<li>类型注解 :  <ul>
<li>在Java 8之前,  注解只能是在声明的地方所使用,  Java8开始,  注解可以应用在任何地方.<ul>
<li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中(如:泛型声明)</li>
<li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="8-Java集合"><a href="#8-Java集合" class="headerlink" title="8. Java集合"></a>8. Java集合</h2><h3 id="8-1-Java集合框架概述"><a href="#8-1-Java集合框架概述" class="headerlink" title="8.1 Java集合框架概述"></a>8.1 Java集合框架概述</h3><ol>
<li><p>集合, 数组都是对多个数据进行存储操作的结构, 是一种容器. (此时的存储指的是内存层面的存储, 不涉及到持久化的存储)</p>
</li>
<li><p>数组在存储多个数据方法的特点:</p>
<ul>
<li>一旦初始化后, 其长度就确定了, 不可修改</li>
<li>数组一旦定义好, 其元素的类型也就确定了, 也就只能操作指定类型的数据了</li>
<li>数组中提供的方法有限, 对增.删.改.查的操作不便捷, 效率不高</li>
<li>获取数组中实际元素的个数的需求, 数组没有现成的属性或方法可用</li>
<li>数组存储数据: 有序, 可重复</li>
</ul>
</li>
<li><p>集合框架</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-----Collection 接口: 单列数据, 用来存储一个一个的数据  </span><br><span class="line">   |-----List： 元素有序、可重复的数据, --&gt;&quot;动态&quot;的数组  </span><br><span class="line">      |-----ArrayList :  List的主要实现类, 线程不安全, 效率高, 底层使用Object[] elementData存储</span><br><span class="line">      |-----LinkedList : 对于频繁的插入和删除, 使用该类, 因为该类底层使用双向链表存储</span><br><span class="line">      |-----Vector : 作为List接口的古老实现类, 线程安全的, 效率低, 底层使用Object[] elementData 存储</span><br><span class="line">   |-----Set： 元素无序、不可重复的数据 --&gt; 数学上的&quot;集合&quot;定义</span><br><span class="line">      |-----HashSet : Set 接口的主要实现类, 线程不安全, 可以存储null值</span><br><span class="line">         |-----LinkedHashSet : HashSet的子类, 遍历其内部数据时, 按照添加顺序进行遍历</span><br><span class="line">      |-----TreeSet : 底层是红黑树构成的, 添加的元素必须是同一个类的对象, 可以按照指定属性进行排序</span><br><span class="line">|-----Map 接口： 双列数据, 保存具有映射关系“key-value对”的集合</span><br><span class="line">   |-----HashMap : 作为Map的主要实现类, 线程不安全, 效率高, 可以存储null的key和value</span><br><span class="line">          底层: 数组+链表(jdk7及之前)</span><br><span class="line">                数组+链表+红黑树(jdk8)</span><br><span class="line">      |-----LinkedHashMap : 保证在遍历map元素时, 可以按照添加的顺序实现遍历(在原有的hashmap底层结构基础上, 添加了一对指针, 指向前一个和后一个元素), 对于频繁的插入和删除, 使用该类</span><br><span class="line">   |-----TreeMap : 可按照指定key-value 的key进行排序, 即考虑key的自然排序和定制排序, 底层使用红黑树</span><br><span class="line">   |-----HashTable : 作为Map的古老实现类, 线程安全, 效率低, 不能存储null的key和value</span><br><span class="line">      |-----Properties : 用来处理配置文件, key和value都是String类型</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="8-2-Collection接口方法"><a href="#8-2-Collection接口方法" class="headerlink" title="8.2 Collection接口方法"></a>8.2 Collection接口方法</h3><ul>
<li>Collection 接口是 List、 Set 和 Queue 接口的父接口, 该接口里定义的方法既可用于操作 Set 集合, 也可用于操作 List 和 Queue 集合</li>
<li>JDK不提供此接口的任何直接实现, 而是提供更具体的子接口(如： Set和List)实现</li>
<li>在 Java5 之前,  Java 集合会丢失容器中所有对象的数据类型, 把所有对象都当成 Object 类型处理； 从 JDK 5.0 增加了泛型以后,  Java 集合可以记住容器中对象的数据类型</li>
</ul>
<hr>
<ul>
<li>Collection接口方法</li>
</ul>
<ol>
<li>添加<ul>
<li>add(Object obj) 将obj添加到集合中</li>
<li>addAll(Collection coll) 将coll集合中的所有元素添加到集合中</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>int size()</li>
</ul>
</li>
<li>清空集合<ul>
<li>void clear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>boolean contains(Object obj)： 是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection c)： 也是调用元素的equals方法来比较的. 拿两个集合的元素挨个比较</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj) ： 通过元素的equals方法判断是否是要删除的那个元素. 只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)： 取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)： 把交集的结果存在当前集合中, 不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
<li>数组 –&gt; 集合: Arrays类的静态方法asList()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()： 返回迭代器对象, 用于集合遍历</li>
</ul>
</li>
</ol>
<ul>
<li>注:  </li>
</ul>
<p><strong>向Collection接口的实现类的对象中添加数据obj时, 要求obj所在类重写equals()方法</strong></p>
<ul>
<li>即 List : 要重写equals()方法(做remove, compare等方法时需要用到比较)</li>
<li>HashSet,LinkedHashSet : 重写equals()方法和hashCode()方法  </li>
<li>TreeSet : Comparable接口 – compareTo(Object obj)方法<br>Comparator接口 – compare(Object o1, Object o2)方法</li>
</ul>
<h3 id="8-3-Iterator迭代器接口"><a href="#8-3-Iterator迭代器接口" class="headerlink" title="8.3 Iterator迭代器接口"></a>8.3 Iterator迭代器接口</h3><ul>
<li><p>Iterator对象称为迭代器(设计模式的一种), 主要用于遍历 Collection 集合中的元素</p>
</li>
<li><p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素, 而又不需暴露该对象的内部细节.</p>
<ul>
<li>迭代器模式, 就是为容器而生. 类似于“公交车上的售票员”、“火车上的乘务员”、 “空姐”</li>
</ul>
</li>
<li><p>Collection接口继承了java.lang.Iterable接口, 该接口有一个iterator()方法, 那么所有实现了Collection接口的集合类都有一个iterator()方法, 用以返回一个实现了Iterator接口的对象</p>
</li>
<li><p>Iterator 仅用于遍历集合,  Iterator 本身并不提供承装对象的能力.如果需要创建Iterator 对象, 则必须有一个被迭代的集合</p>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象, 默认游标都在集合的第一个元素之前</p>
</li>
<li><p>Iterator接口的方法</p>
<ul>
<li>boolean hasNext(); 判断是否还有下一个元素</li>
<li>E next():  <ol>
<li>指针下移  </li>
<li>将下移以后集合位置上的元素返回</li>
<li>如果超出个数后, 抛异常NoSuchElementException</li>
</ol>
</li>
<li>void remove(); 删除集合的元素<blockquote>
<p>Iterator可以删除集合的元素,  但是是遍历过程中通过迭代器对象的remove方法,  不是集合对象的remove方法<br>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法, 再调用remove都会报IllegalStateException</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="8-4-Collection子接口-List"><a href="#8-4-Collection子接口-List" class="headerlink" title="8.4 Collection子接口: List"></a>8.4 Collection子接口: List</h3><ul>
<li><p>List集合类中元素<strong>有序、且可重复</strong>, 集合中的每个元素都有其对应的顺序索引</p>
<ul>
<li>有序性是指: 存储的元素按照数组索引一个个存储</li>
</ul>
</li>
<li><p>List接口的实现类常用的有： ArrayList、 LinkedList和Vector</p>
<ul>
<li><strong>ArrayList</strong> : List的主要实现类, 线程不安全, 效率高, 底层使用Object[] elementData存储</li>
<li><strong>LinkedList</strong> : 对于频繁的插入和删除, 使用该类, 因为该类底层使用双向链表存储</li>
<li><strong>Vector</strong> : 作为List接口的古老实现类, 线程安全的, 效率低, 底层使用Object[] elementData 存储</li>
</ul>
</li>
<li><p>ArrayList 源码分析</p>
<ul>
<li><p>JDK 7版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层创建了长度为10的Object[]数组 elementData</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>); <span class="comment">// 当此次添加导致elementData数组容量不够, 则扩容,</span></span><br><span class="line"><span class="comment">// 默认情况下扩容至原来容量的1.5倍,即加上原来的一半, 向下取整 同时将原有数组中的数据复制到新数组中Arrays.copyOf(elementData, newCapacity);</span></span><br><span class="line"><span class="comment">// 结论: 建议开发中在使用带参构造器, ArrayList list  = new ArrayList(int capacity)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK 8中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层创建了Object[] elementData 初始化为&#123;&#125;, 并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 第一次调用add()时, 底层才创建了长度为10的数组, 并将123添加到elementData中</span></span><br><span class="line"><span class="comment">// 后续添加与扩容与jdk7相同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小结: jdk7中Array List对象的创建类似于单例的饿汉式, 而jdk8中,累死懒汉式, 延迟了数组的创建, 节省内存</p>
</li>
</ul>
</li>
<li><p>LinkedList 源码分析</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); <span class="comment">// 内部声明了Node类型的first和last属性, 默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 将123封装到node中, 创建Node对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中, Node定义为</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 体现了双向的特点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>List除了从Collection集合继承的方法外,  List 集合里添加了一些根据索引来操作集合元素的方法:</p>
<ul>
<li>void add(int index, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素, 并返回此元素<ul>
<li>注意区分和collection类中的remove方法, remove(Object obj)</li>
</ul>
</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
</ul>
<h3 id="8-5-Collection子接口-Set"><a href="#8-5-Collection子接口-Set" class="headerlink" title="8.5 Collection子接口: Set"></a>8.5 Collection子接口: Set</h3><ul>
<li><p>Set 存储<strong>无序的, 不可重复</strong>的数据</p>
</li>
<li><p>Set接口是Collection的子接口,  set接口没有提供额外的方法</p>
</li>
<li><p>Set 集合不允许包含相同的元素, 如果试把两个相同的元素加入同一个Set 集合中, 则添加操作失败</p>
</li>
<li><p>Set 判断两个对象是否相同不是使用 == 运算符, 而是根据 equals() 方法</p>
</li>
<li><p>Set 的实现类有: HashSet, LinkedHashSet, TreeSet</p>
<ul>
<li>HashSet : Set 接口的主要实现类, 线程不安全, 可以存储null值</li>
<li>LinkedHashSet : HashSet的子类, 遍历其内部数据时, 按照添加顺序进行遍历</li>
<li>TreeSet : 底层是红黑树构成的, 添加的元素必须是同一个类的对象, 可以按照指定属性进行排序</li>
</ul>
</li>
<li><p>HashSet的使用</p>
<ol>
<li>无序性:(不是随机性)<ul>
<li>以HashSet为例: 指存储的数据在底层数组中并非按照数组索引的顺序添加, 是按照数据的哈希值决定的.</li>
</ul>
</li>
<li>不可重复性:<ul>
<li>保证添加的元素按照equals()判断时, 不能返回true</li>
</ul>
</li>
<li>添加元素的过程, 以HashSet为例:<ul>
<li>向HashSet中添加元素a,首先调用a的所在类的hashCode()方法, 计算a的哈希值, 此哈希值通过某种算法计算出在HashSet底层数组中的存放位置(即为索引位置), 判断此位置上是否已经有元素, 如果没有, 则a添加成功, 如果此位置上已经有元素b(或以链表形式存在的多个元素), 则比较a与b的hash值; 如果hash值不同, 则a添加成功, 如果hash值相同, 则要调用a的所在类的equals方法, equals方法返回true, 则添加失败, 如果返回false, 则a添加成功.</li>
<li>若此位置上已经存在元素, a添加成功后, 与已有元素以链表的方式存储.<ul>
<li>jdk7: a放到数组中, 指向原来的元素</li>
<li>jdk8: 原来的元素在数组中, 指向元素a</li>
</ul>
</li>
<li>即HashSet的底层是 : 数组 + 链表实现的<blockquote>
<p>注: 添加到Set中的元素必须重写equals()和hashCode()方法</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li><p>LinkedHashSet 的使用</p>
<ul>
<li>可以按照添加的顺序遍历</li>
<li>LinkedHashSet 作为HashSet的子类, 在添加数据的同时, 还维护了2个引用, 记录此数据的前一个数据和后一个数据<ul>
<li>优点: 对于频繁的遍历操作,LindedHashSet 效率高于HashSet  </li>
</ul>
</li>
</ul>
</li>
<li><p>TreeSet 的使用</p>
<ul>
<li>按照指定属性进行排序</li>
</ul>
<ol>
<li>向TreeSet中添加的数据, 要求是相同类的对象</li>
<li>两种排序方式, 自然排序(实现comparable接口,重写compareTo()方法)和定制排序(实现comparator接口重写compare()方法)<ul>
<li>自然排序中, 比较两个对象是否相同的标准为: compareTo()返回0, 不是equals()方法</li>
<li>定制排序中, 比较标准为: compare()方法</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="8-6-Map接口"><a href="#8-6-Map接口" class="headerlink" title="8.6 Map接口"></a>8.6 Map接口</h3><ul>
<li><p>存储双列数据, 存储key-value对的数据</p>
<ul>
<li>HashSet : Set 接口的主要实现类, 线程不安全, 可以存储null值</li>
<li>LinkedHashSet : HashSet的子类, 遍历其内部数据时, 按照添加顺序进行遍历</li>
<li>TreeSet : 底层是红黑树构成的, 添加的元素必须是同一个类的对象, 可以按照指定属性进行排序</li>
<li>Map 接口： 双列数据, 保存具有映射关系“key-value对”的集合</li>
<li>HashMap : 作为Map的主要实现类, 线程不安全, 效率高, 可以存储null的key和value  <ul>
<li>底层:<br>数组+链表(jdk7及之前)<br>数组+链表+红黑树(jdk8)</li>
</ul>
</li>
</ul>
</li>
<li><p>Map结构</p>
<ul>
<li>key : 不能重复的, 无序的,用Set存储所有的key, key所在的类要重写equals()和hashcode()方法</li>
<li>value : 可以重复, 也是无序的, 用Collection存所有的value, value所在类要重写equals()</li>
<li>一个键值对Entry对象 : key-value</li>
<li>enrty : 无序的, 不可重复的, 使用Set存储</li>
</ul>
</li>
<li><p>HashMap源码分析</p>
<ul>
<li><p>jdk7</p>
<ul>
<li><p>HashMap map = new HashMap(); 在实例化后, 底层创建了长度16的数组Entry[] table</p>
</li>
<li><p>map.put(key1, value1):</p>
<ul>
<li>首先调用key1的hashCode()方法, 计算其哈希值, 经过某种算法计算后, 得到在Entry[] 中的存放位置</li>
<li>如果此位置上数据为空, key1-value1添加成功</li>
<li>如果此位置上存在1个或多个数据(链表形式存储), 比较key1和已存在数据的哈希值, 如果都不相同, 则key1-value1添加成功</li>
<li>如果key1和已存在数据哈希值相同, 调用key1的equals()方法, 返回false. 添加成功; 返回true, 使用value1替换相同key的value值</li>
</ul>
</li>
<li><p>默认扩容方式是: 超出临界值时(且要存放的位置非空时)扩容为原来的2倍, 并将原有数据复制</p>
</li>
</ul>
</li>
<li><p>jdk8</p>
<ol>
<li>new HashMap():底层没有创建长度为16的数组</li>
<li>jdk8 底层的数组是 Node[], 非Entry[]</li>
<li>首次调用put()方法时, 创建长度为16的数组</li>
<li>jdk7底层结构为 : 数组+链表; jdk8中是: 数组+链表+红黑树<ul>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组的长度 &gt; 64时; 此索引位置上的所有数据改为红黑树存储</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>LinkedHashMap 源码分析(了解)</p>
<ul>
<li>可以根据添加的顺序进行遍历</li>
</ul>
</li>
</ul>
<h3 id="8-7-Collections工具类"><a href="#8-7-Collections工具类" class="headerlink" title="8.7 Collections工具类"></a>8.7 Collections工具类</h3><ul>
<li><p>操作集合的工具类, set, List Map</p>
</li>
<li><p>常用方法:  </p>
<ul>
<li>排序操作： (均为static方法)<ul>
<li><code>reverse(List)</code>： 反转 List 中元素的顺序<ul>
<li><code>shuffle(List)</code>： 对 List 集合元素进行随机排序</li>
</ul>
</li>
<li><code>sort(List)</code>： 根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List,  Comparator)</code>： 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List,  int,  int)</code>： 将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
</li>
<li>查找、替换<ul>
<li><code>Object max(Collection)</code>： 根据元素的自然顺序, 返回给定集合中的最大元素</li>
<li><code>Object max(Collection,  Comparator)</code>： 根据 Comparator 指定的顺序, 返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code><br><code>Object min(Collection,  Comparator)</code></li>
<li><code>int frequency(Collection,  Object)</code>： 返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list,  Object oldVal,  Object newVal)</code>： 使用新值替换 List 对象的所有旧值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-泛型与File类"><a href="#9-泛型与File类" class="headerlink" title="9. 泛型与File类"></a>9. 泛型与File类</h2><h3 id="9-1-泛型"><a href="#9-1-泛型" class="headerlink" title="9.1 泛型"></a>9.1 泛型</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li>所谓泛型,  就是允许在定义类、 接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型. 这个类型参数将在使用时（例如, 继承或实现这个接口,  用这个类型声明变量、 创建对象时） 确定（即传入实际的类型参数,  也称为类型实参）</li>
<li>从JDK1.5以后, Java引入了“参数化类型（ Parameterized type） ” 的概念, 允许我们在创建集合时再指定集合元素的类型,  正如： List&lt;String&gt;,  这表明该List只能保存字符串类型的对象</li>
<li>Java泛型可以保证如果程序在编译时没有发出警告, 运行时就不会产生<code>ClassCastException</code>异常.同时, 代码更加简洁、健壮</li>
</ul>
<h4 id="2-在集合中使用泛型"><a href="#2-在集合中使用泛型" class="headerlink" title="2. 在集合中使用泛型"></a>2. 在集合中使用泛型</h4><ul>
<li><p>代码示例</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line">list.add(<span class="number">78</span>);</span><br><span class="line">list.add(<span class="number">88</span>);</span><br><span class="line">list.add(<span class="number">77</span>);</span><br><span class="line">list.add(<span class="number">66</span>);</span><br><span class="line"><span class="comment">//遍历方式一：</span></span><br><span class="line"><span class="comment">//for(Integer i : list)&#123;</span></span><br><span class="line"><span class="comment">//不需要强转</span></span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//遍历方式二：</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"Tom1"</span>,<span class="number">34</span>);</span><br><span class="line">map.put(<span class="string">"Tom2"</span>,<span class="number">44</span>);</span><br><span class="line">map.put(<span class="string">"Tom3"</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"Tom4"</span>,<span class="number">32</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//map.put(33, "Tom");  //添加失败</span></span><br><span class="line">Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">"---&gt;"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-自定义泛型结构"><a href="#3-自定义泛型结构" class="headerlink" title="3. 自定义泛型结构"></a>3. 自定义泛型结构</h4><ul>
<li>3种自定义泛型结构的形式:<ol>
<li>自定义泛型类</li>
<li>自定义泛型接口</li>
<li>自定义泛型方法</li>
</ol>
</li>
</ul>
<ol>
<li><p>自定义泛型结构：泛型类、泛型接口</p>
<ol>
<li>泛型类可能有多个参数, 此时应将多个参数一起放在尖括号内.比如：<code>&lt;E1,E2,E3&gt;</code></li>
<li>泛型类的构造器如下： <code>public GenericClass(){}</code>.<br>而下面是错误的： <code>public GenericClass&lt;E&gt;(){}</code></li>
<li>实例化后, 操作原来泛型位置的结构必须与指定的泛型类型一致.</li>
<li>泛型不同的引用不能相互赋值.<blockquote>
<p>尽管在编译时<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>是两种类型, 但是, 在运行时只有一个ArrayList被加载到JVM中.</p>
</blockquote>
</li>
<li>泛型如果不指定, 将被擦除, 泛型对应的类型均按照Object处理, 但不等价于Object.<br>经验： 泛型要使用一路都用.要不用, 一路都不要用.</li>
<li>如果泛型结构是一个接口或抽象类, 则不可创建泛型类的对象.</li>
<li>jdk1.7, 泛型的简化操作： <code>ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</code></li>
<li>泛型的指定中不能使用基本数据类型, 可以使用包装类替换.</li>
<li>在类/接口上声明的泛型, 在本类或本接口中即代表某种类型, 可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型.<strong>但在静态方法中不能使用类的泛型.</strong></li>
<li>异常类不能是泛型的</li>
<li>不能使用<code>new E[]</code>.但是可以： <code>E[] elements = (E[])new Object[capacity];</code><br>参考： ArrayList源码中声明： <code>Object[] elementData</code>,  而非泛型参数类型数组.</li>
<li>父类有泛型, 子类可以选择保留泛型也可以选择指定泛型类型：  <ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型 擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>结论：子类必须是“富二代”, 子类除了指定或保留父类的泛型, 还可以增加自己的泛型</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、使用时：类似于Object, 不等同于Object</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// list.add(new Date());//有风险</span></span><br><span class="line">        list.add(<span class="string">"hello"</span>);</span><br><span class="line">        test(list);<span class="comment">// 泛型擦除, 编译不会类型检查</span></span><br><span class="line">        <span class="comment">// ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line">        <span class="comment">// test(list2);//一旦指定Object, 编译会类型检查, 必须按照Object处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            str += s + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"元素:"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 使用T类型定义变量</span></span><br><span class="line">    <span class="keyword">private</span> T info;</span><br><span class="line">    <span class="comment">// 使用T类型定义一般方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用T类型定义构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static的方法中不能声明泛型</span></span><br><span class="line">    <span class="comment">//public static void show(T t) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">// 不能在try-catch中使用泛型定义</span></span><br><span class="line">    <span class="comment">//public void test() &#123;</span></span><br><span class="line">    <span class="comment">//try &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125; catch (MyException&lt;T&gt; ex) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>自定义泛型结构：泛型方法</p>
<ul>
<li><p>方法: 也可以被泛型化, 不管此时定义在其中的类是不是泛型类. 在泛型方法中可以定义泛型参数, 此时, 参数的类型就是传入数据的类型.</p>
</li>
<li><p>泛型方法的格式:<br>[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</p>
</li>
<li><p>泛型方法声明泛型时也可以指定上限</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> id, E e)</span> </span>&#123;</span><br><span class="line">        E result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object[] ao = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    Collection&lt;Object&gt; co = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    fromArrayToCollection(ao, co);</span><br><span class="line">    String[] sa = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">    Collection&lt;String&gt; cs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fromArrayToCollection(sa, cs);</span><br><span class="line">    Collection&lt;Double&gt; cd = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 下面代码中T是Double类, 但sa是String类型, 编译错误.</span></span><br><span class="line">    <span class="comment">// fromArrayToCollection(sa, cd);</span></span><br><span class="line">    <span class="comment">// 下面代码中T是Object类型,  sa是String类型, 可以赋值成功.</span></span><br><span class="line">    fromArrayToCollection(sa, co);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Person&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Person());</span><br><span class="line">        test(<span class="keyword">new</span> Man());</span><br><span class="line">        <span class="comment">//The method test(T) in the type PersonTest is not</span></span><br><span class="line">        <span class="comment">//applicable for the arguments (Creature)</span></span><br><span class="line">        test(<span class="keyword">new</span> Creature());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="4-泛型在继承上的体现"><a href="#4-泛型在继承上的体现" class="headerlink" title="4. 泛型在继承上的体现"></a>4. 泛型在继承上的体现</h4><ul>
<li><p>如果B是A的一个子类型（子类或者子接口）, 而G是具有泛型声明的类或接口,  G&lt;B&gt;并不是G&lt;A&gt;的子类型！<br>比如： String是Object的子类, 但是<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenericAndSubClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person[] persons = <span class="keyword">null</span>;</span><br><span class="line">    Man[] mans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 而 Person[] 是 Man[] 的父类.</span></span><br><span class="line">    persons = mans;</span><br><span class="line">    Person p = mans[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 在泛型的集合上</span></span><br><span class="line">    List&lt;Person&gt; personList = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Man&gt; manList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// personList = manList;(报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-通配符的使用"><a href="#5-通配符的使用" class="headerlink" title="5. 通配符的使用"></a>5. 通配符的使用</h4><ul>
<li><p>概述:</p>
<ol>
<li>使用类型通配符：<code>？</code><br>比如： <code>List&lt;?&gt;</code> ,  <code>Map&lt;?,?&gt;</code><br><code>List&lt;?&gt;</code>是<code>List&lt;String&gt;</code>、 <code>List&lt;Object&gt;</code>等各种泛型List的父类.</li>
<li>读取<code>List&lt;?&gt;</code>的对象list中的元素时, 永远是安全的, 因为不管list的真实类型是什么, 它包含的都是Object.</li>
<li>写入list中的元素时, 不行.因为我们不知道c的元素类型, 我们不能向其中添加对象.</li>
</ol>
<ul>
<li><p>将任意元素加入到其中不是类型安全的：<br><code>Collection&lt;?&gt; c = new ArrayList&lt;String&gt;();</code><br><code>c.add(new Object()); // 编译时错误</code></p>
<ul>
<li>因为我们不知道c的元素类型，我们不能向其中添加对象。 add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去</li>
<li>唯一的例外的是null，它是所有类型的成员</li>
<li>另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    <span class="comment">// list.add(3);//编译不通过</span></span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    l1.add(<span class="string">"尚硅谷"</span>);</span><br><span class="line">    l2.add(<span class="number">15</span>);</span><br><span class="line">    read(l1);</span><br><span class="line">    read(l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTypeClass</span>&lt;?&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</span></span><br><span class="line">ArrayList&lt;?&gt; list2 = <span class="keyword">new</span> ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有限制的通配符:</p>
</li>
<li><p><code>&lt;?&gt;</code> :  允许所有泛型的引用调用</p>
</li>
<li><p>通配符指定上限: 上限<code>extends</code>：使用时指定的类型必须是继承某个类，或者实现某个接口，即 &lt;=</p>
</li>
<li><p>通配符指定下限: 下限<code>super</code>：使用时指定的类型不能小于操作的类，即 &gt;=</p>
</li>
<li><p>举例：</p>
<ul>
<li><p><code>&lt;? extends Number&gt;</code> (无穷小 , Number] 只允许泛型为Number及Number子类的引用调用</p>
</li>
<li><p><code>&lt;? super Number&gt;</code> [Number , 无穷大) 只允许泛型为Number及Number父类的引用调用</p>
</li>
<li><p><code>&lt;? extends Comparable&gt;</code> 只允许泛型为实现Comparable接口的实现类的引用调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection3</span><span class="params">(Collection&lt;? extends Person&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why?</span></span><br><span class="line">    Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection4</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Person&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why?</span></span><br><span class="line">        Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="9-2-File类"><a href="#9-2-File类" class="headerlink" title="9.2 File类"></a>9.2 File类</h3><ul>
<li>File类是一个与系统无关的类, 任何操作系统都可以使用这个类中的方法</li>
</ul>
<h4 id="1-File概述"><a href="#1-File概述" class="headerlink" title="1. File概述"></a>1. File概述</h4><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示, 主要用于文件和目录的创建、查找和删除等操作.</p>
<ul>
<li>File.pathSeparator 路径分隔符, windows系统中是 ; , Linux是 : .  </li>
<li>File.separator 文件名称分隔符,  windows是 反斜杠 , Linux是正斜杠/  </li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h4><ul>
<li><p><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例.  </p>
</li>
<li><p><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例.  </p>
</li>
<li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例.  </p>
</li>
<li><p>构造举例, 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">"D:\\aaa.txt"</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">"D:\\aaa\\bbb.txt"</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">String parent = <span class="string">"d:\\aaa"</span>;</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录.</li>
<li>无论该路径下是否存在文件或者目录, 都不影响File对象的创建, 也就是说创建File对象, 只是把字符串路径封装为File对象, 不考虑路径的真假情况</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3 常用方法"></a>3 常用方法</h4><h5 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h5><ul>
<li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串.</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串.</p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称.  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度.</p>
<ul>
<li><p>方法演示, 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:/aaa/bbb.java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"文件绝对路径:"</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"文件构造路径:"</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">"文件名称:"</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">"文件长度:"</span>+f.length()+<span class="string">"字节"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:/aaa"</span>);</span><br><span class="line">        System.out.println(<span class="string">"目录绝对路径:"</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"目录构造路径:"</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">"目录名称:"</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">"目录长度:"</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：length( ), 表示文件的长度.若File对象表示目录, 则返回值未指定.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h5><ul>
<li><p><strong>绝对路径</strong>：从盘符开始的路径, 这是一个完整的路径.</p>
</li>
<li><p><strong>相对路径</strong>：相对于项目目录的路径, 这是一个便捷的路径, 开发中经常使用.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\bbb.java"</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"bbb.java"</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h5><ul>
<li><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在.</p>
</li>
<li><p><code>public boolean isDirectory()</code> ：此File表示的是否为目录.</p>
</li>
<li><p><code>public boolean isFile()</code> ：此File表示的是否为文件.</p>
</li>
<li><p>方法演示, 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:\\aaa\\bbb.java"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">        <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa\\bbb.java 是否存在:"</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 是否存在:"</span>+f2.exists());</span><br><span class="line">        <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 文件?:"</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 目录?:"</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h5><ul>
<li><p><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时, 创建一个新的空文件.  </p>
</li>
<li><p><code>public boolean delete()</code> ：删除由此File表示的文件或目录.  </p>
</li>
<li><p><code>public boolean mkdir()</code> ：创建由此File表示的目录.</p>
</li>
<li><p><code>public boolean mkdirs()</code> ：创建由此File表示的目录, 包括任何必需但不存在的父目录.</p>
</li>
<li><p>方法演示, 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"aaa.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目录的创建</span></span><br><span class="line">        File f2= <span class="keyword">new</span> File(<span class="string">"newDir"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f2.mkdir()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多级目录</span></span><br><span class="line">        File f3= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件的删除</span></span><br><span class="line">        System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法, 如果此File表示目录, 则目录必须为空才能删除.</p>
</blockquote>
</li>
</ul>
<h4 id="4-目录的遍历"><a href="#4-目录的遍历" class="headerlink" title="4. 目录的遍历"></a>4. 目录的遍历</h4><ul>
<li><p><code>public String[] list()</code> ：返回一个String数组, 表示该File目录中的所有子文件或目录.</p>
</li>
<li><p><code>public File[] listFiles()</code> ：返回一个File数组, 表示该File目录中的所有的子文件或目录.  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹的名称.</span></span><br><span class="line">        String[] names = dir.list();</span><br><span class="line">        <span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象, 只要拿到了文件对象, 那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:<br>调用listFiles方法的File对象, 必须是实际存在的目录, 否则返回null, 无法进行遍历.  </p>
</blockquote>
</li>
</ul>
<h4 id="5-文件过滤器"><a href="#5-文件过滤器" class="headerlink" title="5. 文件过滤器"></a>5. 文件过滤器</h4><p>在File类中,有2个和ListFiles重载的方法,方法的参数传递的就是过滤器</p>
<ol>
<li><p><code>File[] listFiles(FileFilter filter)</code> 返回抽象路径名(File对象)数组</p>
<ul>
<li>这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录.</li>
</ul>
</li>
<li><p><code>File[] listFiles(FilenameFilter filter)</code> 返回抽象路径名(File对象)数组  </p>
<ul>
<li>这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录.</li>
</ul>
</li>
</ol>
<ul>
<li><p><code>java.io.FileFilter</code> 是一个接口, 是File对象的过滤器.  </p>
<ul>
<li>作用: 用来过滤文件(File对象)  </li>
<li>抽象方法:用来过滤文件的方法  </li>
<li><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中, 符合则返回true.  </li>
<li>参数: <code>pathname</code> 使用<code>ListFiles</code>方法遍历目录.得到每一个文件对象  </li>
</ul>
</li>
<li><p><code>java.io.FilenameFilter</code>接口: 实现此接口的类实例可用于过滤器文件名  </p>
<ul>
<li><p>作用: 用于过滤文件名称</p>
</li>
<li><p>抽象方法:用来过滤文件的方法</p>
</li>
<li><p><code>boolean accept(File dir, String name)</code> 测试指定文件是否应该包含在某一文件列表中  </p>
</li>
<li><p>参数：  </p>
<ul>
<li>dir - 被找到的文件所在的目录.  </li>
<li>name - 文件的名称.  </li>
</ul>
</li>
<li><p>返回：  </p>
<ul>
<li>当且仅当该名称应该包含在文件列表中时返回 true；否则返回 false</li>
</ul>
<blockquote>
<p>注意:<br>两个过滤器接口是没有实现类的,需要我们自己写实现类,重写过滤的方法accept,在方法中自定义过滤的规则</p>
</blockquote>
</li>
</ul>
</li>
<li><p>分析：  </p>
<ol>
<li><p>接口作为参数, 需要传递子类对象, 重写其中方法.我们选择匿名内部类方式, 比较简单.</p>
</li>
<li><p>accept方法, 参数为File, 表示当前File下所有的子文件和子目录.保留住则返回true, 过滤掉则返回false.</p>
</li>
<li><p>通过过滤器的作用, listFiles(FileFilter)返回的数组元素中, 子文件对象都是符合条件的, 可以直接打印.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterImpl</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保留住则返回true, 过滤掉则返回false.</span></span><br><span class="line">        <span class="comment">// 如果pathname是一个文件夹,也返回true, 继续遍历这个文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础学习笔记(一)</title>
    <url>/posts/ccb0c92d.html</url>
    <content><![CDATA[<h2 id="1-NoSQL-概念"><a href="#1-NoSQL-概念" class="headerlink" title="1. NoSQL 概念"></a>1. NoSQL 概念</h2><h3 id="1-NoSQL-数据模型简介"><a href="#1-NoSQL-数据模型简介" class="headerlink" title="1. NoSQL 数据模型简介"></a>1. NoSQL 数据模型简介</h3><ul>
<li><p>聚合模型</p>
<ol>
<li><p>KV键值对</p>
</li>
<li><p>Bson: JSON串的数据表达</p>
</li>
<li><p>列族:</p>
</li>
<li><p>图形</p>
<blockquote>
<p><a href="https://github.com/xingbofeng/Reading-Note/blob/master/%E3%80%8ANoSQL%E7%B2%BE%E7%B2%B9%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.md" target="_blank" rel="noopener">聚合模型</a></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="2-NoSQL数据库四大分类"><a href="#2-NoSQL数据库四大分类" class="headerlink" title="2. NoSQL数据库四大分类"></a>2. NoSQL数据库四大分类</h3><ol>
<li>KV键值对: redis, memcache, tair, BerkeleyDB</li>
<li>文档型数据库(Bson格式):CouchDB, MongoDB: 基于分布式文件存储的数据库, 介于关系型数据库和非关系数据库之间</li>
<li>列族: HBase, Cassandra, 分布式文件系统</li>
<li>图形: 放的是图谱, Neo4J, InfoGrid</li>
</ol>
<a id="more"></a>

<h3 id="3-分布式数据库中的CAP原理"><a href="#3-分布式数据库中的CAP原理" class="headerlink" title="3. 分布式数据库中的CAP原理"></a>3. 分布式数据库中的CAP原理</h3><ul>
<li><p>传统的关系型数据库是 ACID  </p>
<ul>
<li>Atomicity 原子性  要么都执行，要么都回滚</li>
<li>Consistency 一致性  保证数据的状态操作前和操作后保持一致</li>
<li>Isolation 独立性  多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</li>
<li>Durability 持久性  一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</li>
</ul>
</li>
<li><p>NoSQL 中的 CAP+BASE</p>
<p><img src="https://i.loli.net/2020/03/20/cMZRBv9VHQyEXoO.png" alt="cap.png"></p>
<ul>
<li>Consitency 强一致性 : 写操作之后的读操作，必须返回该值</li>
<li>Availability 可用性 : 只要收到用户的请求，服务器就必须给出回应</li>
<li>Partition tolerance 分区容错性 : 区间通信可能失败</li>
<li>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到</li>
<li><a href="https://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP定理含义</a></li>
</ul>
</li>
<li><p>CAP的3进2</p>
<ul>
<li>CAP理论的核心是: 一个分布式系统不可以同时很好的满足一致性, 可用性和分区容错性这3个需求.</li>
<li>最多只能同时较好的满足其中2个</li>
<li>CA 单点集群, 满足一致性和可用性, 扩展性不强, 传统的数据库, MySQL, Oracle</li>
<li>CP 满足一致性, 分区容错性, 性能不高, NoSQL, MongoDB,redis,HBase</li>
<li>AP 满足可用性, 分区容错性, 对一致性要求低, CouchDB…,大多数网站架构的选择</li>
</ul>
</li>
<li><p>BASE 是为了解决关系数据库强一致性引起的可用性降低而提出的解决方案</p>
<ul>
<li>Basically Availabel 基本可用</li>
<li>Soft state 软状态</li>
<li>Eventually consistent 最终一致</li>
<li>通过让系统对某一时刻的数据一致性的要求来换取系统整体伸缩性和性能上改观, 即牺牲C换取AP,通过BASE再达到C</li>
</ul>
</li>
</ul>
<h3 id="4-分布式-集群简介"><a href="#4-分布式-集群简介" class="headerlink" title="4. 分布式+集群简介"></a>4. 分布式+集群简介</h3><ul>
<li>分布式: 不同的多台服务器上部署不同的服务模块(工程), 他们之间通过Rpc/Rmi之间通信和调用, 对外提供服务和组内协助</li>
<li>集群: 不同的多台服务器上面部署相同的服务模块, 通过分布式调度软件进行同意的调度, 对外提供服务和访问</li>
</ul>
<h2 id="2-Redis-介绍"><a href="#2-Redis-介绍" class="headerlink" title="2. Redis 介绍"></a>2. Redis 介绍</h2><ul>
<li>REmote DIctionary Server(远程字典服务器)<ul>
<li>C语言写的, 遵守BSD协议, 是一个高性能的KV分布式内存数据库, 基于内存运行, 并支持持久化的NoSQL数据库</li>
<li>支持异步将内存中的数据写到硬盘上, 同时不影响继续服务</li>
<li>取最新N个数据</li>
<li>模拟类似HttpSession这种要设定过期时间的功能</li>
<li>发布,订阅消息系统</li>
<li>定时器, 计数器  </li>
</ul>
</li>
<li>特点:<ul>
<li>redis支持数据的持久化, 可以将内存中的数据保存再磁盘中, 重启的时候可以再次加载使用</li>
<li>redis不仅支持KV存储, 还提供了list,set,zset,hash等数据结构的存储</li>
<li>redis支持数据备份, 即master-slave模式的数据备份</li>
<li>KV + cache + persistent</li>
</ul>
</li>
</ul>
<h3 id="1-Redis的5大数据类型"><a href="#1-Redis的5大数据类型" class="headerlink" title="1. Redis的5大数据类型"></a>1. Redis的5大数据类型</h3><ul>
<li><p>String字符串</p>
<ul>
<li>一个key对应一个value</li>
<li>string 类型是二进制安全的, 可以包含任何数据, 比如图片或序列化的对象</li>
<li>string 是redis最基本的类型, 一个redis中字符串value最多可以是512M</li>
</ul>
</li>
<li><p>Hash哈希</p>
<ul>
<li>是一个键值对集合, 类似Java的Map</li>
<li>redis hash 是一个 string 类的field 和value 的映射表, 适合存储对象, 类似Object&lt;String, Object&gt;</li>
</ul>
</li>
<li><p>List列表</p>
<ul>
<li>简单的字符串列表, 按照插入的顺序排序, 可以添加一个元素到列表的头部或尾部</li>
<li>底层实际是个链表</li>
</ul>
</li>
<li><p>Set集合</p>
<ul>
<li>string类型的无序,不能重复集合, 通过hashTable实现</li>
</ul>
</li>
<li><p>Zset有序集合</p>
<ul>
<li>和set一样是string类型的集合, 不同的是每个元素关联一个double类型的分数, redis通过分数对集合中的成员进行从大到小的排序, zset的成员是唯一的, 分数却可以重复</li>
</ul>
</li>
<li><p><a href="http://redisdoc.com" target="_blank" rel="noopener">redis命令手册</a></p>
</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li>redis键(key)<ul>
<li>keys *</li>
<li>exists key, 判断key是否存在, 1存在, 0不存在</li>
<li>move key num, 移动key至num号库, 当前库没有该key</li>
<li>expire key 秒数, 给指定key设置过期时间</li>
<li>ttl key 看出key还有多少秒过期, -1永不过期, -2 已过期(自动删除了)</li>
<li>type key 查看key是什么类型</li>
<li>del key 删除该key</li>
<li>set key value 为key 设定value, 若key已存在, 覆盖旧的值</li>
</ul>
</li>
<li>redis字符串(String)<ul>
<li>set/get/del/append/strlen</li>
<li>incr/decr/incrby/decrby 是数字才可以加减</li>
<li>getrange/setrange key 0 3; 获取[0,3]</li>
<li>setex key 12 value;  key 只存活12s</li>
<li>setnx(if not exist) key value;</li>
<li>mset/mget/msetnx</li>
</ul>
</li>
<li>redis列表(List)<ul>
<li>lpush/rpush/lrange</li>
<li>lpop/rpop</li>
<li>lindex</li>
<li>llen</li>
<li>lrem key N value; 删除N个值</li>
<li>ltrim key begin edn; 截取指定范围的值在赋值给key</li>
<li>rpoplpush 源列表 目标列表</li>
<li>lset key index value</li>
<li>linsert key before/after 值1 值2</li>
</ul>
</li>
<li>redis集合(set)<ul>
<li>sadd/smember/sismember</li>
<li>scard 获取集合元素个数</li>
<li>srem key value</li>
<li>srandmember key num;  随机num个出栈</li>
<li>spop key 随机出栈</li>
<li>smove key1 key2 value1;  将key1中的value1赋给key2</li>
<li>数学集合类:<ul>
<li>sdiff 差集</li>
<li>sinter 交集</li>
<li>sunion 并集</li>
</ul>
</li>
</ul>
</li>
<li>redis哈希(Hash)<ul>
<li>KV模式不变, 但V是一个键值对</li>
<li>hset/hget/hmset/hmget/hgetall/hdel</li>
<li>hlen</li>
<li>hexists key 在key中存在的某个值的key</li>
<li>hkeys / hvals</li>
<li>hincrby/hincrbyfloat</li>
<li>hsetnx</li>
</ul>
</li>
<li>redis有序集合Zset(sorted set)<ul>
<li>在set的基础上,加一个score值, set是 k1 v1 v2 v3; zset 是 k1 score1 v1 score2 v2</li>
<li>zadd / zrange</li>
<li>zrangebyscore key 分数范围  ‘(‘ 表示不包含,  eg: 60 90 -&gt; [60,90] (60 (90 -&gt; (60,90)</li>
<li>zrem key 某score下对应的value值, 删除元素</li>
<li>zcard/zcount key score区间 / zrank key values值 作用是获得下标值/zscore key 对应值, 获得分数</li>
<li>zrevrand key values, 逆序获得下标值</li>
<li>zrevrange</li>
<li>zrevrangebyscore key</li>
</ul>
</li>
</ol>
<h3 id="2-解析配置文件-redis-conf"><a href="#2-解析配置文件-redis-conf" class="headerlink" title="2. 解析配置文件 redis.conf"></a>2. 解析配置文件 redis.conf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k &#x3D;&gt; 1000 bytes</span><br><span class="line"># 1kb &#x3D;&gt; 1024 bytes</span><br><span class="line"># 1m &#x3D;&gt; 1000000 bytes</span><br><span class="line"># 1mb &#x3D;&gt; 1024*1024 bytes</span><br><span class="line"># 1g &#x3D;&gt; 1000000000 bytes</span><br><span class="line"># 1gb &#x3D;&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order</span><br><span class="line"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn so</span><br><span class="line"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">设置tcp的backlog, backlog是一个连接队列, backlog队列总和 &#x3D; 未完成三次握手队列 + 已完成三次握手队列</span><br></pre></td></tr></table></figure>

<h2 id="3-Redis-持久化"><a href="#3-Redis-持久化" class="headerlink" title="3. Redis 持久化"></a>3. Redis 持久化</h2><h3 id="1-RDB-redis-database"><a href="#1-RDB-redis-database" class="headerlink" title="1. RDB(redis database)"></a>1. RDB(redis database)</h3><ul>
<li><p>在指定的时间间隔内将内存中的数据集快照写入磁盘, 即Snapshot快照, 它恢复时是将快照文件直接读入到内存中</p>
</li>
<li><p>特点:</p>
<ul>
<li>Redis会单独创建(fork)一个子进程来持久化, 会先将数据写入到一个临时文件中, 等到持久化过程结束了,再用这个临时文件替换上次持久化号的文件  </li>
<li>整个过程中, 主进程是不进行任何IO操作的，　这就确保了极高的性能  </li>
<li>如果需要大规模数据的回复, 且对于数据恢复的完整性不是非常敏感, RDB方式要比AOF方式更高效</li>
<li>RDB的缺点是最后一次持久化后的数据可能丢失  </li>
</ul>
</li>
<li><p>Fork: 复制一个与当前进程一样的进程, 新进程的所有数据,数值和原进程一致, 但是是一个全新的进程, 并作为原进程的子进程, 但是性能会暂时2倍膨胀</p>
</li>
<li><p>Rdb保存的是dump.rdb, 在运行目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line">################################################################################</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行直接输入 save/bgsave,flushall(清空了, 无意义) 可以立刻保存<ul>
<li>save : 阻塞式保存</li>
<li>bgsave : 后台异步保存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-AOF-append-only-file"><a href="#2-AOF-append-only-file" class="headerlink" title="2. AOF(append only file)"></a>2. AOF(append only file)</h3><ul>
<li><p>以日志的形式记录每个<strong>写</strong>操作,将redis执行过的所有写指令记录下来(读操作不记录),只可以追加文件, 不可以改写文件, redis启动之初回读取该文件重新构建数据, 即redis重启的时候根据日志文件的内容重新执行一遍写指令以恢复数据</p>
<ul>
<li>该功能默认是关闭的</li>
<li>生成的文件在dir下, appendonly.aof, 可以和dump.rdb共存, 但是首先加载aof文件  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">################### APPEND ONLY MODE ###################</span><br><span class="line">682 # By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line">683 # good enough in many applications, but an issue with the Redis process or</span><br><span class="line">684 # a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line">685 # the configured save points).</span><br><span class="line">686 #</span><br><span class="line">687 # The Append Only File is an alternative persistence mode that provides</span><br><span class="line">688 # much better durability. For instance using the default data fsync policy</span><br><span class="line">689 # (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line">690 # dramatic event like a server power outage, or a single write if something</span><br><span class="line">691 # wrong with the Redis process itself happens, but the operating system is</span><br><span class="line">692 # still running correctly.</span><br><span class="line">693 #</span><br><span class="line">694 # AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line">695 # If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line">696 # with the better durability guarantees.</span><br><span class="line">697 #</span><br><span class="line">698 # Please check http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;persistence for more information.</span><br><span class="line"></span><br><span class="line">700 appendonly no</span><br><span class="line"></span><br><span class="line">702 # The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">704 appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">706 # The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line">707 # instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line">708 # data on disk, some other OS will just try to do it ASAP.</span><br><span class="line">709 #</span><br><span class="line">710 # Redis supports three different modes:</span><br><span class="line">711 #</span><br><span class="line">712 # no: don&#39;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line">713 # always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line">714 # everysec: fsync only one time every second. Compromise.</span><br><span class="line">715 #</span><br><span class="line">716 # The default is &quot;everysec&quot;, as that&#39;s usually the right compromise between</span><br><span class="line">717 # speed and data safety. It&#39;s up to you to understand if you can relax this to</span><br><span class="line">718 # &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line">719 # it wants, for better performances (but if you can live with the idea of</span><br><span class="line">720 # some data loss consider the default persistence mode that&#39;s snapshotting),</span><br><span class="line">721 # or on the contrary, use &quot;always&quot; that&#39;s very slow but a bit safer than</span><br><span class="line">722 # everysec.</span><br><span class="line">723 #</span><br><span class="line">724 # More details please check the following article:</span><br><span class="line">725 # http:&#x2F;&#x2F;antirez.com&#x2F;post&#x2F;redis-persistence-demystified.html</span><br><span class="line">726 #</span><br><span class="line">727 # If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line">729 # appendfsync always</span><br><span class="line">730 appendfsync everysec</span><br><span class="line">731 # appendfsync no</span><br><span class="line"></span><br><span class="line">733 # When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line">734 # saving process (a background save or AOF log background rewriting) is</span><br><span class="line">735 # performing a lot of I&#x2F;O against the disk, in some Linux configurations</span><br><span class="line">745 # the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line">746 # possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line">747 # default Linux settings).</span><br><span class="line">748 #</span><br><span class="line">749 # If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line">750 # &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"></span><br><span class="line">752 no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">754 # Automatic rewrite of the append only file.</span><br><span class="line">755 # Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line">756 # BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line">757 #</span><br><span class="line">758 # This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line">759 # latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line">760 # the AOF at startup is used).</span><br><span class="line">761 #</span><br><span class="line">762 # This base size is compared to the current size. If the current size is</span><br><span class="line">763 # bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line">764 # you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line">765 # is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line">766 # is reached but it is still pretty small.</span><br><span class="line">767 #</span><br><span class="line">768 # Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line">769 # rewrite feature.</span><br><span class="line"></span><br><span class="line">771 auto-aof-rewrite-percentage 100</span><br><span class="line">772 auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">774 # An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line">775 # startup process, when the AOF data gets loaded back into memory.</span><br><span class="line">776 # This may happen when the system where Redis is running</span><br><span class="line">777 # crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line">778 # data&#x3D;ordered option (however this can&#39;t happen when Redis itself</span><br><span class="line">779 # crashes or aborts but the operating system still works correctly).</span><br><span class="line">780 #</span><br><span class="line">781 # Redis can either exit with an error when this happens, or load as much</span><br><span class="line">782 # data as possible (the default now) and start if the AOF file is found</span><br><span class="line">783 # to be truncated at the end. The following option controls this behavior.</span><br><span class="line">784 #</span><br><span class="line">785 # If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="line">786 # the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line">787 # Otherwise if the option is set to no, the server aborts with an error</span><br><span class="line">788 # and refuses to start. When the option is set to no, the user requires</span><br><span class="line">789 # to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="line">790 # the server.</span><br><span class="line">791 #</span><br><span class="line">792 # Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="line">793 # the server will still exit with an error. This option only applies when</span><br><span class="line">794 # Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="line">795 # will be found.</span><br><span class="line">796 aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">798 # When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line">799 # AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line">800 # on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line">801 #</span><br><span class="line">802 #   [RDB file][AOF tail]</span><br><span class="line">803 #</span><br><span class="line">804 # When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="line">805 # string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="line">806 # tail.</span><br><span class="line">807 aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line">809 ################## LUA SCRIPTING  ################</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结</p>
<ul>
<li>AOF文件是一个只进行追加的日志文件</li>
<li>redis可以在AOF文件体积变得过大时, 自动地在后台对AOF进行重写</li>
<li>AOF文件有序地保存了对数据库执行的所有写入操作, 这些写入操作以reids协作的格式保存, 因此,AIF文件的内容容易读懂</li>
<li>对相同的数据集来说, AOF文件的体积通常大于RDB文件</li>
<li>根据所使用的fsync策略, AOF的速度可能会慢于RDB</li>
</ul>
</li>
</ul>
<h3 id="3-小总结"><a href="#3-小总结" class="headerlink" title="3. 小总结"></a>3. 小总结</h3><ul>
<li>RDB持久化方式能在指定的时间间隔内对数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作, 当服务器重启的时候, 会重新执行这些命令来恢复原始的数据, redis可以对AOF文件后台重写, 使得AOF文件的体积不至于过大</li>
<li>只做缓存: 即数据值在服务器运行的时候存在, 可以不用持久化</li>
<li>作者建议同时开启2种持久化方式:  <ul>
<li>优先载入AOF文件, 因为通常AOF要比RDB存储的完整</li>
<li>RDB更适合于备份数据库(AOF不断变化, 不适合备份), 留一手</li>
</ul>
</li>
</ul>
<h2 id="4-Redis-事务"><a href="#4-Redis-事务" class="headerlink" title="4. Redis 事务"></a>4. Redis 事务</h2><ul>
<li><p>概念:  </p>
<ul>
<li>可以一次执行多个命令, 本质是<strong>一组命令的集合</strong>, 一个事务种的所有命令都会序列化, 按顺序的串行化执行,而不会被其他命令插入</li>
<li>一个队列中, 一次性, 顺序性,排他性的执行一系列命令</li>
</ul>
</li>
<li><p>常用命令:</p>
<ol>
<li>discard: 取消事务, 放弃执行事务块内的所有命令</li>
<li>exec: 执行事务块内的所有命令</li>
<li>multi: 标志着事务块的开启</li>
<li>unwatch: 取消watch命令对所有key的监视</li>
<li>watch key: 监视1个或多个 key, 如果在事务执行前,这个key被其他命令所改动, 那么事务将被打断</li>
</ol>
</li>
<li><p>redis 部分支持事务</p>
<ul>
<li>命令全部正确, 正常批量执行</li>
<li>discard 放弃执行所有事务</li>
<li>全体连坐 — 有严重错误命令, 直接报错, 全部失败</li>
<li>冤头寨主 — 小的错误, 比如给字母 incr 1, 只有该条命令失败</li>
<li>watch监控<ul>
<li>使用的是乐观锁</li>
<li>悲观锁/乐观锁/CAS(check and set)<ol>
<li>悲观锁:(认为一定会出事, 在MySQL中就是把整张表都锁了,每次拿数据的时候都会上锁, 并发差, 一致性好)</li>
<li>乐观锁:(认为不会出事, 不会上锁,在一张表后加一个version字段; 一旦有并发的修改, 在提交的时候,如果版本号和查询的时候不相同, 就失败, 先把数据更新到别人改好的版本, 再进行自己的修改, 直到修改成功): 提交版本必须大于当前记录版本才更新</li>
</ol>
</li>
<li>一旦执行了exec, 之前的监控锁都被取消</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="插曲-Redis-发布和订阅"><a href="#插曲-Redis-发布和订阅" class="headerlink" title="插曲: Redis 发布和订阅"></a>插曲: Redis 发布和订阅</h3><ul>
<li>进程间的一种消息通信模式: 发送者(pub)发送消息, 订阅者(sub)接收消息</li>
</ul>
<h2 id="5-Redis的复制-master-slave"><a href="#5-Redis的复制-master-slave" class="headerlink" title="5. Redis的复制(master/slave)"></a>5. Redis的复制(master/slave)</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul>
<li>主从复制, 主机数据更新后根据配置和策略, 自动同步到备机的master/slave机制, master以写为主, slave以读为主</li>
<li>读写分离, 容灾恢复  </li>
</ul>
<h3 id="2-怎么用"><a href="#2-怎么用" class="headerlink" title="2. 怎么用"></a>2. 怎么用</h3><ol>
<li>配从(库)不配主(库)</li>
<li>从库配置: slaveof 主库IP 主库端口<ul>
<li>每次从机与master断开之后, 都要重新连接, 除非配置到redis.conf文件中</li>
<li>Info replication</li>
</ul>
</li>
<li>修改配置文件细节:<ul>
<li>拷贝多个redis.conf文件</li>
<li>开启daemonize yes</li>
<li>pid文件名字</li>
<li>指定端口</li>
<li>log文件名字</li>
<li>dump.rdb名字</li>
</ul>
</li>
<li>常用3招:<ol>
<li>一主二仆<ul>
<li>如果主机主动断开, 从机默认不发生变化, 主机重新连接后, 依然保持不变, 但是从机主动断开后需要重新连接主机</li>
</ul>
</li>
<li>薪火相传</li>
<li>反客为主: slaceof no one 使当前数据库停止与其他数据库的同步,转为u主数据库</li>
</ol>
</li>
</ol>
<h3 id="3-复制原理"><a href="#3-复制原理" class="headerlink" title="3.  复制原理"></a>3.  复制原理</h3><ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>master接到命令后, 启动后台的存盘程序, 同时收集所有接收到的用于修改数据集命令, 在后台进程执行完毕后, master将传送整个数据文件到slave, 已完成一次完全同步</li>
<li>全量复制: 而slave服务在接受到数据库文件数据后, 将其存盘并加载到内存中</li>
<li>增量复制: master继续将新的所有收集到的修改命令一次传给salve, 完成同步</li>
<li>但是只要是重新连接master, 一次完全同步将被自动执行</li>
</ul>
<h3 id="4-哨兵模式-sentinel"><a href="#4-哨兵模式-sentinel" class="headerlink" title="4. 哨兵模式(sentinel)"></a>4. 哨兵模式(sentinel)</h3><ul>
<li><p>反客为主的自动版, 后台监控主机是否故障,如果故障, 根据投票数将从库转换为主库</p>
</li>
<li><p>步骤:</p>
<ul>
<li>新建sentinel.conf文件跟之前的配置文件在同一目录</li>
<li>配置哨兵, 填写内容<ul>
<li>sentinel monitor 被监控数据库名字 ip:端口号 1<br>数字1表示主机挂掉后,slave投票看让谁接替成为宿主机, 票数多的成为主机</li>
</ul>
</li>
<li>启动哨兵<ul>
<li>redis-sentinel …./sentinel.conf</li>
</ul>
</li>
<li>挂掉的主机重启回来后, 称为新的主机的slave</li>
</ul>
</li>
<li><p>复制的缺点</p>
<ul>
<li>延迟</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8中HashMap更新映射项的方法(merge)笔记</title>
    <url>/posts/85124b9.html</url>
    <content><![CDATA[<ul>
<li><p>在jdk1.8中, HashMap中更新了几个关于更新映射项的方法, 个人觉得很好用,于是写个笔记小记一下.</p>
<ul>
<li><code>public V getOrDefault(Object key, V defaultValue)</code></li>
<li><code>public V putIfAbsent(K key, V value)</code>  </li>
<li><code>public V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code></li>
</ul>
</li>
<li><p>处理映射项的一个难点是更新映射项, 也就是我们常说的键值对中的值. 正常情况下, 可以通过<code>get(key)</code>方法获得值, 然后对其进行更新, 然后再放回更新的值. 但是要考虑到键第一次出现的时候. 比如, 再统计某个单词在文件中出现的频度.  </p>
</li>
<li><p>在看到一个单词(word)时, 将对应的计数器加1, 如下所示</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">String word = <span class="string">"word"</span>;</span><br><span class="line">counts.put(word, counts.get(word)+<span class="number">1</span>); <span class="comment">// NullPointerException, 第一次获取"1"时get返回null</span></span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>在jdk8之前我们解决这个问题, 应该就会在put前进行检测, 虽然不难, 但是当jdk8后可以更加便捷的方法.  </p>
<ul>
<li><p>第一种方法就是利用<code>getOrDefault</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>api中的描述是:<blockquote>
<p>Returns the value to which the specified key is mapped, or if this map contains no mapping for the key.</p>
</blockquote>
</li>
<li>直接看源码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key)) ? v : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现这个默认方法其实就是把我们之前做的事简单封装了一下, 简单明了</p>
</li>
<li><p>第二种方法是先调用putIfAbsent方法, 只有当键存在时才放入一个值, 这跟我们之前的做法是一样的,只不过更加便捷.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.putIfAbsent(word,<span class="number">0</span>); <span class="comment">// 直接看源代码, 清楚明白</span></span><br><span class="line">counts.put(word, counts.get(word)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    V v = get(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        v = put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看到源码, 我不知道怎么形容了, 就是2个字, 清晰</li>
<li>第三种方法就是使用merge方法, 这也是最方便的方法, 强烈建议:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用方法引用传入sum方法, 当word第一次出现时, word的值被赋值为1,  </span></span><br><span class="line"><span class="comment">// 不是第一次出现时, 会将其值加1.</span></span><br><span class="line"><span class="comment">// 这是一个函数式接口, 用来写怎样处理默认值value和get方法得到的oldValue之间的关系</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,  BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span>   </span>&#123;</span><br><span class="line">    <span class="comment">// 确保remappingFunction 不是一个 null 值,  </span></span><br><span class="line">    <span class="comment">// 如果是null会直接抛异常, 不是null就返回对象本身.</span></span><br><span class="line">    Objects.requireNonNull(remappingFunction);  </span><br><span class="line">    Objects.requireNonNull(value);  </span><br><span class="line">    <span class="comment">// 获取当前key中的值, 如果是第一次出现的键, 会得到一个null</span></span><br><span class="line">    V oldValue = get(key);  </span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">                remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    当oldVlue为null时, 也就是说该键key第一次出现, 返回默认值value,</span></span><br><span class="line"><span class="comment">    不是第一次出现的时候, 交给函数式接口来处理, 在调用的时候可以用lambda表达式或方法引用来写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        remove(key); <span class="comment">// 如果经过以上处理, 得到的newValue还是null的话, 删去该key, 否则就正常的添加该键值对,  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法最终返回我们想要的值</span></span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>都在注释里写清楚了.</li>
<li>综上, 以后再更新映射项就考虑merge吧!</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>参考文献</strong>:<br>Java核心技术 卷1 原书第10版 , 第9章</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
