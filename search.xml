<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java位运算总结&amp;分析tableSizeFor方法</title>
    <url>/posts/3feabb4b.html</url>
    <content><![CDATA[<blockquote>
<p>在看源码的过程中, 总是会遇到各种位运算, 借此机会总结一下</p>
</blockquote>
<h2 id="位运算总结"><a href="#位运算总结" class="headerlink" title="位运算总结"></a>位运算总结</h2><h3 id="字节长度"><a href="#字节长度" class="headerlink" title="字节长度"></a>字节长度</h3><ul>
<li><p>由于 Java 是跨平台的语言, 所以 JVM 中基本数据类型的字节长度是一致的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	int: 		4 个字节</span></span><br><span class="line"><span class="comment">	short: 		2 个字节</span></span><br><span class="line"><span class="comment">	long: 		8 个字节</span></span><br><span class="line"><span class="comment">	byte: 		1 个字节</span></span><br><span class="line"><span class="comment">	float: 		4 个字节</span></span><br><span class="line"><span class="comment">	double: 	8 个字节</span></span><br><span class="line"><span class="comment">	char: 		2 个字节</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	boolean：    boolean属于布尔类型，在存储的时候不使用字节，仅仅使用 1 位来存储，范围仅仅为0和1，其字面量为true和false。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="原码-补码-反码"><a href="#原码-补码-反码" class="headerlink" title="原码, 补码, 反码"></a>原码, 补码, 反码</h3><ul>
<li>最高位是符号位。<ul>
<li>最高位为0表示正数。</li>
<li>最高位为1表示负数</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>正数</p>
<p>原码 ==  反码 == 补码</p>
</li>
<li><p>负数</p>
<p>反码 == 原码按位取反</p>
<p>补码 == 反码 + 1</p>
</li>
<li><p><strong>计算机在进行数值运算的时候，是通过补码表示每个数值的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 - 3 &#x3D; 5 + ( -3 )</span><br><span class="line">相当于 0000 0000 0000 0101 + 1111 1111 1111 1101</span><br><span class="line">    &#x3D; 1 0000 0000 0000 0010</span><br><span class="line">    </span><br><span class="line">由于 int 类型只有 4 byte，所以最高位产生了溢出，进位 1 被丢弃。</span><br><span class="line">结果就变成了 0010 也就是 2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>更详细的原码,反码, 补码知识可以看<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></p>
</blockquote>
<h3 id="位运算符-amp-、-、-、-、-gt-gt-、-lt-lt-、-gt-gt-gt"><a href="#位运算符-amp-、-、-、-、-gt-gt-、-lt-lt-、-gt-gt-gt" class="headerlink" title="位运算符 &amp;、|、~、^、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;"></a>位运算符 &amp;、|、~、^、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;</h3><blockquote>
<p>&amp;  与;  |  或;  ~  非; ^  异或</p>
</blockquote>
<h4 id="gt-gt-右移运算符"><a href="#gt-gt-右移运算符" class="headerlink" title="&gt;&gt; 右移运算符"></a>&gt;&gt; 右移运算符</h4><ul>
<li><p>数值的补码向右移 n 位，符号位不变（左边补上符号位）</p>
<ul>
<li>右移n位就相当于除以2的n次方</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[ <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> ]　 <span class="number">7</span> 的补码</span><br><span class="line">[ <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> ]　 a &gt;&gt; <span class="number">1</span> 向右移 <span class="number">1</span> 位</span><br><span class="line">  正数的补码就是原码, 所以 a &gt;&gt; <span class="number">1</span> == <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>负数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[ <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> ]　-<span class="number">7</span> 的原码</span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> ]　-<span class="number">7</span> 的反码</span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1001</span> ]　-<span class="number">7</span> 的补码</span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span> ]  a &gt;&gt; <span class="number">1</span> 向右移<span class="number">1</span>位</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负数的补码转原码: 真值的部分 取反 + 1</span></span><br><span class="line">[ <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> ]</span><br><span class="line">[ <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> ] 　得到a &gt;&gt; <span class="number">1</span>的原码</span><br><span class="line">   即 a &gt;&gt; <span class="number">1</span> == -<span class="number">4</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="lt-lt-左移运算符"><a href="#lt-lt-左移运算符" class="headerlink" title="&lt;&lt; 左移运算符"></a>&lt;&lt; 左移运算符</h4><ul>
<li><p>数值的补码全部往左移动 n 位，符号位和最高位都舍弃，最低位补 0</p>
<ul>
<li>左移 n 位就相当于乘以 2 的 n 次方</li>
</ul>
</li>
<li><p>正数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[ <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> ] <span class="number">7</span>的补码</span><br><span class="line">[ <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1100</span> ] 对于正数而言，补码就是原码</span><br><span class="line">即 a &lt;&lt; <span class="number">2</span> = <span class="number">28</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>负数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">7</span> ;</span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">2</span> ;</span><br><span class="line">[ <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> ] -<span class="number">7</span>的原码</span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> ] -<span class="number">7</span>的反码</span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1001</span> ] -<span class="number">7</span>的补码</span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">0100</span> ] a &lt;&lt; <span class="number">2</span>左移<span class="number">2</span>位</span><br><span class="line"><span class="comment">// 补码转反码</span></span><br><span class="line">[ <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span> ]</span><br><span class="line">[ <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1100</span> ] 得到a &lt;&lt; <span class="number">2</span>的原码</span><br><span class="line"> 即 a &lt;&lt; <span class="number">2</span> = -<span class="number">28</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="gt-gt-gt-无符号右移"><a href="#gt-gt-gt-无符号右移" class="headerlink" title="&gt;&gt;&gt; 无符号右移"></a>&gt;&gt;&gt; 无符号右移</h4><ul>
<li><p>忽略符号位，空位都以0补齐</p>
</li>
<li><p>正数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[ <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> ]  <span class="number">7</span>的补码</span><br><span class="line">[   <span class="number">00</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> ]  a &gt;&gt;&gt; <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"> 其实前面<span class="number">2</span>位还是<span class="number">0</span>, 但是这样看的更明显</span><br><span class="line"> 相当于直接右移n位</span><br></pre></td></tr></table></figure>
</li>
<li><p>负数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[ <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1001</span> ]  -<span class="number">7</span>的补码</span><br><span class="line">[ <span class="number">0011</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> ]  a &gt;&gt;&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="分析-tableSizeFor-int-cap-方法"><a href="#分析-tableSizeFor-int-cap-方法" class="headerlink" title="分析 tableSizeFor(int cap) 方法"></a>分析 tableSizeFor(int cap) 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * MAXIMUM_CAPACITY == 2^30</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法是 jdk1.8 HashMap 中的一个方法</p>
</li>
<li><p>首先明确: 2 的整数次幂, 从二进制上表示即第 i 位上为 1, 其他位均为 0, 表示 $$2^i$$</p>
</li>
<li><p>传入的是一个 int 值, 4 byte , 32 bit</p>
<p>先来假设 n 的二进制为 01xxx…xxx, </p>
<p>对 n 右移 1 位：001xx…xxx，再位或：011xx…xxx</p>
<p>对 n 右移 2 位：00011…xxx，再位或：01111…xxx</p>
<p>此时前面已经有 4 个 1了，再右移 4 位且位或可得 8 个 1</p>
<p>同理，有 8 个1 后，右移 8 位会让后 8 位也为1</p>
<p>最后右移 16 位 , 则保证从最高位的 1 开始, 后面全是 1</p>
</li>
<li><p>也就是将 0…01xxx..xx变为 0…0111..111 这样的形式, 然后 n + 1, 产生了<strong>进位</strong></p>
<p>得到了 2 的整数次幂的值</p>
</li>
<li><p>让<code>cap - 1</code>再赋值给 n 的目的是另找到的目标值大于或<strong>等于</strong>原值。</p>
<p>例如二进制 <code>1000</code>，十进制数值为 8。如果不对它减 1 而直接操作，将得到答案 <code>10000</code>，即16。</p>
<p>显然不是结果。减 1 后二进制为 <code>111</code>，再进行操作则会得到原来的数值 <code>1000</code>，即 8</p>
<blockquote>
<p>参考: <a href="https://www.cnblogs.com/loading4/p/6239441.html" target="_blank" rel="noopener">Java8 HashMap之tableSizeFor</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug之路-SpringBoot拦截自定义注解</title>
    <url>/posts/be3e954d.html</url>
    <content><![CDATA[<blockquote>
<p>背景: HandlerInterceptor + 自定义注解 用作权限拦截, 但是在测试时发现, 有的方法能获取到, 有的方法获取不到方法上的注解</p>
</blockquote>
<p>最后发现, 是因为请求发错, 本来应该报 405 , Method not allow,  但是由于在拦截器中加入了判断, 直接返回了别的信息, 所以看不到 405, 导致以为是没有获取到注解</p>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><p>过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不是映射到方法，直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是方法探测，直接通过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"OPTIONS"</span>.equals(request.getMethod())) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果方法有JwtIgnore注解，直接通过</span></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        JwtIgnore annotation = AnnotationUtils.findAnnotation(method, JwtIgnore<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span> &amp;&amp; annotation.value()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String header = request.getHeader(JwtTokenUtil.AUTH_HEADER_KEY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(header) || !header.startsWith(JwtTokenUtil.TOKEN_PREFIX)) &#123;</span><br><span class="line">            returnJson(response, HttpServletResponse.SC_UNAUTHORIZED, <span class="string">"error"</span>, <span class="string">"Invalid authorization code"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String token = header.substring(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.verifyToke(token)) &#123;</span><br><span class="line">            returnJson(response, HttpServletResponse.SC_UNAUTHORIZED, <span class="string">"error"</span>, <span class="string">"Authorization code expire, please refresh token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnJson</span><span class="params">(HttpServletResponse response, Integer code, String msg, String result)</span> </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">        response.setStatus(code);</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">            JSONObject message = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            message.put(<span class="string">"msg"</span>, msg);</span><br><span class="line">            message.put(<span class="string">"result"</span>, result);</span><br><span class="line">            String s = message.toJSONString();</span><br><span class="line">            writer.print(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JwtIgnore &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拦截器配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        InterceptorRegistration interceptor = registry.addInterceptor(<span class="keyword">new</span> AccessFilter());</span><br><span class="line">        interceptor.addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>要细心 ⊙﹏⊙∥, 不然就这个问题调试了半天</li>
</ul>
]]></content>
      <categories>
        <category>Bug 之路</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 编译 OpenJDK-7u75</title>
    <url>/posts/35ab761c.html</url>
    <content><![CDATA[<blockquote>
<p>实践 深入理解Java虚拟机 一书第一章的手动编译 JDK</p>
<p>环境信息:</p>
<ul>
<li>CentOS 7.8</li>
<li><a href="https://download.java.net/openjdk/jdk7u75/ri/openjdk-7u75-src-b13-18_dec_2014.zip" target="_blank" rel="noopener">OpenJDK7u75</a></li>
<li>jdk1.7.0_81</li>
</ul>
</blockquote>
<h3 id="准备工作与开始编译"><a href="#准备工作与开始编译" class="headerlink" title="准备工作与开始编译"></a>准备工作与开始编译</h3><ul>
<li><p>安装所需要的依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要的依赖 </span></span><br><span class="line">yum -y install gawk m4 binutils libstdc++-static ant gcc gcc-c++ cups-devel alsa-lib-devel libX* zip unzip glibc-static</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备 bootjdk</p>
<ul>
<li>即下载一个正常使用的 jdk 版本, 要与编译的 openjdk 版本相同</li>
</ul>
</li>
<li><p>测试安装环境是否完善</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下操作在解压的openjdk目录下操作</span></span><br><span class="line">make sanity</span><br><span class="line"><span class="comment"># 有一个 waring</span></span><br><span class="line">[WARNING]: LANG has been <span class="built_in">set</span> to zh_CN.UTF-8, this can cause build failures.</span><br><span class="line">         Try setting LANG to <span class="string">'C'</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法</span></span><br><span class="line"><span class="built_in">export</span> LANG=C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新执行</span></span><br><span class="line">make sanity</span><br><span class="line"><span class="comment"># 看到只有</span></span><br><span class="line">Sanity check passed.</span><br><span class="line"><span class="comment"># 说明环境准备好了</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<ul>
<li><p>编写启动脚本</p>
<ul>
<li>还是在上文解压的 openjdk 目录下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim compile.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 语言选项, 这个必须设置, 否则编译好后会出现一个HashTable的NPE错</span></span><br><span class="line"><span class="built_in">export</span> LANG=C</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootstrap JDK的安装路径. 必须设置.  </span></span><br><span class="line"><span class="comment"># export ALT_BOOTDIR=/opt/jdk1.8.0_221</span></span><br><span class="line"><span class="built_in">export</span> ALT_BOOTDIR=/opt/jdk1.7.0_81</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许自动下载依赖</span></span><br><span class="line"><span class="built_in">export</span> ALLOW_DOWNLOADS=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行编译的线程数, 设置为和CPU内核数量一致即可</span></span><br><span class="line"><span class="built_in">export</span> HOTSPOT_BUILD_JOBS=4</span><br><span class="line"><span class="built_in">export</span> ALT_PARALLEL_COMPILE_JOBS=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较本次build出来的映像与先前版本的差异. 这个对我们来说没有意义, 必须设置为false，否则sanity检查会报缺少先前版本JDK的映像. 如果有设置dev或者DEV_ONLY=true的话这个不显式设置也行.  </span></span><br><span class="line"><span class="built_in">export</span> SKIP_COMPARE_IMAGES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用预编译头文件, 不加这个编译会更慢一些</span></span><br><span class="line"><span class="built_in">export</span> USE_PRECOMPILED_HEADER=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要编译的内容</span></span><br><span class="line"><span class="built_in">export</span> BUILD_LANGTOOLS=<span class="literal">true</span> </span><br><span class="line"><span class="comment"># export BUILD_JAXP=false</span></span><br><span class="line"><span class="comment"># export BUILD_JAXWS=false </span></span><br><span class="line"><span class="comment"># export BUILD_CORBA=false</span></span><br><span class="line"><span class="built_in">export</span> BUILD_HOTSPOT=<span class="literal">true</span> </span><br><span class="line"><span class="built_in">export</span> BUILD_JDK=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要编译的版本</span></span><br><span class="line"><span class="built_in">export</span> SKIP_DEBUG_BUILD=<span class="literal">false</span></span><br><span class="line"><span class="built_in">export</span> SKIP_FASTDEBUG_BUILD=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> DEBUG_NAME=debug</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把它设置为false可以避开javaws和浏览器Java插件之类的部分的build。 </span></span><br><span class="line">BUILD_DEPLOY=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把它设置为false就不会build出安装包. 因为安装包里有些奇怪的依赖, 但即便不build出它也已经能得到完整的JDK映像, 所以还是别build它好了. </span></span><br><span class="line">BUILD_INSTALL=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> COMPILER_WARNINGS_FATAL=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译结果存放的路径</span></span><br><span class="line"><span class="comment"># export ALT_OUTPUTDIR=/tmp/server/jdk1.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两个环境变量必须去掉, 不然会有很诡异的事情发生(我没有具体查过这些“”诡异的事情”，Makefile脚本检查到有这2个变量就会提示警告“)</span></span><br><span class="line"><span class="built_in">unset</span> JAVA_HOME</span><br><span class="line"><span class="built_in">unset</span> CLASSPATH</span><br><span class="line"></span><br><span class="line">make 2&gt;&amp;1 | tee <span class="variable">$ALT_OUTPUTDIR</span>/build.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># =======================end compile==================</span></span><br><span class="line"></span><br><span class="line">chmod +x compile.sh</span><br><span class="line">./compile.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一切顺利的话, 会出现如下结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;Finished making images @ Mon May 25 15:56:48 CST 2020 ...</span><br><span class="line">make[2]: Leaving directory `/opt/openjdk/jdk/make<span class="string">'</span></span><br><span class="line"><span class="string">########################################################################</span></span><br><span class="line"><span class="string">##### Leaving jdk for target(s) sanity all docs images             #####</span></span><br><span class="line"><span class="string">########################################################################</span></span><br><span class="line"><span class="string">##### Build time 00:10:07 jdk for target(s) sanity all docs images #####</span></span><br><span class="line"><span class="string">########################################################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#-- Build times ----------</span></span><br><span class="line"><span class="string">Target all_product_build</span></span><br><span class="line"><span class="string">Start 2020-05-25 15:46:00</span></span><br><span class="line"><span class="string">End   2020-05-25 15:56:48</span></span><br><span class="line"><span class="string">00:00:16 corba</span></span><br><span class="line"><span class="string">00:00:15 hotspot</span></span><br><span class="line"><span class="string">00:00:03 jaxp</span></span><br><span class="line"><span class="string">00:00:04 jaxws</span></span><br><span class="line"><span class="string">00:10:07 jdk</span></span><br><span class="line"><span class="string">00:00:03 langtools</span></span><br><span class="line"><span class="string">00:10:48 TOTAL</span></span><br><span class="line"><span class="string">-------------------------</span></span><br><span class="line"><span class="string">make[1]: Leaving directory `/opt/openjdk'</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="编译完成后的测试"><a href="#编译完成后的测试" class="headerlink" title="编译完成后的测试"></a>编译完成后的测试</h3><ul>
<li><p>还是在 openjdk 目录下操作</p>
<ul>
<li>验证编译成功</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/linux-amd64/j2sdk-image/bin</span><br><span class="line"></span><br><span class="line">[root@jvm bin]<span class="comment"># ./java -version</span></span><br><span class="line">openjdk version <span class="string">"1.7.0-internal"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.7.0-internal-root_2020_05_25_15_25-b00)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将之前安装 ant 时安装的 openjdk 卸载掉 (可选)</p>
</li>
<li><p>将 build/linux-amd64/j2sdk-image 放在 JAVA_HOME 下, 配置好环境变量后, 即可正常使用自己编译的 jdk (可选)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@jvm bin]<span class="comment"># source /etc/profile</span></span><br><span class="line">[root@jvm bin]<span class="comment"># java -version</span></span><br><span class="line">openjdk version <span class="string">"1.7.0-internal"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.7.0-internal-root_2020_05_25_15_25-b00)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="编译中出现的错误"><a href="#编译中出现的错误" class="headerlink" title="编译中出现的错误"></a>编译中出现的错误</h3><p>大部分错误的导致原因都是由于缺少相应的依赖, 但是本文在开始已经下载好了所需要的依赖, 所以出现的错误不多, 如果有出现其他错误的, 可以参考文章结束部分的参考资料</p>
<h4 id="build-bootstrap-javac"><a href="#build-bootstrap-javac" class="headerlink" title="build-bootstrap-javac"></a>build-bootstrap-javac</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">build-bootstrap-javac:</span><br><span class="line">    [mkdir] Created dir: /opt/openjdk/build/linux-amd64/langtools/build/bootstrap/gensrc</span><br><span class="line">    [mkdir] Created dir: /opt/openjdk/build/linux-amd64/langtools/build/bootstrap/classes</span><br><span class="line"> [pcompile] Generating 7 resource files to /opt/openjdk/build/linux-amd64/langtools/build/bootstrap/gensrc</span><br><span class="line">     [copy] Copying 1 file to /opt/openjdk/build/linux-amd64/langtools/build/bootstrap/gensrc</span><br><span class="line"> [pcompile] Generating 1 resource files to /opt/openjdk/build/linux-amd64/langtools/build/bootstrap/gensrc</span><br><span class="line">    [javac] Compiling 298 <span class="built_in">source</span> files to /opt/openjdk/build/linux-amd64/langtools/build/bootstrap/classes</span><br><span class="line">    [javac] /opt/openjdk/langtools/src/share/classes/com/sun/tools/javac/comp/Resolve.java:2182: warning: [overrides] Class Resolve.InapplicableSymbolsError.Candidate overrides equals, but neither it nor any superclass overrides hashCode method</span><br><span class="line">    [javac]         private class Candidate &#123;</span><br><span class="line">    [javac]                 ^</span><br><span class="line">    [javac] error: warnings found and -Werror specified</span><br><span class="line">    [javac] 1 error</span><br><span class="line">    [javac] 1 warning</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br><span class="line">/opt/openjdk/langtools/make/build.xml:452: The following error occurred <span class="keyword">while</span> executing this line:</span><br><span class="line">/opt/openjdk/langtools/make/build.xml:795: Compile failed; see the compiler error output <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<ul>
<li>解决办法:<ul>
<li>之前使用的是 jdk 1.8 查阅资料发现, 是版本的问题, 换成 jdk1.7 即可</li>
<li><a href="https://download.oracle.com/otn/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz" target="_blank" rel="noopener">jdk1.7下载链接</a></li>
</ul>
</li>
</ul>
<h4 id="Error-time-is-more-than-10-years-from-present-1136059200000"><a href="#Error-time-is-more-than-10-years-from-present-1136059200000" class="headerlink" title="Error: time is more than 10 years from present: 1136059200000"></a>Error: time is more than 10 years from present: 1136059200000</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Error: time is more than 10 years from present: 1136059200000</span><br><span class="line">java.lang.RuntimeException: time is more than 10 years from present: 1136059200000</span><br><span class="line">at build.tools.generatecurrencydata.GenerateCurrencyData.makeSpecialCaseEntry(GenerateCurrencyData.java:285)</span><br><span class="line">at build.tools.generatecurrencydata.GenerateCurrencyData.buildMainAndSpecialCaseTables(GenerateCurrencyData.java:225)</span><br><span class="line">at build.tools.generatecurrencydata.GenerateCurrencyData.main(GenerateCurrencyData.java:154)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件  在 openjdk 下</span></span><br><span class="line">vi openjdk/jdk/src/share/classes/java/util/CurrencyData.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改108行</span></span><br><span class="line">AZ=AZM;2009-12-31-20-00-00;AZN</span><br><span class="line"><span class="comment"># 修改381行</span></span><br><span class="line">MZ=MZM;2009-06-30-22-00-00;MZN</span><br><span class="line"><span class="comment"># 修改443行</span></span><br><span class="line">RO=ROL;2009-06-30-21-00-00;RON</span><br><span class="line"><span class="comment"># 修改535行</span></span><br><span class="line">TR=TRL;2009-12-31-22-00-00;TRY</span><br><span class="line"><span class="comment"># 修改561行</span></span><br><span class="line">VE=VEB;2009-01-01-04-00-00;VEF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改年份至今小于 10 年 :)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机</a></p>
</li>
<li><p><a href="https://axboy.github.io/java/2018/12/21/openjdk7-centos/" target="_blank" rel="noopener">CentOS7下编译OpenJDK</a> – 更多的错误处理可以看这篇文章</p>
</li>
</ul>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器软件安装实录</title>
    <url>/posts/b5b62e3d.html</url>
    <content><![CDATA[<blockquote>
<p>由于最近经常配置服务器, 每次总是东拼西凑, 装完就忘, 说不上有什么技术含量,但是就是比较费时间, 刚好我一直关注的<code>CodeSheep</code>羊哥推出了一篇服务器安装文章, 我就顺水推舟, 顺便记录自己的安装过程. 这样以后在安装时就很省时间了</p>
<p>本文所有用到的安装包, 都已经放在尾部链接了, 有需要自取</p>
<p>注: </p>
<p>  本文是在 centos 7.8 下进行安装的</p>
<p>  以下操作均在 root 用户执行, 省略了 sudo</p>
</blockquote>
<h3 id="配置-Linux"><a href="#配置-Linux" class="headerlink" title="配置 Linux"></a>配置 Linux</h3><h4 id="查看-ip-地址-使用-Xshell-工具连接"><a href="#查看-ip-地址-使用-Xshell-工具连接" class="headerlink" title="查看 ip 地址, 使用 Xshell 工具连接"></a>查看 ip 地址, 使用 Xshell 工具连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker001 ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:36:25:d0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.150.129/24 brd 192.168.150.255 scope global noprefixroute dynamic ens33</span><br><span class="line">       valid_lft 1646sec preferred_lft 1646sec</span><br><span class="line">    inet6 fd15:4ba5:5a2b:1008:d3c3:20d9:3634:da84/64 scope global noprefixroute dynamic </span><br><span class="line">       valid_lft 86385sec preferred_lft 14385sec</span><br><span class="line">    inet6 fe80::484c:a2cf:4ef5:72e6/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="修改-ip-配置-配置DHCP与DNS等信息"><a href="#修改-ip-配置-配置DHCP与DNS等信息" class="headerlink" title="修改 ip 配置, 配置DHCP与DNS等信息"></a>修改 ip 配置, 配置DHCP与DNS等信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 固定ip</span></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=ip地址</span><br><span class="line">GATEWAY=网关</span><br><span class="line">DNS1=DNS</span><br><span class="line">IPV6_PRIVACY=no</span><br></pre></td></tr></table></figure>

<h4 id="关闭-SELINUX"><a href="#关闭-SELINUX" class="headerlink" title="关闭 SELINUX"></a>关闭 SELINUX</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line">vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<h4 id="可以下载一些小工具"><a href="#可以下载一些小工具" class="headerlink" title="可以下载一些小工具"></a>可以下载一些小工具</h4><ul>
<li><p><code>ifconfig , locate, lsof</code></p>
<p><code>yum -y install net-tools mlocate lsof</code></p>
<p><code>locate</code>安装后, 第一次使用还需要执行<code>updatedb</code> 建立索引</p>
<p><code>lsof -i:端口号</code> 查看端口占用</p>
</li>
</ul>
<h4 id="修改一下vim配置"><a href="#修改一下vim配置" class="headerlink" title="修改一下vim配置"></a>修改一下vim配置</h4><ul>
<li><p>要先更新一下 vim, 如果是最小安装的话, 有些配置不生效</p>
<p><code>yum install vim</code></p>
<p>参考: <a href="https://joemendezckh.github.io/posts/687ddbf0.html">vim配置</a></p>
</li>
</ul>
<h4 id="切换yum源并更新"><a href="#切换yum源并更新" class="headerlink" title="切换yum源并更新"></a>切换yum源并更新</h4><ol>
<li><p>首先备份本身的yum源</p>
<p><code>cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p>
</li>
<li><p>进入yum源的目录, 下载阿里云的yum源</p>
<p><code>cd /etc/yum.repos.d/</code></p>
<p><code>wget http://mirrors.aliyun.com/repo/Centos-7.repo</code></p>
<p>如果提示没有<code>wget</code>工具, 则<code>yum install wget</code></p>
</li>
<li><p>用阿里云的源替换Base</p>
<p><code>mv Centos-7.repo CentOS-Base.repo</code></p>
</li>
<li><p>重新清除并生成缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除旧的kernel (不必须)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前核心</span></span><br><span class="line">[root@docker001 ~]<span class="comment"># uname -a</span></span><br><span class="line">Linux docker001 3.10.0-1127.8.2.el7.x86_64 <span class="comment">#1 SMP Tue May 12 16:57:42 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"><span class="comment"># 查询所有核心</span></span><br><span class="line">[root@docker001 ~]<span class="comment"># rpm -qa|grep kernel</span></span><br><span class="line">kernel-headers-3.10.0-1127.8.2.el7.x86_64</span><br><span class="line">kernel-3.10.0-1127.8.2.el7.x86_64</span><br><span class="line">kernel-3.10.0-957.el7.x86_64</span><br><span class="line">kernel-tools-libs-3.10.0-1127.8.2.el7.x86_64</span><br><span class="line">kernel-tools-3.10.0-1127.8.2.el7.x86_64</span><br><span class="line"><span class="comment"># 卸载不要的</span></span><br><span class="line">[root@docker001 ~]<span class="comment"># yum remove kernel-3.10.0-957.el7.x86_64</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><ul>
<li><p>该服务器为自学使用, 为方便使用, 关闭防火墙, 否则每次要开放相应的端口, 比较繁琐</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 防火墙添加端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 关闭开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.jianshu.com/p/411274f96492" target="_blank" rel="noopener">firewall-cmd命令简单使用</a></li>
</ul>
</li>
</ul>
<h3 id="安装-JDK-1-8"><a href="#安装-JDK-1-8" class="headerlink" title="安装 JDK-1.8"></a>安装 JDK-1.8</h3><h4 id="准备工作-卸载openjdk-解压"><a href="#准备工作-卸载openjdk-解压" class="headerlink" title="准备工作: 卸载openjdk, 解压"></a>准备工作: 卸载openjdk, 解压</h4><ul>
<li><p>安装包<code>jdk-8u251-linux-x64.tar.gz</code></p>
</li>
<li><p>首先卸载已安装的 <code>openjdk</code>(如果有)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载java开头的, javapackages- 不算</span></span><br><span class="line">yum remove -y javaxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>/usr/local</code>下创建目录, 并将压缩包解压至此</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/java</span><br><span class="line">tar -zxvf jdk-8u251-linux-x64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录得到一个新的目录 /usr/<span class="built_in">local</span>/java/jdk1.8.0_251</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><ul>
<li><p>在<code>/etc/profile</code>中配置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_251 # 改为你自己的路径</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">JAVA_BIN=$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">export PATH JAVA_HOME CLASSPATH JRE_HOME JAVA_BIN</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活环境变量, 让改动生效</p>
<p><code>source /etc/profile</code></p>
</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker001 ~]# java -version</span><br><span class="line">java version "1.8.0_251"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_251-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)</span><br><span class="line"></span><br><span class="line">[root@docker001 ~]# javac</span><br><span class="line">Usage: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">where possible options include:</span><br><span class="line">  -g                         Generate all debugging info</span><br><span class="line">  -g:none                    Generate no debugging info</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     Generate only some debugging info</span><br><span class="line">  -nowarn                    Generate no warnings</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><h4 id="准备工作-安装依赖与解压"><a href="#准备工作-安装依赖与解压" class="headerlink" title="准备工作: 安装依赖与解压"></a>准备工作: 安装依赖与解压</h4><ul>
<li><p>通过源码编译安装</p>
<p>在官网下载需要的包</p>
<p><a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">官网下载链接</a></p>
<p>解压 <code>tar -zxvf v2.26.2.tar.gz</code></p>
</li>
<li><p>提前安装可能会用到的依赖</p>
<p><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc-c++ perl-ExtUtils-MakeMaker autoconf automake libtool</code> </p>
</li>
</ul>
<h4 id="编译安装并配置环境变量"><a href="#编译安装并配置环境变量" class="headerlink" title="编译安装并配置环境变量"></a>编译安装并配置环境变量</h4><ul>
<li><p>进入对应目录, 执⾏配置、编译、安装命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker001 git-2.26.2]#cd git-2.26.2/</span><br><span class="line">[root@docker001 git-2.26.2]# make configure</span><br><span class="line">[root@docker001 git-2.26.2]# ./configure --prefix=/usr/local/git</span><br><span class="line">[root@docker001 git-2.26.2]# make profix=/usr/local/git</span><br><span class="line">[root@docker001 git-2.26.2]# make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 Git 加入环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">export GIT_HOME=/usr/local/git</span><br><span class="line">export PATH=$PATH:$GIT_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后激活 <code>source /etc/profile</code></p>
</li>
</ul>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker001 git-2.26.2]# git --version</span><br><span class="line">git version 2.26.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是 1.8.3 版本的, 则是系统自带的, 可以手动卸载</span></span><br><span class="line">yum list git</span><br><span class="line">yum remove 查出来的git信息</span><br></pre></td></tr></table></figure>

<h3 id="安装-Maven-项目管理工具"><a href="#安装-Maven-项目管理工具" class="headerlink" title="安装 Maven 项目管理工具"></a>安装 Maven 项目管理工具</h3><h4 id="安装前的准备工作-解压"><a href="#安装前的准备工作-解压" class="headerlink" title="安装前的准备工作: 解压"></a>安装前的准备工作: 解压</h4><ul>
<li>下载<code>apache-maven-3.6.3-bin.tar.gz</code>安装包, 放在/opt目录下</li>
<li>进行解压 <code>tar -zxvf apache-maven-3.6.3-bin.tar.gz</code></li>
<li>改名 <code>mv apache-maven-3.6.3-bin/ maven-3.6.3</code></li>
</ul>
<h4 id="配置阿里云镜像-环境变量"><a href="#配置阿里云镜像-环境变量" class="headerlink" title="配置阿里云镜像, 环境变量"></a>配置阿里云镜像, 环境变量</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改 /opt/maven-3.6.3/conf/settings.xml 文件 --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 在 mirrors 标签中添加下面标签即可 --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置环境变量并激活文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">export MAVEN_HOME=/opt/maven/apache-maven-3.6.3</span><br><span class="line">export PATH=$MAVEN_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker001 git-2.26.2]# mvn -v</span><br><span class="line">Apache Maven 3.6.3</span><br><span class="line">Maven home: /opt/maven-3.6.3</span><br><span class="line">Java version: 1.8.0_251, vendor: Oracle Corporation, runtime: /usr/local/java/jdk1.8.0_251/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: "linux", version: "3.10.0-957.el7.x86_64", arch: "amd64", family: "unix"</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="安装-Node-环境"><a href="#安装-Node-环境" class="headerlink" title="安装 Node 环境"></a>安装 Node 环境</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>下载好<code>node-v12.16.3-linux-x64.tar.xz</code>安装包,  放在<code>/opt</code>目录下</p>
</li>
<li><p>创建<code>/usr/local/node</code>目录, 在该目录执行下面命令, 解压下载好的安装包</p>
<p><code>tar -xJvf /opt/node-v12.16.3-linux-x64.tar.xz -C ./</code></p>
<p>解压后, 会出现<code>/usr/local/node/node-v12.16.3-linux-x64</code>目录</p>
</li>
</ul>
<h4 id="配置-NODE-环境变量"><a href="#配置-NODE-环境变量" class="headerlink" title="配置 NODE 环境变量"></a>配置 NODE 环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 ~/.bash_profile 文件末尾添加如下信息, 并重新激活文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Nodejs</span></span><br><span class="line">export PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATH</span><br><span class="line"></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<h4 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br><span class="line"></span><br><span class="line">[root@docker001 node]# node -v</span><br><span class="line">v12.16.3</span><br><span class="line">[root@docker001 node]# npm version</span><br><span class="line">&#123;</span><br><span class="line">  npm: '6.14.4',</span><br><span class="line">  ares: '1.16.0',</span><br><span class="line">  brotli: '1.0.7',</span><br><span class="line">  cldr: '36.0',</span><br><span class="line">  http_parser: '2.9.3',</span><br><span class="line">  icu: '65.1',</span><br><span class="line">  llhttp: '2.0.4',</span><br><span class="line">  modules: '72',</span><br><span class="line">  napi: '5',</span><br><span class="line">  nghttp2: '1.40.0',</span><br><span class="line">  node: '12.16.3',</span><br><span class="line">  openssl: '1.1.1g',</span><br><span class="line">  tz: '2019c',</span><br><span class="line">  unicode: '12.1',</span><br><span class="line">  uv: '1.34.2',</span><br><span class="line">  v8: '7.8.279.23-node.35',</span><br><span class="line">  zlib: '1.2.11'</span><br><span class="line">&#125;</span><br><span class="line">[root@docker001 node]# npx -v</span><br><span class="line">6.14.4</span><br></pre></td></tr></table></figure>



<h3 id="安装-Python-3"><a href="#安装-Python-3" class="headerlink" title="安装 Python 3"></a>安装 Python 3</h3><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>系统自带了<code>python2.7.5</code>, 可通过<code>python -V</code>查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker001 node]<span class="comment"># python -V</span></span><br><span class="line">Python 2.7.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装一个 python3, 与python2共存</p>
<ul>
<li><p>下载安装包<code>Python-3.8.3.tgz</code>, 放在 <code>/opt</code>目录下</p>
</li>
<li><p>执行命令解压 <code>tar -zxvf Python-3.8.2.tgz</code></p>
<p>得到 <code>/opt/Python-3.8.3</code>目录</p>
</li>
</ul>
</li>
<li><p>安装需要的依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="编译安装-python-并添加软链接"><a href="#编译安装-python-并添加软链接" class="headerlink" title="编译安装 python, 并添加软链接"></a>编译安装 python, 并添加软链接</h4><ul>
<li><p>指定安装目录为 <code>/usr/local/python3</code>, 可以根据自己的需要指定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Python-3.8.3/</span><br><span class="line">./configure prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待安装完毕, 生成 <code>/usr/local/python3</code>目录</p>
</li>
<li><p>添加软链接, 方便后续使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br><span class="line"></span><br><span class="line">[root@docker001 node]<span class="comment"># pip3 -V</span></span><br><span class="line">pip 19.2.3 from /usr/<span class="built_in">local</span>/python3/lib/python3.8/site-packages/pip (python 3.8)</span><br><span class="line">[root@docker001 node]<span class="comment"># python3 -V</span></span><br><span class="line">Python 3.8.3</span><br></pre></td></tr></table></figure>

<h4 id="切换pip源为阿里云源"><a href="#切换pip源为阿里云源" class="headerlink" title="切换pip源为阿里云源"></a>切换pip源为阿里云源</h4><ul>
<li><p>创建配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker001 ~]<span class="comment"># mkdir -p ~/.pip</span></span><br><span class="line">[root@docker001 ~]<span class="comment"># vi  ~/.pip/pip.conf</span></span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">timeout = 6000</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">trusted-host = mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker001 .pip]<span class="comment"># pip3 install --upgrade pip</span></span><br><span class="line">Looking <span class="keyword">in</span> indexes: https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><ul>
<li>完全按官网的步骤来就可以, 唯一需要改动的就是 修改 repo 源和配置阿里云加速</li>
</ul>
<h4 id="申请阿里云的容器镜像服务"><a href="#申请阿里云的容器镜像服务" class="headerlink" title="申请阿里云的容器镜像服务"></a>申请阿里云的容器镜像服务</h4><ul>
<li><p>申请阿里云的容器镜像服务(免费)</p>
<ul>
<li><p><a href="https://cr.console.aliyun.com/cn-shanghai/instances/mirrors" target="_blank" rel="noopener">容器镜像服务</a></p>
<p><img src="https://i.loli.net/2020/05/24/lfxOBDA7XgZQSeJ.png" alt="image-20200524102808707.png"></p>
</li>
</ul>
</li>
</ul>
<h4 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h4><p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">Docker官网教程</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卸载旧的docker, 安装yum-utils</span></span><br><span class="line">yum remove docker docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine                  </span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加阿里云的repo源</span></span><br><span class="line">yum-config-manager --add-repo \</span><br><span class="line">     http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># 生成缓存</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置阿里云镜像加速, 以下部分为阿里云的镜像仓库</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"你自己的地址"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证结果</span></span><br><span class="line">[root@docker001 node]<span class="comment"># docker run hello-world</span></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><h4 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>下载安装包<code>mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz</code>, 放在 <code>/opt</code>目录下</p>
</li>
<li><p>卸载系统自带的<code>Mariadb</code>(如果有)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum remove $(rpm -qa|grep mariadb)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压 MySQL到 <code>/usr/local</code>, 并重命名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf /opt/mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">mv mysql-5.7.30-linux-glibc2.12-x86_64 mysql</span><br><span class="line"><span class="comment"># 创建 data 目录, 存放mysql数据, 根据自己需要指定</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建mysql用户和用户组, 并修改从属关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql</span><br><span class="line"></span><br><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>mysql</code>配置文件<code>my.cnf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单配置如下, 更多详细的自己根据需要配置</span></span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="comment">#设置3306端口</span></span><br><span class="line">port = 3306</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line">datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集, 指定为utf-8</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 驼峰命名与下划线</span></span><br><span class="line">lower_case_table_names=1</span><br><span class="line">max_allowed_packet=16M</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 <code>/var/lib/mysql</code> ⽬录，并修改权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /var/lib/mysql</span><br><span class="line">chmod 777 /var/lib/mysql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="正式开始安装Mysql"><a href="#正式开始安装Mysql" class="headerlink" title="正式开始安装Mysql"></a>正式开始安装Mysql</h4><ul>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql</span><br><span class="line">./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql \ </span><br><span class="line">--datadir=/usr/local/mysql/mysqlData</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完成后会在终端打印出初始密码</span></span><br><span class="line">[Note] A temporary password is generated for root@docker001: UDF*s23_13sc</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置启动脚本, 在 <code>/usr/local/mysql</code>目录下执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker001 mysql]# cp ./support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 /etc/init.d/mysqld 的内容为正确路径</span></span><br><span class="line">vi /etc/init.d/mysqld</span><br><span class="line"></span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加执行权限</span></span><br><span class="line">chmod +x /etc/init.d/mysqld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 mysqld 服务加入到系统服务, 并检查是否生效</span></span><br><span class="line">chkconfig --add mysqld</span><br><span class="line"></span><br><span class="line">chkconfig --list mysqld</span><br><span class="line"></span><br><span class="line">mysqld  	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这就表示mysqld生效了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以用 service mysqld start 启动服务</span></span><br><span class="line">[root@docker001 ~]# service mysqld start</span><br><span class="line">Starting MySQL.</span><br><span class="line"></span><br><span class="line">SUCCESS!</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置msql环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="第一次启动MySQL"><a href="#第一次启动MySQL" class="headerlink" title="第一次启动MySQL"></a>第一次启动MySQL</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u root -p <span class="comment"># 使用上面安装后打印出的密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt;alter user user() identified by <span class="string">"密码"</span>;</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line"><span class="comment"># 设置主机远程登录</span></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> user.Host=<span class="string">'%'</span> <span class="built_in">where</span> user.User=<span class="string">'root'</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时就可以正常使用了</li>
</ul>
<h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><h4 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>下载 <code>redis-5.0.8.tar.gz</code>安装包, 放在<code>/usr/local/redis</code> 目录下</p>
<p><code>tar -zxvf redis-5.0.8.tar.gz</code></p>
</li>
<li><p>会解压出一个 <code>/usr/local/redis/redis-5.0.8</code>目录</p>
</li>
</ul>
<h4 id="编译安装与设置开机自启"><a href="#编译安装与设置开机自启" class="headerlink" title="编译安装与设置开机自启"></a>编译安装与设置开机自启</h4><ul>
<li><p>编译安装</p>
<ul>
<li>执行前确保安装了<code>gcc</code>等环境, 因为在安装<code>python3</code>时已经安装了依赖,所以在此可以直接编译安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 /usr/<span class="built_in">local</span>/redis/redis-5.0.8 目录下执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>设为后台服务, 并自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 /usr/<span class="built_in">local</span>/redis/redis-5.0.8 目录下执行</span></span><br><span class="line">cp redis.conf /etc/redis/6379.conf</span><br><span class="line"></span><br><span class="line">vi /etc/redis/6379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改下面几项内容</span></span><br><span class="line">daemonize no =&gt; daemonize yes</span><br><span class="line">bind 127.0.0.1 =&gt; bind 0.0.0.0</span><br><span class="line">requirepass 你的密码</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 /usr/<span class="built_in">local</span>/bin 目录下执行, 启动服务端</span></span><br><span class="line">./redis-server /etc/redis/6379.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后ps查看redis</span></span><br><span class="line">[root@docker001 bin]# ps -ef |grep redis</span><br><span class="line">root       7373      1  0 23:09 ?        00:00:01 *:6379</span><br><span class="line"></span><br><span class="line">[root@docker001 bin]# ./redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 你的密码</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置开机自启, 在/usr/<span class="built_in">local</span>/redis/redis-5.0.8/utils 目录下执行</span></span><br><span class="line">[root@docker001 utils]# cp redis_init_script /etc/init.d/redis_6379</span><br><span class="line">[root@docker001 utils]# vi /etc/init.d/redis_6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改对应内容为自己设置的内容</span></span><br><span class="line">REDISPORT=6379</span><br><span class="line">EXEC=/usr/local/bin/redis-server</span><br><span class="line">CLIEXEC=/usr/local/bin/redis-cli</span><br><span class="line">PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line">CONF="/etc/redis/$&#123;REDISPORT&#125;.conf"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了更快的启动, 可以在第38行 添加密码</span></span><br><span class="line">37  	echo "Stopping ..."</span><br><span class="line">38	    $CLIEXEC -p $REDISPORT -a 你的密码 shutdown  </span><br><span class="line"></span><br><span class="line">[root@docker001 init.d]# chmod +x redis_6379</span><br><span class="line">[root@docker001 init.d]# chkconfig --add redis_6379</span><br><span class="line">[root@docker001 init.d]# chkconfig redisd on </span><br><span class="line">[root@docker001 init.d]# chkconfig --list redis_6379 </span><br><span class="line">redis_6379     	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="安装-Nginx-Web服务器"><a href="#安装-Nginx-Web服务器" class="headerlink" title="安装 Nginx Web服务器"></a>安装 Nginx Web服务器</h3><h4 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>下载安装包<code>nginx-1.17.10.tar.gz</code>并放入<code>/opt</code>目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx</span><br><span class="line">tar -zxvf /opt/nginx-1.17.10.tar.gz -C ./</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压完成后会生成 <code>/usr/local/nginx/nginx-1.17.10</code>目录</p>
</li>
<li><p>安装需要的依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><ul>
<li><p>编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/nginx-1.17.10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 ssl 模块, 如果不需要的话, 可以不带参数</span></span><br><span class="line">./configure --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后, nginx启动文件位于 <code>/usr/local/nginx/sbin/nginx</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/java/nginx/conf</span><br><span class="line">vi nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单配置</span></span><br><span class="line">user root;</span><br><span class="line">error_log  logs/error.log  info;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="comment"># 第一次启动</span></span><br><span class="line">./sbin/nginx </span><br><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line">./sbin/nginx -s reload</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">./sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置开机自启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NGINX 开机自启</span></span><br><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line"><span class="comment"># 添加下面这个路径,启动路径</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx </span><br><span class="line"></span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="验证-4"><a href="#验证-4" class="headerlink" title="验证"></a>验证</h4><p>在浏览器输入服务器的ip, 可以看到 <code>welcome to nginx</code></p>
<h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><h4 id="准备工作-5"><a href="#准备工作-5" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>添加<code>repo</code>, 安装<code>erlong</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line">yum install erlang-22.3.3-1.el7.x86_64</span><br><span class="line"><span class="comment"># 如果上一句有问题了, 执行这个</span></span><br><span class="line">yum load-transaction /tmp/yum_save_tx.2020-05-14.22-21.n0cwzm.yumtx</span><br><span class="line"></span><br><span class="line">erl <span class="comment"># 查看是否成功</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>rabbitmq</code>的<code>yum</code>源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="正式安装与配置"><a href="#正式安装与配置" class="headerlink" title="正式安装与配置"></a>正式安装与配置</h4><ul>
<li><p>安装<code>rabbitmq-server-3.8.3</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install rabbitmq-server-3.8.3-1.el7.noarch</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机自启与可视化插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开服务</span></span><br><span class="line">chkconfig rabbitmq-server on</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start rabbitmq-server.service</span><br><span class="line"><span class="comment"># 开启可视化插件</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">rabbitmqctl add_user 用户名 密码</span><br><span class="line">eg: </span><br><span class="line">	rabbitmqctl add_user admin admin</span><br><span class="line"><span class="comment"># 设置管理员</span></span><br><span class="line">rabbitmqctl set_user_tags 用户名 administrator</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="验证-5"><a href="#验证-5" class="headerlink" title="验证"></a>验证</h4><p>访问: IP:15672, 可以看到RabbitMQ的界面</p>
<h3 id="安装-Tomcat-应用服务器"><a href="#安装-Tomcat-应用服务器" class="headerlink" title="安装 Tomcat 应用服务器"></a>安装 Tomcat 应用服务器</h3><h4 id="准备工作-6"><a href="#准备工作-6" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>下载安装包 <code>apache-tomcat-8.5.55.tar.gz</code>, 放在<code>/opt</code>目录</p>
</li>
<li><p>解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/tomcat</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/tomcat</span><br><span class="line">tar -zxvf /opt/apache-tomcat-8.5.55.tar.gz -C ./</span><br></pre></td></tr></table></figure>
</li>
<li><p>会生成<code>/usr/local/tomcat/apache-tomcat-8.5.55</code>目录</p>
</li>
</ul>
<h4 id="配置及设置启动脚本"><a href="#配置及设置启动脚本" class="headerlink" title="配置及设置启动脚本"></a>配置及设置启动脚本</h4><ul>
<li><p>配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/tomcat/apache-tomcat-8.5.55/conf/server.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认端口 8080 为自己指定的端口, 否则会与zookeeper冲突, 这一点是坑</span></span><br><span class="line">&lt;Connector port=<span class="string">"8000"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">            connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">            redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /usr/local/tomcat/apache-tomcat-8.5.55/bin/setclasspath.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加 Java 路径, 否则加入服务时找不到 java</span></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_251</span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_251/jre</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试启动与关闭</span></span><br><span class="line">[root@docker001 bin]# ./startup.sh </span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat/apache-tomcat-8.5.55</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat/apache-tomcat-8.5.55</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/apache-tomcat-8.5.55/temp</span><br><span class="line">Using JRE_HOME:        /usr/local/java/jdk1.8.0_251/jre</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/apache-tomcat-8.5.55/bin/bootstrap.jar:/usr/local/tomcat/apache-tomcat-8.5.55/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br><span class="line">[root@docker001 bin]# ./shutdown.sh </span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat/apache-tomcat-8.5.55</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat/apache-tomcat-8.5.55</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/apache-tomcat-8.5.55/temp</span><br><span class="line">Using JRE_HOME:        /usr/local/java/jdk1.8.0_251/jre</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/apache-tomcat-8.5.55/bin/bootstrap.jar:/usr/local/tomcat/apache-tomcat-8.5.55/bin/tomcat-juli.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机自启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/rc.d/init.d/</span><br><span class="line">vi tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#chkconfig:- 20 90</span></span><br><span class="line"><span class="comment">#description:tomcat</span></span><br><span class="line"><span class="comment">#processname:tomcat</span></span><br><span class="line">TOMCAT_HOME=/usr/<span class="built_in">local</span>/tomcat/apache-tomcat-8.5.55<span class="comment"># 你的tomcat路径</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	start) su root <span class="variable">$TOMCAT_HOME</span>/bin/startup.sh;;</span><br><span class="line">	stop) su root <span class="variable">$TOMCAT_HOME</span>/bin/shutdown.sh;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">"require start|stop"</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">chmod +x tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时可以执行下面的命令进行启动和关闭</span></span><br><span class="line">service tomcat start</span><br><span class="line">service tomcat stop</span><br><span class="line"><span class="comment"># 加入系统服务</span></span><br><span class="line">chkconfig --add tomcat</span><br><span class="line">chkconfig tomcat on</span><br><span class="line">chkchkconfig --list tomcat</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="安装-Zookeeper"><a href="#安装-Zookeeper" class="headerlink" title="安装 Zookeeper"></a>安装 Zookeeper</h3><h4 id="准备工作-7"><a href="#准备工作-7" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>下载安装包<code>apache-zookeeper-3.6.1-bin.tar.gz</code>放在<code>/opt</code>下</p>
</li>
<li><p>解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/zookeeper</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/zookeeper</span><br><span class="line">tar -zxvf /opt/apache-zookeeper-3.6.1-bin.tar.gz -C ./</span><br><span class="line"><span class="comment"># 会生成一个/usr/local/zookeeper/apache-zookeeper-3.6.1-bin目录</span></span><br><span class="line"><span class="comment"># 创建一个data目录</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin/data</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><ul>
<li><p>配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vi zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改dataDir为上面创建的data目录</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker001 apache-zookeeper-3.6.1-bin]<span class="comment"># ./bin/zkServer.sh start</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line"></span><br><span class="line">[root@docker001 apache-zookeeper-3.6.1-bin]<span class="comment"># ./bin/zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$ZOOKEEPER_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机自启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">vi zookeeper</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#chkconfig:- 20 90</span></span><br><span class="line"><span class="comment">#description:zookeeper</span></span><br><span class="line"><span class="comment">#processname:zookeeper</span></span><br><span class="line">ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.6.1-bin <span class="comment"># 此处根据你的实际情况更换对应</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_251 <span class="comment"># 此处根据你的实际情况更换对应</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	start) su root <span class="variable">$ZOOKEEPER_HOME</span>/bin/zkServer.sh start;;</span><br><span class="line">	stop) su root <span class="variable">$ZOOKEEPER_HOME</span>/bin/zkServer.sh stop;;</span><br><span class="line">	status) su root <span class="variable">$ZOOKEEPER_HOME</span>/bin/zkServer.sh status;;</span><br><span class="line">	restart) su root <span class="variable">$ZOOKEEPER_HOME</span>/bin/zkServer.sh restart;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">"require start|stop|status|restart"</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">chmod +x zookeeper</span><br><span class="line"><span class="comment"># 加入开机启动</span></span><br><span class="line">chkconfig --add zookeeper</span><br><span class="line">chkconfig zookeeper on</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="安装-Thefuck-工具"><a href="#安装-Thefuck-工具" class="headerlink" title="安装 Thefuck 工具"></a>安装 Thefuck 工具</h3><ul>
<li>安装这个工具纯属娱乐 : )  <a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">thefuck</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release python3-devel</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line"></span><br><span class="line">pip3 install thefuck </span><br><span class="line"></span><br><span class="line">Successfully installed colorama-0.4.3 decorator-4.4.2 psutil-5.7.0 pyte-0.8.0 six-1.15.0 thefuck-3.30 wcwidth-0.1.9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 .bashrc 配置文件</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(thefuck --alias fuck)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>



<h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247486646&idx=1&sn=2e4f946f2ac7889991e872d1c885eb44&chksm=fddeda72caa953643fd8d2af385e1ad973b7b4ebe59585fb23072b851fe4a5c0bfb2442573ae&scene=0&xtrack=1&key=cf6ab1fd6f95a270dfefa6b2f3f4eb1fb6e8176dd7c366fa5194889c8b9a9e882d5e0bd45e20e943929ed45b875cc1533d20ba028783a0ff9691e1481387f535a7993f1a75d53d1a001e147bd22b6562&ascene=1&uin=MTI0NDQ3NzIwNw%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=A9pb1wEuSza6ydZuqGd3jb0%3D&pass_ticket=TOgG0xj3EwqhuL%2F3G1yPG42n1a7FIgWBlXzGD%2B0tdnR7hQwiMNVDdaeetDZ7BYN5" target="_blank" rel="noopener"><strong>CodeSheep</strong>公众号</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1520882" target="_blank" rel="noopener">pip pip3 替换国内镜像源</a></p>
</li>
<li><p><a href="https://blog.csdn.net/inslow/article/details/54177191" target="_blank" rel="noopener">修改CentOS默认yum源为国内yum镜像源</a></p>
</li>
<li><p>非常感谢<code>CodeSheep</code>羊哥, 按照羊哥的手册, 对我个人而言, 大部分不用一点修改, 小的部分进行了修改, 特此记录</p>
</li>
</ul>
<blockquote>
<p>下载链接：<a href="https://pan.baidu.com/s/1t_LOlTrdVvC481j1AsS6Xw" target="_blank" rel="noopener">https://pan.baidu.com/s/1t_LOlTrdVvC481j1AsS6Xw</a><br>提取码：xti8 </p>
</blockquote>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Zookeeper 启动报错</title>
    <url>/posts/50e22a29.html</url>
    <content><![CDATA[<h3 id="Error-contacting-service-It-is-probably-not-running"><a href="#Error-contacting-service-It-is-probably-not-running" class="headerlink" title="Error contacting service. It is probably not running."></a>Error contacting service. It is probably not running.</h3><ul>
<li>记录在安装启动Zookeeper 3.6.1 时遇到的问题与解决方法</li>
</ul>
<blockquote>
<p>环境信息:</p>
<p>CentOS Linux release 7.8.2003 </p>
<p>java version “1.8.0_161”</p>
<p>apache-zookeeper-3.6.1-bin.tar.gz</p>
</blockquote>
<ul>
<li><p>安装过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf /opt/apache-zookeeper-3.6.1-bin.tar.gz -C ./</span><br><span class="line">mv apache-zookeeper-3.6.1-bin zookeeper-3.6.1</span><br><span class="line">cd zookeeper-3.6.1</span><br><span class="line">" 创建 dataDir, 在 zoo.cfg 中修改 dataDir</span><br><span class="line">mkdir data</span><br><span class="line">cd zookeeper-3.6.1/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br><span class="line">" 修改 dataDir 为上面创建的 data 目录</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>至此, 安装结束, 进行启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zookeeper-3.6.1]# ./bin/zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/zookeeper-3.6.1/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<ul>
<li>启动正常, 查看状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zookeeper-3.6.1]# ./bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/zookeeper-3.6.1/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Error contacting service. It is probably not running</span><br></pre></td></tr></table></figure>

<ul>
<li>查看状态错误, 使用 ps 命令和 netstat 命令查看2181端口均没有显示, 说明启动失败</li>
</ul>
<p>查阅相关资料后, 解释的原因有下面几种: </p>
<ol>
<li>没有创建<code>dataDir</code>目录</li>
<li>没有关闭防火墙</li>
<li>2181端口被占用</li>
<li><code>zoo.cfg</code>文件中主机名出错</li>
<li><code>myid</code>文件中的整数格式不对，或者与<code>zoo.cfg</code>中的<code>server</code>整数不对应</li>
</ol>
</li>
<li><p>经过排查上述原因, 均为解决</p>
</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p>最终发现, <strong>直接查看日志文件即可</strong></p>
<p><strong>查看位于<code>zookeeper-3.6.1/logs</code>下的<code>.out</code>文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[myid:] - ERROR [main:ZooKeeperServerMain@85] - Unable to start AdminServer, exiting abnormally                </span><br><span class="line">org.apache.zookeeper.server.admin.AdminServer$AdminServerException: Problem starting AdminServer on address 0.0.0.0, port 8080 and comm</span><br><span class="line">and URL &#x2F;commands</span><br><span class="line">    at org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:176)</span><br><span class="line">    at org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ZooKeeperServerMain.java:153)</span><br><span class="line">    at org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun(ZooKeeperServerMain.java:112)</span><br><span class="line">    at org.apache.zookeeper.server.ZooKeeperServerMain.main(ZooKeeperServerMain.java:67)</span><br><span class="line">    at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(QuorumPeerMain.java:140)</span><br><span class="line">    at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain.java:90)</span><br><span class="line">Caused by: java.io.IOException: Failed to bind to &#x2F;0.0.0.0:8080</span><br><span class="line">    at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:346)</span><br><span class="line">    at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:307)</span><br><span class="line">    at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)</span><br><span class="line">    at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:231)</span><br><span class="line">    at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)</span><br><span class="line">    at org.eclipse.jetty.server.Server.doStart(Server.java:385)</span><br><span class="line">    at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)</span><br><span class="line">    at org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:167)</span><br><span class="line">    ... 5 more</span><br><span class="line">Caused by: java.net.BindException: 地址已在使用</span><br><span class="line">    at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">    at sun.nio.ch.Net.bind(Net.java:433)</span><br><span class="line">    at sun.nio.ch.Net.bind(Net.java:425)</span><br><span class="line">    at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)</span><br><span class="line">    at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)</span><br><span class="line">    at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:342)</span><br><span class="line">    ... 12 more</span><br><span class="line">Unable to start AdminServer, exiting abnormally</span><br></pre></td></tr></table></figure>

<ul>
<li>显而易见, 是因为8080端口被占用, 解决端口占用后, 即可正常启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/zookeeper-3.6.1/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以后出现问题, 不要忙着google, 看看日志文件, 就可以解决大部分问题, 如果不行再google</p>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>记录vim配置</title>
    <url>/posts/687ddbf0.html</url>
    <content><![CDATA[<h2 id="备份自己的vim设置"><a href="#备份自己的vim设置" class="headerlink" title="备份自己的vim设置"></a>备份自己的vim设置</h2><ul>
<li><p>因为经常装完系统后, vim设置总是比较烦, 所以干脆做个备份, 一劳永逸</p>
</li>
<li><p>首先更新vim</p>
<p><code>yum install -y vim</code></p>
</li>
<li><p>编辑个人配置</p>
<ul>
<li><code>vim ~/.vimrc</code></li>
</ul>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">" 语法高亮</span><br><span class="line">syntax on</span><br><span class="line">" 设置编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8</span><br><span class="line">" 开启行号</span><br><span class="line">set number</span><br><span class="line">"  突出显示当前行</span><br><span class="line">set cul </span><br><span class="line">" 开启鼠标</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line">" 显示括号匹配</span><br><span class="line">set showmatch</span><br><span class="line">" 设置Tab长度为4空格</span><br><span class="line">set tabstop=4</span><br><span class="line">" 设置自动缩进长度为4空格</span><br><span class="line">set shiftwidth=4</span><br><span class="line">" 继承前一行的缩进方式，适用于多行注释</span><br><span class="line">set autoindent</span><br><span class="line">" 设置粘贴模式</span><br><span class="line">set paste</span><br><span class="line">" 总是显示状态栏</span><br><span class="line">set laststatus=2</span><br><span class="line">" 打开文件类型检测</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果如下</p>
<p><img src="https://i.loli.net/2020/05/22/NBvwlUGLh29qSXY.png" alt="image-20200522105126848.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云Docker新人赛记录</title>
    <url>/posts/249f9dc1.html</url>
    <content><![CDATA[<blockquote>
<p>本文主要是记录参加阿里云docker新人赛 <a href="https://tianchi.aliyun.com/competition/entrance/231759/information" target="_blank" rel="noopener">Docker练习场</a> 的过程以及自已遇到的一些坑</p>
<p>使用 java 实现 </p>
</blockquote>
<h2 id="Docker练习场"><a href="#Docker练习场" class="headerlink" title="Docker练习场"></a>Docker练习场</h2><ul>
<li>首先, 官方的帮助文档将流程介绍的已经很详细了, 在此不做赘述</li>
<li>直接从Java实现写起</li>
</ul>
<h3 id="如何实现-run-sh-调用我们的函数"><a href="#如何实现-run-sh-调用我们的函数" class="headerlink" title="如何实现 run.sh 调用我们的函数"></a>如何实现 run.sh 调用我们的函数</h3><ol>
<li>一个 web 工程, 通过 curl 发送 get 请求调用函数<ul>
<li>优点: 可以重复调用</li>
<li>缺点: 感觉有点跑题, 目的是学习docker, 不是web…</li>
</ul>
</li>
<li>直接 main 函数, 打成jar包后直接运行<ul>
<li>简单粗暴</li>
</ul>
</li>
</ol>
<p>综上: 我选择了方案 2 (中间有个小坑)</p>
<a id="more"></a>

<h3 id="新建一个-maven-工程"><a href="#新建一个-maven-工程" class="headerlink" title="新建一个 maven 工程"></a>新建一个 maven 工程</h3><ul>
<li><p>编写实现功能的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NUM_LIST = <span class="string">"/tcdata/num_list.csv"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"result.json"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    File resultFile = <span class="keyword">new</span> File(PATH);</span><br><span class="line">    File numFile = <span class="keyword">new</span> File(NUM_LIST);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resultFile.exists()) &#123;</span><br><span class="line">            resultFile.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"Q1"</span>, <span class="string">"Hello world"</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; list = FileUtils.readLines(numFile, <span class="string">"UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        list.forEach(num -&gt; integers.add(Integer.parseInt(num)));</span><br><span class="line">        <span class="keyword">int</span> sum = integers.stream().mapToInt(num -&gt; num).sum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] result = integers.stream()</span><br><span class="line">            .sorted(Comparator.comparing(Integer::intValue).reversed())</span><br><span class="line">            .mapToInt(n -&gt; n).limit(<span class="number">10</span>).toArray();</span><br><span class="line"></span><br><span class="line">        jsonObject.put(<span class="string">"Q2"</span>, sum);</span><br><span class="line">        jsonObject.put(<span class="string">"Q3"</span>, result);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(resultFile);</span><br><span class="line">        fileOutputStream.write(jsonObject.toJSONString().getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"success"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用了 2 个工具类 <code>fastjson</code> 和 <code>commons-io</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.68<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h4><ul>
<li><p>要指定 java -jar 运行的主类名, 方可执行</p>
</li>
<li><p>直接运行是可以的, 但是直接打包再在本地运行jar包的话, 会抛异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com&#x2F;alibaba&#x2F;fastjson&#x2F;JSONObject</span><br><span class="line">        at com.joe.tcdata.TaskRun.main(TaskRun.java:13)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.alibaba.fastjson.JSONObject</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">        ... 1 more</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这是因为maven在打包的过程中, 没有将  <code>fastjson</code> 和 <code>commons-io</code>打包进去</p>
</li>
<li><p>修改 pom 和 手动添加 jar 包都不生效, 最后通过 maven 插件解决</p>
<p>详细分析见: <a href="https://www.cnblogs.com/dzblog/p/6913809.html" target="_blank" rel="noopener">Maven构建可执行的jar包(包含依赖jar包)</a></p>
<p>此时就可以解决了</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 此处指定main方法入口的class --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.joe.tcdata.TaskRun<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="编写run-sh"><a href="#编写run-sh" class="headerlink" title="编写run.sh"></a>编写run.sh</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">java -jar tcdata-1.0.0.jar &gt; tcdata.log</span><br></pre></td></tr></table></figure>

<h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>            registry.cn-shanghai.aliyuncs.com/tcc-public/java:jdk_13.<span class="number">0.2</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      作者&lt;作者邮箱&gt;</span><br><span class="line"><span class="comment"># 添加当前文件夹下所有内容(包括 jar包和 run.sh) 到 container 的 / 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> 		. /</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> 	/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> 		[<span class="string">"sh"</span>, <span class="string">"run.sh"</span>]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意:</p>
<p><code>/tcdata/num_list.csv</code> 该文件在提交回答的时候, 会自动生成, 不需要我们自己编写</p>
<p>但是在build 好镜像后, 是不存在这个目录的, 所以 build 好的镜像是不能执行的</p>
<p>也就是说, 需要提前在本地测试好 jar 包没有问题, 这样提交后出现错误才是 docker 方面的问题</p>
</li>
</ul>
<h3 id="推送到自己的仓库"><a href="#推送到自己的仓库" class="headerlink" title="推送到自己的仓库"></a>推送到自己的仓库</h3><p>这一步可以看官方的指导, 很详细</p>
<h4 id="登录阿里云Docker-Registry"><a href="#登录阿里云Docker-Registry" class="headerlink" title="登录阿里云Docker Registry"></a>登录阿里云Docker Registry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username&#x3D;用户名 registry.cn-shanghai.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<h4 id="从Registry中拉取镜像"><a href="#从Registry中拉取镜像" class="headerlink" title="从Registry中拉取镜像"></a>从Registry中拉取镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull registry.cn-shanghai.aliyuncs.com&#x2F;用户名&#x2F;仓库名:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h4 id="将镜像推送到Registry"><a href="#将镜像推送到Registry" class="headerlink" title="将镜像推送到Registry"></a>将镜像推送到Registry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username&#x3D;用户名 registry.cn-shanghai.aliyuncs.com</span><br><span class="line">$ sudo docker tag [ImageId] registry.cn-shanghai.aliyuncs.com&#x2F;用户名&#x2F;仓库名:[镜像版本号]</span><br><span class="line">$ sudo docker push registry.cn-shanghai.aliyuncs.com&#x2F;用户名&#x2F;仓库名:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h3 id="提交回答"><a href="#提交回答" class="headerlink" title="提交回答"></a>提交回答</h3><ul>
<li>建议将该仓库设置为公有仓库, 这样比较省事, 不然要写用户名和密码, 可能出错</li>
</ul>
<p><img src="https://i.loli.net/2020/05/17/zemPk7FcIG3ErWg.png" alt="image-20200517130659535.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个 docker新人赛最大的作用就是熟悉整个 docker 的基本运行流程, 以及基础的知识, 只是一个起步.</p>
<p>继续努力学习!</p>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实践笔记(2)-对象的共享</title>
    <url>/posts/48123146.html</url>
    <content><![CDATA[<h2 id="2-对象的共享"><a href="#2-对象的共享" class="headerlink" title="2. 对象的共享"></a>2. 对象的共享</h2><p>我们知道同步代码块和同步方法可以保证原子性,但是还有重要的另一方面:<strong>内存可见性(Memory Visibility)</strong>, 确保当一个线程修改了对象状态后, 其他线程可以看到发生的状态变化,(即可以防止脏读)</p>
<h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1. 可见性"></a>1. 可见性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序中, 可能会持续循环下去, 因为可能看不到ready的值. 还有可能输出0, 即读线程看到了ready的值, 但是却没有看到之后写入number的值, 即”重排序(Reordering)”,如果有重排序情况, 那么就无法确定程序按照指定的顺序执行.</p>
<a id="more"></a>

<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><ol>
<li><strong>失效数据</strong><ul>
<li>类似脏读, 读取到已经失效的值, 即别的线程已经更新了该值,却还是读取到之前的值</li>
</ul>
</li>
<li><strong>非原子的64位操作</strong><ul>
<li>当线程在没有同步的情况下, 可能会读取到失效值, 但是这个值至少是之前某个线程设置的值, 而不是一个随机值.这种安全性称为最低安全性(<code>out-of-thin-airsafety</code>)</li>
<li>最低安全行适用于绝大多数变量, 但是存在例外: 非volatile的64位数值变量(double,long). JVM允许将64位的读/写操作分解为2个32位的操作, 如果对改变量的读写分别在不同的线程中, 可能会读取到某个值的高32位和另一个值的低32位, 这就导致严重的错误</li>
<li>因此在多线程中使用共享且可变的long/double类型的变量是不安全的, 要用volatile声明或锁保护.</li>
</ul>
</li>
</ol>
<ul>
<li>加锁的意义:<ol>
<li>保证原子性</li>
<li>保证内存可见性</li>
</ol>
</li>
</ul>
<h3 id="2-发布与逸出"><a href="#2-发布与逸出" class="headerlink" title="2. 发布与逸出"></a>2. 发布与逸出</h3><ul>
<li><p>发布(Publish): 使对象能够在当前作用域之外的代码中使用.<br>也就是在其他域中持有了对象的引用, 例如, 将对象的引用保存到公有的静态变量中, 以便任何类和线程都可以看到该对象</p>
</li>
<li><p>逸出(Escape): 不该被发布的对象被发布时, 就称作逸出</p>
<ul>
<li>当某个对象逸出后, 必须假设有某个类或线程可能会无用该对象, 这正是使用封装的最主要原因: 封装使得对程序的正确性进行分析变的可能, 并使得无意中破坏设计约束条件变得更难</li>
</ul>
</li>
<li><p>当发布一个对象时, 在该对象的非私有域中引用的所有对象同样会被发布. 一般来说, 如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象, 那么这些对象也都会被发布  </p>
<ul>
<li><p>假定有一个类C, 对C来说, “外部(Alien)方法”是指并不完全由C来规定的方法, 包括其它类中定义的方法以及C中可以被改写的方法(即不是私有方法(private)也不是终结方法(final)), 当把一个对象传递给某个外部方法时, 就相当于发布了这个对象</p>
<blockquote>
<p>也就是说, Javabean的属性都属于发布, 但是这是我们需要发布的, 而如果是不应该被发布的对象却被发布了, 就是逸出</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 将对象的引用保存到公有的静态变量中</span></span><br><span class="line"><span class="comment">// knownSecrets 被发布, 间接的发布了Secret对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从非私有方法中返回一个引用, 同样会发布返回的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">"AK"</span>,<span class="string">"AL"</span>...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发布一个内部的类实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 公有的构造器, 在对象没有构造成功时, 就发布了this 对象的引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//  上面的相当于: source.registerListener(this::doSomething);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventSource</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安全的对象构造过程</p>
<ul>
<li><p>不要再构造过程中使this引用逸出  </p>
<ul>
<li>在构造过程中使this逸出的常见错误:  <ul>
<li>在构造函数中启动一个线程</li>
<li>在构造函数中调用一个可改写的外部方法</li>
</ul>
</li>
</ul>
</li>
<li><p>想要避免不正确的构造过程, 可以使用私有的构造函数和公有的工厂方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"私有构造方法....."</span>);</span><br><span class="line">        listener = <span class="keyword">this</span>::doSomething;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 工厂方法,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工厂方法"</span>);</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventSource</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-线程封闭"><a href="#3-线程封闭" class="headerlink" title="3. 线程封闭"></a>3. 线程封闭</h3><p>仅在单线程内访问数据, 就不需要使用同步, 这种技术称为线程封闭(Thread Confinement), 是实现线程安全性的最简单方式之一.  </p>
<p>常见应用有: JDBC的connection对象.将每个Connection对象封闭在一个线程中.</p>
<ol>
<li><p>Ad-hoc: 维护线程封闭性的职责完全地由程序实现承担. 这种方式很脆弱,建议使用更强的栈封闭或ThreadLocal</p>
</li>
<li><p>栈封闭: 线程封闭的一种特例, 只能通过局部变量才能访问对象.<strong>局部变量的固有属性就是封闭在执行线程中</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123;</span><br><span class="line">    SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">    Animal candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// animals confined to method, don't let them escape!</span></span><br><span class="line">    animals = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a)) &#123;</span><br><span class="line">            candidate = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadLocal</p>
</li>
</ol>
<ul>
<li><p><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">ThreadLocal理解</a> 原理涉及到 <code>countDownLatch</code>  和 <code>concurrentMap</code>方面的知识, 后面再看, 先简单理解用法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDispenser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/mydatabase"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">            = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to acquire Connection, e"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-不变性"><a href="#4-不变性" class="headerlink" title="4. 不变性"></a>4. 不变性</h3><p>如果某个对象在被创建后其状态就不能被修改, 那么这个对象就称为不可变对象, 线程安全性是不可变对象的固有属性之一, 不变性是由构造函数创建的, 只要他们的状态不改变, 那么这些不变性条件就能得以维持</p>
<ul>
<li><p>不可变性不等于将对象中的所有域都声明为final类型, 即使对象中所有的域都是final类型的, 这个对象也仍然是可变的, 因为在final类型的域中可以保存对可变对象的引用</p>
</li>
<li><p>不可变对象的定义</p>
<ul>
<li>对象创建后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的(在对象的创建期间, this引用没有逸出)</li>
</ul>
</li>
<li><p>不可变对象内部仍可以使用可变对象来管理他们的状态, 如下所示</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在可变对象基础上构建的不可变类</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管Set对象是可变的, 但是在Set对象构造完成后无法对其进行修改, <code>stooges</code>是一个<code>final</code>类型的引用变量, 因此所有的对象状态都通过一个<code>final</code>域来访问, 且构造函数保证了防止其他代码的访问</p>
</li>
</ul>
<h4 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h4><p><code>final</code>类型的域是不可修改的, 但如果<code>final</code>域所引用的对象是可变的, 那么被引用的对象是可以被修改的. 在Java内存模型中, <code>final</code>域有特殊的语义, <strong>final域确保初始化过程的安全性, 从而可以不受限制地访问不可变对象, 并在共享这些对象时无需同步</strong></p>
<h4 id="使用volatile类型发布不可变对象"><a href="#使用volatile类型发布不可变对象" class="headerlink" title="使用volatile类型发布不可变对象"></a>使用volatile类型发布不可变对象</h4><ul>
<li><p>对于访问和更新多个相关变量时出现竞争条件问题, 可以通过将这些变量全部保存在一个不可变对象中来消除, 如果是一个可变的对象, 那么就需要使用锁来确保原子性. 如果是一个不可变对象, 那么当线程获得了该对象的引用后, 就不必担心另一个线程会修改对象的状态. 如果要更新这些变量, 呢么可以创建一个新的容器对象, 但其他使用原有对象的线程仍然会看到对象处于一致的状态.</p>
<ul>
<li><p>当一个线程将volatile类型的cache设置为引用一个新的<code>OneValueCache</code>时, 其他线程会立即看到新缓存的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指向不可变容器对象的volatile类型引用以缓存最新的结果</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与<code>cache</code>相关的操作不会相互干扰, 因为<code>OneValueCache</code>是不可变的, 并且在每条相应的代码路径中只会访问它一次, 通过使用包含多个状态变量的容器对象来维持不变性,并使用<code>volatile</code>类型的引用确保可见性, 使得<code>VolatileCachedFactorizer</code>在没有显示的使用锁的情况下仍是线程安全的</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-安全发布"><a href="#5-安全发布" class="headerlink" title="5. 安全发布"></a>5. 安全发布</h3><ul>
<li><p>由于存在可见性问题, 其他线程看到的Holder对象将处于不一致的状态, 即便在该对象的构造函数中正确的构建了不变性条件, 这种不正确的发布将导致其他线程看到尚未创建完成的对象</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不安全的发布</span></span><br><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>不正确的发布: 正确的对象被破坏</p>
<ul>
<li><p>不能指望一个<strong>尚未被完全创建</strong>的对象拥有完整性.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n!=n)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>除了发布对象的线程外, 其他线程可以看到的Holder是一个失效值, 因此将看到一个空引用或之前的旧值</li>
</ul>
</li>
</ul>
</li>
<li><p>要安全的发布一个对象, 对象的引用以及对象的状态必须同时对其他线程可见, 一个正确构造的对象可以通过以下方式来安全地发布;</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到<code>volatile</code>类型的域或<code>AtomicReferance</code>对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
</li>
</ol>
<ul>
<li><p>通常, 要发布一个静态构造的对象, 最简单和最安全的方式是使用静态的初始化器, 因为静态初始化器由JVM在类的初始化阶段执行</p>
</li>
<li><p>对象的发布需求取决于它的可变性:</p>
<ul>
<li>不可变对象可以通过任意机制发布</li>
<li>事实不可变对象必须通过安全方式来发布</li>
<li>可变对象必须通过安全方式来发布, 并且必须是线程安全的或者由某个锁保护起来</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在并发程序中使用和共享对象时, 可以使用一些使用的策略, 包括:</p>
<ul>
<li><strong>线程封闭</strong>: 线程封闭的对象只能由一个线程拥有, 对象被封闭在该线程中, 并且只能由这个线程修改</li>
<li><strong>只读共享</strong>: 在没有额外同步的情况下, 共享的只读对象可以由多个线程并发访问,但是任何线程都不能修改它. 共享的只读对象包括不可变对象和事实不可变对象</li>
<li><strong>线程安全共享</strong>: 线程安全的对象在其内部实现同步, 因此多个线程可以通过公有接口进行访问, 而不用进一步的同步</li>
<li><strong>保护对象</strong>: 被保护的对象只能通过持有特定的锁来访问, 保护对象包括封装再其他线程安全对象中的对象, 以及已发布的并由某个特定所保护的对象</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实践笔记(1)--线程安全</title>
    <url>/posts/41c3286f.html</url>
    <content><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="1-并发的风险"><a href="#1-并发的风险" class="headerlink" title="1. 并发的风险"></a>1. 并发的风险</h3><ul>
<li><p>安全性问题</p>
<ul>
<li><p>在没有充足同步的情况下, 多个线程的操作执行顺序是不可预测的, 有可能产生奇怪的结果, 比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++; <span class="comment">// 竟态条件(Race Condition)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ++ 操作不是原子性操作, 在单线程时没有问题, 但是多线程时,就可能引发线程安全问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    i++ 不是原子操作, 是3个原子操作组合</span></span><br><span class="line"><span class="comment">        1.读取主存中的count值, 赋值给一个局部成员变量tmp</span></span><br><span class="line"><span class="comment">        2.tmp+1</span></span><br><span class="line"><span class="comment">        3.将tmp赋值给count</span></span><br><span class="line"><span class="comment">    可能会出现线程1运行到第2步的时候, tmp值为1；这时CPU调度切换到线程2执行完毕, count值为1；切换到线程1, 继续执行第3步, count被赋值为1</span></span><br><span class="line"><span class="comment">    结果就是两个线程执行完毕, count的值只加了1, 而且两个线程获取到同样的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>i++</code>不是原子操作, 所以会引发多线程安全问题, 可以通过加<code>synchronized</code>关键字保证同步, 这样可以保证线程安全, 但是效率会变的很慢</p>
</li>
<li><p>安全性的含义是”保证永远不会发生糟糕的事”.</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>活跃性问题</p>
<ul>
<li>当某个操作无法继续执行下去时, 就会发生活跃性问题. 在串行程序中活跃性问题的形式之一就是无线循环, 而在多线程中, 则是死锁, 饥饿, 活锁等.</li>
<li>活跃性意味着某件事最终会发生</li>
</ul>
</li>
</ul>
<h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h3><ul>
<li><p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作时, 必须采用同步机制来协同这些线程对变量的访问.</p>
</li>
<li><p>完全由线程安全类构成的程序并不一定就是线程安全的, 而在线程安全类中也可以包含非线程安全的类, 只有当类中仅包含自己的状态时, 线程安全类才是有意义的</p>
</li>
<li><p>当多个线程访问某个类时, 这个类始终都能表现出正确的行为, 那么就称这个类是线程安全的.(无状态(不包含任何域, 也不包含任何对其他类中域的引用)对象一定是线程安全的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span></span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigIntergerp[] factors = factor[i];</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="非原子性问题解决-CAS"><a href="#非原子性问题解决-CAS" class="headerlink" title="非原子性问题解决(CAS)"></a>非原子性问题解决(CAS)</h4><ul>
<li>在 Java 并发领域, 我们解决并发安全问题最粗暴的方式就是使用 synchronized 关键字了, 但它是一种独占形式的锁, 属于悲观锁机制, 性能会大打折扣。volatile 貌似也是一个不错的选择, 但 volatile 只能保持变量的可见性, 并不保证变量的原子性操作。</li>
<li>CAS 全称是 <code>compare and swap</code>, 即比较并交换, 它是一种原子操作, 同时 CAS 是一种乐观机制。<code>java.util.concurrent</code> 包很多功能都是建立在 CAS 之上, 如 <code>ReenterLock</code> 内部的 AQS, 各种原子类, 其底层都用 CAS来实现原子操作</li>
</ul>
<h5 id="原子性问题分析"><a href="#原子性问题分析" class="headerlink" title="原子性问题分析"></a>原子性问题分析</h5><ul>
<li><p>查看 i++ 的机制</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  通过<code>javap -c AddTest</code>反编译查看add方法的字节码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: dup</span><br><span class="line">    2: getfield      #2          // Field i:I</span><br><span class="line">    <span class="number">5</span>: iconst_1</span><br><span class="line">    <span class="number">6</span>: iadd</span><br><span class="line">    7: putfield      #2          // Field i:I</span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>i++</code>被拆分成了几个指令：<ol>
<li>执行<code>getfield</code>拿到原始<code>i</code>；</li>
<li>执行<code>iadd</code>进行加 1 操作；</li>
<li>执行<code>putfield</code>写把累加后的值写回<code>i</code>。</li>
</ol>
</li>
<li>当线程 1 执行到加 1 步骤时, 由于还没有执行赋值改变变量的值, 这时候并不会刷新主内存区中的变量, 如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中, 问题就出现了, 当线程 2 拷贝完以后, 线程1正好执行赋值运算, 立马更新主内存区的值, 那么此时线程 2 的副本就是旧的了, 出现了脏读.</li>
</ul>
</li>
<li><p>如何解决呢?</p>
<ul>
<li><p>在add方法上加上 <code>synchronized</code> 关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决了并发安全问题, 但是性能也大打折扣</p>
</li>
</ul>
</li>
</ul>
<h5 id="CAS-底层原理"><a href="#CAS-底层原理" class="headerlink" title="CAS 底层原理"></a>CAS 底层原理</h5><p>CAS 的思想很简单：三个参数, 一个当前内存值 V、旧的预期值 A、即将更新的值 B, 当且仅当预期值 A 和内存值 V 相同时, 将内存值修改为 B 并返回 true, 否则什么都不做, 并返回 false。</p>
<ul>
<li><p>查看 <code>AtomicInteger</code> 静态代码块片段：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里用到了 <code>sun.misc.Unsafe</code> 类, 它可以提供硬件级别的原子操作, 它可以获取某个属性在内存中的位置, 也可以修改对象的字段值, 只不过该类对一般开发而言, 很少会用到, 其底层是用 <code>C/C++</code> 实现的, 所以它的方式都是被 <code>native</code> 关键字修饰过的<br>  可以看得出 <code>AtomicInteger</code> 类存储的值是在 <code>value</code> 字段中, 并且获取了 <code>Unsafe</code> 实例, 在静态代码块中, 还获取了 <code>value</code> 字段在内存中的偏移量 <code>valueOffset</code></p>
<ul>
<li><p>接下来的例子使用CAS技术保证了并发安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddIntTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getAndIncrement();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getAndAddInt()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2); <span class="comment">// native方法</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<span class="comment">// native 方法, 自旋</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>var5 通过 <code>this.getIntVolatile(var1, var2)</code>方法获取, 是个 native 方法, 其目的是获取 var1 在 var2 偏移量的值, 其中 var1 就是 <code>AtomicInteger</code>, var2 是 valueOffset 值</p>
</li>
<li><p>那么 CAS 核心重点来了，<code>compareAndSwapInt</code> 就是实现 CAS 的核心方法，其原理是如果 var1 中的 value 值和 var5 相等，就证明没有其他线程改变过这个变量，那么就把 value 值更新为 <code>var5 + var4</code>，其中 var4 是更新的增量值；反之如果没有更新，那么 CAS 就一直采用自旋的方式继续进行操作（其实就是个 while 循环），这一步也是一个原子操作</p>
</li>
<li><p>举例分析:</p>
<ol>
<li>设定 <code>AtomicInteger</code> 的 value 原始值为 A，从 Java 内存模型得知，线程 1 和线程 2 各自持有一份 value 的副本，值都是 A。</li>
<li>线程 1 通过<code>getIntVolatile(var1, var2)</code>拿到 value 值 A，这时线程 1 被挂起</li>
<li>线程 2 也通过<code>getIntVolatile(var1, var2)</code>方法获取到 value 值 A，并执行<code>compareAndSwapInt</code>方法比较内存值也为 A，成功修改内存值为 B</li>
<li>这时线程 1 恢复执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值 A 和内存的值 B 不一致，说明该值已经被其它线程提前修改过了</li>
<li>线程 1 重新执行<code>getIntVolatile(var1, var2)</code>再次获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功</li>
</ol>
</li>
<li><p>查看 <code>hospot</code> 的源码<code>hotspot\src\share\vm\prims\unsafe.cpp</code>, 发现具体实现为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">oop p = JNIHandles::resolve(obj);</span><br><span class="line"> <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset</span></span><br><span class="line">jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line"><span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line"><span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">assert(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">"more work to do"</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                   (jint)compare_value);</span><br></pre></td></tr></table></figure>

<ul>
<li>…没看懂<ol>
<li>先想办法拿到变量value在内存中的地址。</li>
<li>通过<code>Atomic::cmpxchg</code>实现比较替换，其中参数x是即将更新的值，参数e是原内存的值</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h5><ol>
<li><p>ABA问题</p>
<ul>
<li>有2个线程同时对同一个值(初始值为A)进行CAS操作，还有一个线程想要更新该值为A, 这3个线程如下:<ul>
<li>线程1，期望值为A，欲更新的值为B</li>
<li>线程2，期望值为A，欲更新的值为B</li>
<li>线程3，期望值为B，欲更新的值为A</li>
</ul>
</li>
<li><strong>线程1</strong>抢先获得CPU时间片，而<strong>线程2</strong>因为其他原因阻塞了，<strong>线程1</strong>取值与期望的A值比较，发现相等然后将值更新为B, 然后<strong>线程3</strong>抢到了CPU时间片, <strong>线程3</strong>取值与期望的值B比较，发现相等则将值更新为A，此时<strong>线程2</strong>从阻塞中恢复，并且获得了CPU时间片，这时候<strong>线程2</strong>取值与期望的值A比较，发现相等则将值更新为B，虽然<strong>线程2</strong>也完成了操作，但是<strong>线程2</strong>并不知道值已经经过了<code>A-&gt;B-&gt;A</code>的变化过程<blockquote>
<p>ABA问题带来的危害：<br>小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50<br>线程1（提款机）：获取当前值100，期望更新为50，<br>线程2（提款机）：获取当前值100，期望更新为50，<br>线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50<br>线程3（默认）：获取当前值50，期望更新为100，<br>这时候线程3成功执行，余额变为100，<br>线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！<br>此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。</p>
</blockquote>
</li>
<li>通常，我们的乐观锁实现中都会带一个 <code>version</code> 字段来记录更改的版本, 每次变量更新的时候, 版本号+1, 避免并发操作带来的问题。在 Java 中，<code>AtomicStampedReference</code> 实现了这个处理方式。</li>
</ul>
</li>
<li><p>循环时间长开销大</p>
<ul>
<li><p>如果CAS操作失败，就需要循环进行CAS操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销</p>
<blockquote>
<p>这种循环也称为自旋</p>
</blockquote>
</li>
<li><p>解决方法： 限制自旋次数，防止进入死循环</p>
</li>
</ul>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<ul>
<li><code>CAS</code>的原子操作只能针对一个共享变量</li>
<li>解决方法： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行CAS操作</li>
</ul>
</li>
</ol>
<h5 id="CAS的应用"><a href="#CAS的应用" class="headerlink" title="CAS的应用"></a>CAS的应用</h5><p>CAS操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，CAS就是乐观锁的实现</p>
<ol>
<li><p>乐观锁  </p>
<p> 乐观锁总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</p>
</li>
<li><p>悲观锁  </p>
<p>  悲观锁总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，<strong>别的线程会一直阻塞</strong>直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久  </p>
</li>
</ol>
<p>Java利用CAS的乐观锁、原子性的特性高效解决了多线程的安全性问题，例如JDK1.8中的集合类<code>ConcurrentHashMap</code>、关键字<code>volatile</code>、<code>ReentrantLock</code>等</p>
<blockquote>
<p>参考文章:  </p>
<p><a href="https://juejin.im/post/5c87afa06fb9a049f1550b04" target="_blank" rel="noopener">CAS原理分析及ABA问题</a>  </p>
<p><a href="https://objcoding.com/2018/11/29/cas/#aba-%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">Java并发之CAS原理分析</a></p>
</blockquote>
<h4 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h4><ul>
<li><p>由于不恰当的执行时序而出现不正确的结果就是竟态条件(Race Condition). 最常见的竟态条件类型就是”先检查后执行(check-then-Act)”操作, 即通过一个可能失效的观测结果来决定下一步的动作</p>
<blockquote>
<p>数据竞争(data race): 如果在访问共享的非final类型的域时没有采用同步来进行协同, 那么就会出现数据竞争.</p>
<p>当一个线程写入一个变量, 而另一个线程接下来读取这个变量, 或者获取一个之前由另一个线程写入的变量时, 并且在这两个线程之间没有使用同步, 那么就可能出现数据竞争.</p>
<p>如果存在数据竞争, 那么这段代码没有确定的语义, 并非所有的竟态条件都是数据竞争, 同样并非所有的数据竞争都是竟态条件, 但二者都可能使并发程序失败</p>
</blockquote>
<ul>
<li>竟态条件并不总会产生错误, 还需要某种不恰当的执行时序</li>
</ul>
</li>
</ul>
<ol>
<li><p>惰性初始化中的竟态条件(lazy initialization)</p>
<ul>
<li><p>目的是延迟对象的初始化, 直到程序真正使用它, 同时确保他只初始化一次(单例)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resource == <span class="keyword">null</span>)</span><br><span class="line">            resource = <span class="keyword">new</span> Resource(); <span class="comment">// unsafe publication</span></span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>复合操作</p>
<ul>
<li><p>复合操作: 先检查后执行, “读取-修改-写入”等操作的全部执行过程看作复合操作, 为了保证线程安全, 操作必须原子地执行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原子类变量, 利用CAS原理实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count.get(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        <span class="comment">// 原子操作</span></span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encodeIntoResponse</span><span class="params">(ServletResponse res, BigInteger[] factors)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">BigInteger <span class="title">extractFromRequest</span><span class="params">(ServletRequest req)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul>
<li><p>尽管在程序中所有的变量都是原子操作, 但还是可能出现竟态条件, 可能产生错误的结果. 当不变性条件中涉及多个变量时, 各个变量之间并不是彼此独立的, 而是某个变量的值会对其他变量的值产生约束, 因此, 当需要更新某个变量时, 需要在同一个原子操作中对其他变量同时进行更新, 这就需要加锁来实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber</span><br><span class="line">            = <span class="keyword">new</span> AtomicReference&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors</span><br><span class="line">            = <span class="keyword">new</span> AtomicReference&lt;BigInteger[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get())) <span class="comment">// 竟态条件</span></span><br><span class="line">            encodeIntoResponse(resp, lastFactors.get());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            BigInteger[] factors = factor(i);</span><br><span class="line">            lastNumber.set(i);<span class="comment">//竟态条件, 每个set是安全的, 但是合起来就不一定了, 可能只更新了一个值然后被中断</span></span><br><span class="line">            lastFactors.set(factors);</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p><strong>内置锁</strong><br> Java中提供了一种内置的锁机制来支持原子性:  </p>
<ul>
<li><strong>同步代码块(Synchronized Block)</strong><br>同步代码块包括2部分, 一个作为锁的对象引用, 一个作为由这个锁保护的代码块.<br>同步代码块的锁就是方法调用所在的对象, 静态的<code>synchronized</code>方法以Class对象作为锁 <code>synchronized(lock) { // 由锁保护的共享状态 }</code><br>每个Java对象都可以用做一个实现同步的锁, 这些锁被称为<strong>内置锁(Intrinsic Lock)</strong>或<strong>监视器锁(Monitor Lock)</strong>, 线程在进入同步代码块之前会自动获得锁, 并且在退出同步代码块后自动释放锁, 无论是正常退出还是抛出异常.<br>Java的内置锁相当于一种互斥体, 即最多只有一个线程持有这种锁</li>
</ul>
</li>
<li><p><strong>重入</strong><br> 当某个线程请求一个由其他线程持有的锁时, 发出的线程就会阻塞. 然而由于<strong>内置锁是可重入的</strong>(某个线程试图获取一个已经由他自己持有的锁, 那么这个请求会成功).<br> 重入意味着获取锁的操作的粒度是”线程”,不是”调用”.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.ou.println(<span class="string">"doSomething..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toString() + <span class="string">": calling doSomething"</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类重写了父类的<code>synchronized</code>方法, 然后调用父类的方法, 如果没有可重入的锁, 那么这段代码将会产生死锁, 由于<code>Widget</code>和<code>LoggingWidget</code>中的<code>doSomething</code>方法都是<code>synchronized</code>方法, 因此每个<code>doSomething</code>方法执行前都会获取<code>Widget</code>上的锁, 如果内置锁是不可重入的, 那么调用<code>super.doSomething</code>时将无法获得<code>Widget</code>上的锁, 因为这个锁已经被持有.</li>
</ul>
</li>
</ol>
<hr>
<p>参考资料:  </p>
<blockquote>
<p><a href="https://juejin.im/post/5c87afa06fb9a049f1550b04" target="_blank" rel="noopener">CAS原理分析及ABA问题</a>  </p>
<p><a href="https://objcoding.com/2018/11/29/cas/#aba-%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">Java并发之CAS原理分析</a>  </p>
<p>Java Concurrency in Practice(Java并发编程实践) [作者: Brian Goetz]</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/posts/f12cbde5.html</url>
    <content><![CDATA[<h2 id="1-数据库基本知识"><a href="#1-数据库基本知识" class="headerlink" title="1.数据库基本知识"></a>1.数据库基本知识</h2><h3 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1.数据库相关概念"></a>1.数据库相关概念</h3><ol>
<li>DB：数据库，保存一组有组织的数据的容器  </li>
<li>DBMS：数据库管理系统，又称为数据库软件(产品)，用于管理DB中的数据</li>
<li>SQL:结构化查询语言，用于和DBMS通信的语言</li>
</ol>
<h3 id="2-数据库存储数据的特点"><a href="#2-数据库存储数据的特点" class="headerlink" title="2.数据库存储数据的特点"></a>2.数据库存储数据的特点</h3><ol>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</li>
<li>表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ol>
<h3 id="3-MySQL的常见命令"><a href="#3-MySQL的常见命令" class="headerlink" title="3.MySQL的常见命令"></a>3.MySQL的常见命令</h3><ol>
<li><p>查看当前所有的数据库<br> show databases;</p>
</li>
<li><p>打开指定的库<br> use 库名</p>
</li>
<li><p>查看当前库的所有表<br> show tables;</p>
</li>
<li><p>查看其它库的所有表<br> show tables from 库名;</p>
</li>
<li><p>创建表  </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    列名 列类型,</span><br><span class="line">    列名 列类型，</span><br><span class="line">    。。。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>查看表结构<br> desc 表名;</p>
</li>
<li><p>查看服务器的版本  </p>
<ul>
<li>方式一：登录到mysql服务端<ul>
<li>select version(); // 函数</li>
</ul>
</li>
<li>方式二：没有登录到mysql服务端<ul>
<li>mysql –version</li>
<li>mysql –V</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-MySQL的语法规范"><a href="#4-MySQL的语法规范" class="headerlink" title="4.MySQL的语法规范"></a>4.MySQL的语法规范</h3><ol>
<li>不区分大小写,但建议关键字大写，表名. 列名小写</li>
<li>每条命令最好用分号结尾</li>
<li>每条命令根据需要，可以进行缩进 或换行</li>
<li>注释<br>单行注释：#注释文字<br>单行注释：– 注释文字<br>多行注释：/* 注释文字  */</li>
</ol>
<h3 id="5-SQL的语言分类"><a href="#5-SQL的语言分类" class="headerlink" title="5.SQL的语言分类"></a>5.SQL的语言分类</h3><ul>
<li>DQL(Data Query Language)：数据查询语言<ul>
<li>select  </li>
</ul>
</li>
<li>DML(Data Manipulate Language):数据操作语言<ul>
<li>insert . update. delete</li>
</ul>
</li>
<li>DDL(Data Define Languge)：数据定义语言<ul>
<li>create. drop. alter</li>
</ul>
</li>
<li>TCL(Transaction Control Language)：事务控制语言<ul>
<li>commit. rollback<br>​</li>
</ul>
</li>
</ul>
<h3 id="6-SQL的常见命令"><a href="#6-SQL的常见命令" class="headerlink" title="6.SQL的常见命令"></a>6.SQL的常见命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>； <span class="comment"># 查看所有的数据库</span></span><br><span class="line"><span class="keyword">use</span> 库名；<span class="comment"># 打开指定 的库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> ; <span class="comment"># 显示库中的所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> 库名; <span class="comment"># 显示指定库中的所有表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名 字段类型,</span><br><span class="line">    字段名 字段类型</span><br><span class="line">);  <span class="comment"># 创建表</span></span><br><span class="line"></span><br><span class="line">desc 表名; 查看指定表的结构</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名;显示表中的所有数据</span><br></pre></td></tr></table></figure>

<h2 id="2-DQL语言"><a href="#2-DQL语言" class="headerlink" title="2.DQL语言"></a>2.DQL语言</h2><ul>
<li>数据查询语言</li>
</ul>
<h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><ul>
<li><p>语法：</p>
<ul>
<li><p>SELECT 要查询的东西 FROM [表名];</p>
</li>
<li><p>类似于Java中 :System.out.println(要打印的东西);</p>
</li>
</ul>
</li>
<li><p>应用：</p>
<ol>
<li><p>通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</p>
</li>
<li><p>要查询的东西 可以是常量值. 可以是表达式. 可以是字段. 可以是函数</p>
</li>
<li><p>distinct 去重</p>
</li>
<li><p><code>+</code> 号, 只有一个功能, 就是运算符</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">12</span>+<span class="number">3</span>;    <span class="comment"># 都为数值型, 直接相加</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'123'</span>+<span class="number">3</span>; <span class="comment"># 其一为字符型, 则试图将字符型转换为数值型, 转换成功继续相加, 转换失败则将字符型数值转换为0</span></span><br><span class="line"><span class="keyword">select</span> <span class="literal">null</span>+<span class="number">3</span>;  <span class="comment"># 其中一方为null, 则结果为null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>concat 函数 字符串拼接<br> <code>select concat(lastName, firstName) as 姓名 from users;</code></p>
</li>
<li><p>ifnull 函数, ifnull(ex1, ex2);  </p>
<ul>
<li>ex1: 判断是否为null 的参数</li>
<li>ex2: 如果ex1为null的替代值</li>
</ul>
</li>
<li><p>字符型和日期型的常量必须用单引号括起来</p>
</li>
</ol>
</li>
</ul>
<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><ul>
<li><p>条件查询：根据条件过滤原始表的数据，查询到想要的数据</p>
</li>
<li><p>语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  </span><br><span class="line">    要查询的字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">from</span>  </span><br><span class="line">    表</span><br><span class="line"><span class="keyword">where</span>  </span><br><span class="line">    条件 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件的分类：</p>
<ol>
<li><p>条件表达式<br>示例：<code>salary &gt; 10000</code><br>条件运算符：<code>&gt;  &lt;  &gt;=  &lt;=  =  != / &lt;&gt;</code></p>
</li>
<li><p>逻辑表达式<br>示例：<code>salary&gt;10000 &amp;&amp; salary&lt;20000</code>  </p>
<ul>
<li>逻辑运算符：<ul>
<li>and(&amp;&amp;):两个条件如果同时成立，结果为true，否则为false</li>
<li>or(||)：两个条件只要有一个成立，结果为true，否则为false</li>
<li>not(!)：如果条件成立，则not后为false，否则为true</li>
</ul>
</li>
</ul>
</li>
<li><p>模糊查询  </p>
<ul>
<li><p>示例：<code>last_name like &#39;a%&#39;</code></p>
</li>
<li><p>通配符:</p>
<ul>
<li>%: 任意多个字符, 包含0个</li>
<li>_: 任意单个字符</li>
<li>escape ‘$’,表示 $ 为转义字符’&#39;</li>
</ul>
</li>
<li><p>between and<br>包含临界值, 即闭区间</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  </span><br><span class="line">    *  </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    employee  </span><br><span class="line"><span class="keyword">where</span>  </span><br><span class="line">    employeeId <span class="keyword">between</span> <span class="number">100</span> <span class="keyword">and</span> employeeId&lt;=<span class="number">120</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>in</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  </span><br><span class="line">    <span class="string">`name`</span>, jobId</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    jobId <span class="keyword">in</span> (<span class="string">'IT_PRO'</span>,<span class="string">'AD_VP'</span>,<span class="string">'AD_PRES'</span>); <span class="comment"># in 里面不支持通配符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>is null / is not null<br>只能判断null值</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="string">`name`</span>,</span><br><span class="line">    <span class="string">`commission_pct`</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    <span class="keyword">users</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全等于 &lt;=&gt;<br>可以判断任何类型的值, 可读性较差</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="string">`name`</span>,</span><br><span class="line">    <span class="string">`commission_pct`</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    <span class="keyword">users</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    commission_pct &lt;=&gt;<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><ul>
<li><p>语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    要查询的东西</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    表</span><br><span class="line">[<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序的字段|表达式|函数|别名 [<span class="keyword">asc</span>|<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用:</p>
<ul>
<li>默认是升序排列, asc</li>
<li><code>select * from users order by salary;</code></li>
<li><code>select * from users where id &gt; 90 order by hiredate desc;</code></li>
<li>order by 子句支持 单个字段, 别名, 表达式, 函数, 多个字段</li>
<li>order by 子句 在查询语句的最后, 除了limit子句</li>
</ul>
</li>
</ul>
<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><ol>
<li><p>单行函数</p>
<ol>
<li><p>字符函数</p>
<ul>
<li>concat拼接</li>
<li>substr截取子串</li>
<li>upper转换成大写</li>
<li>lower转换成小写</li>
<li>trim去前后指定的空格和字符</li>
<li>ltrim去左边空格</li>
<li>rtrim去右边空格</li>
<li>replace替换</li>
<li>lpad左填充</li>
<li>rpad右填充</li>
<li>instr返回子串第一次出现的索引</li>
<li>length 获取字节个数</li>
</ul>
</li>
<li><p>数学函数</p>
<ul>
<li>round 四舍五入</li>
<li>rand 随机数</li>
<li>ceil 向上取整, 返回&gt;=该参数的最小整数</li>
<li>floor 向下取整</li>
<li>truncate 截断<br><code>truncate(1.234,1);  ==&gt; 1.2</code></li>
<li>mod 取余 mod(a,b) = a-a/b*b<br>mod(10,-3);  -1</li>
</ul>
</li>
<li><p>日期函数</p>
<ul>
<li>now 当前系统日期+时间</li>
<li>curdate 当前系统日期</li>
<li>curtime 当前系统时间</li>
<li>str_to_date 将字符转换成日期</li>
<li>date_format 将日期转换成字符</li>
</ul>
</li>
<li><p>其他函数</p>
<ul>
<li>version 版本</li>
<li>database 当前库</li>
<li>user 当前连接用户</li>
</ul>
</li>
<li><p>流程控制函数</p>
<ul>
<li>if 处理双分支</li>
<li>case语句 处理多分支<ul>
<li>情况1：处理等值判断</li>
<li>情况2：处理条件判断</li>
</ul>
</li>
</ul>
</li>
<li><p>分组函数</p>
<ul>
<li>用作统计使用, 又称为聚合函数或统计函数</li>
<li>sum 求和</li>
<li>max 最大值</li>
<li>min 最小值</li>
<li>avg 平均值</li>
<li>count 计数</li>
<li>特点：<ol>
<li>以上五个分组函数都忽略null值，除了count(*)</li>
<li>sum和avg一般用于处理数值型<br> max. min. count可以处理任何数据类型</li>
<li>都可以搭配distinct使用，用于统计去重后的结果</li>
<li>count的参数可以支持：  <ul>
<li>字段. *. 常量值，一般放1  </li>
<li>建议使用 count(*)<ul>
<li>MYISAM 引擎下, count(*)效率最高</li>
<li>INNODB 引擎下, count(1)和count(*)差不多</li>
</ul>
</li>
</ul>
</li>
<li>和分组函数一同查询的字段要求是 group by 后的字段, 否则没有意义</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(<span class="string">'join'</span>); <span class="comment"># get the length of the string</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(lastName,<span class="string">'_'</span>,firstName) <span class="keyword">from</span> <span class="keyword">users</span>; <span class="comment"># concat the string  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">upper</span>(<span class="string">'join'</span>); <span class="comment"># `JOIN`</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'htasdfja'</span>, <span class="number">6</span>); <span class="comment"># sql中的索引 从 1 开始;截取从 6 开始到末尾 fja</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'htasdfja'</span>, <span class="number">1</span>, <span class="number">3</span>); <span class="comment"># 从 1 开始, 截取长度为3</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'数据结构与算法'</span>, <span class="string">'算法'</span>); <span class="comment"># 返回算法的索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(<span class="string">'a'</span> <span class="keyword">from</span> <span class="string">'aaaaaa张aaaaa阿斯aaaaaa'</span>) <span class="keyword">as</span> <span class="keyword">out</span>; <span class="comment"># 返回张aaaaa阿斯</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(<span class="string">'杨不悔'</span>,<span class="number">4</span>,<span class="string">'*'</span>); <span class="comment"># 长度为4, 不够向左边填充*, 若长度不够, 比如 2, 则从左往右截断, 杨不</span></span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">'asdf'</span>,<span class="number">12</span>,<span class="string">'+'</span>); <span class="comment"># 右填充指定长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">replace</span>(<span class="string">'aslkdjfalksjdfa;shdfba'</span>,<span class="string">'a'</span>,<span class="string">'A'</span>); <span class="comment"># 将a替换为A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">if</span>(<span class="number">10</span>&gt;<span class="number">5</span>, <span class="string">'大'</span>, <span class="string">'小'</span>);  </span><br><span class="line"><span class="keyword">select</span> <span class="string">`name`</span>, commission_pct, <span class="keyword">if</span>(commission_pct <span class="keyword">is</span> <span class="literal">null</span>, <span class="string">'没奖金,惨'</span>, <span class="string">'有奖金,棒'</span>) 备注 <span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一 类似 java switch</span></span><br><span class="line">case `要判断的值或表达式`</span><br><span class="line">when `常量1` then `要表示的值1或表达式1; `</span><br><span class="line">when `常量2` then `要表示的值2或表达式2;`</span><br><span class="line">`...`</span><br><span class="line">else `默认显示的值或语句`</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 方式二 类似java 多重if else</span></span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> <span class="string">`条件1`</span> <span class="keyword">then</span> <span class="string">`显示的值或 语句;`</span></span><br><span class="line"><span class="keyword">when</span> <span class="string">`条件2`</span> <span class="keyword">then</span> <span class="string">`显示的值或 语句;`</span></span><br><span class="line"><span class="keyword">else</span> <span class="string">`显示的值或 语句;`</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> salary 原始工资, dept_id,</span><br><span class="line"><span class="keyword">case</span> dept_id</span><br><span class="line"><span class="keyword">when</span> <span class="number">30</span> <span class="keyword">then</span> salary*<span class="number">1.1</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">40</span> <span class="keyword">then</span> salary*<span class="number">1.2</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">50</span> <span class="keyword">then</span> salary*<span class="number">1.4</span></span><br><span class="line"><span class="keyword">else</span> salary</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> 新工资</span><br><span class="line"><span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><ul>
<li><p>语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表: 分组函数, 列(要求在 <span class="keyword">group</span> <span class="keyword">by</span> 的后面)</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">[<span class="keyword">where</span> 筛选条件]</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组的列表</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> 子句]</span><br></pre></td></tr></table></figure>

<ul>
<li>where 一定在from后面</li>
<li>查询列表必须特殊, 必须是分组函数或是group by后出现的字段</li>
</ul>
</li>
<li><p>特点：</p>
<ol>
<li><p>可以按单个字段分组</p>
</li>
<li><p>和分组函数一同查询的字段最好是分组后的字段</p>
</li>
<li><p>分组筛选<br> 分组前筛选：原始表; group by的前面 where<br> 分组后筛选：分组后的结果集; group by的后面having</p>
<ul>
<li>分组函数做条件, 一定在having中</li>
<li>能用分组前筛选的就用分组前筛选</li>
</ul>
</li>
<li><p>可以按多个字段分组，字段之间用逗号隔开</p>
</li>
<li><p>可以支持排序</p>
</li>
<li><p>having后可以支持别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(salary), job_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(*), location_id</span><br><span class="line"><span class="keyword">from</span> depts</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> location_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(salary),dept_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">where</span> email <span class="keyword">like</span> <span class="string">'%a%'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(salary),manager_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">where</span> commission_por <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> manager_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(*), dept_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(salary) ma, job_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">where</span> commission_por <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job_id</span><br><span class="line"><span class="keyword">having</span> ma&gt;<span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(*) c,<span class="keyword">LENGTH</span>(<span class="keyword">name</span>) len_name</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> len_name</span><br><span class="line"><span class="keyword">having</span> c &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(salary), dept_id, job_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id, job_id; <span class="comment"># dept_id == job_id 的分为一组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(salary) a, dept_id, job_id</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id, job_id</span><br><span class="line"><span class="keyword">having</span> a&gt;<span class="number">10000</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><ul>
<li><p>当查询的字段来自于多个表时, 就会用到连接查询</p>
</li>
<li><p>笛卡尔乘积：</p>
<ul>
<li>如果连接条件省略或无效则会出现</li>
<li>表1中有m行, 表2中有n行, 结果有m*n行</li>
<li>解决办法：添加上连接条件</li>
</ul>
</li>
<li><p>分类:</p>
<ul>
<li><p>按年代分:</p>
<ul>
<li>sql92: 仅支持内连接</li>
<li>sql99(推荐) 支持内连接+外连接(左外,右外)+交叉连接</li>
</ul>
</li>
<li><p>按功能分:</p>
<ul>
<li>内连接 : <strong>查询两个表交集的部分</strong><ol>
<li>等值连接<ul>
<li>用表1的每一行匹配表2的每一行, 但是最后根据连接条件进行筛选</li>
<li>n表连接, 至少需要 n-1 个连接条件</li>
<li>多表顺序没有要求</li>
<li>可以加任何之前讲过的分组, 筛选等</li>
</ul>
</li>
<li>非等值连接<ul>
<li>连接条件不是等号, 其他同等值连接</li>
</ul>
</li>
<li>自然连接<ul>
<li>把原始的表当作2张表, 甚至更多表</li>
<li>相当于等值连接, 但是另一张表就是自己, 必须有特殊的字段才可以<ul>
<li>比如: emps员工表, 有员工id, 某员工的领导存的是领导的员工id, 当查询员工和员工的领导时, 就是先查询该员工领导的员工id, 再根据id查询员工姓名, 得到领导的姓名, 相当于emps表查了2遍, 即自连接</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>外连接 : <strong>查询一个表中有, 一个表中没有的数据</strong><ul>
<li>分主表和从表, 查询的结果为主表中的所有数据, 如果从表中有满足条件的,则显示匹配的值,相当于内连接的部分;如果没有匹配的值, 显示null</li>
<li>外连接查询的结果 = 内连接结果 + 主表中有而而从表没有记录</li>
<li>分类:  <ul>
<li>左外连接 : 左边是主表</li>
<li>右外连接 : 右边是主表</li>
<li>全外连接 : 不分主从表, 结果相当于 内连接结果+左外连接结果+右外连接结果 , MySQL不支持</li>
</ul>
</li>
</ul>
</li>
<li>交叉连接<ul>
<li>笛卡尔乘积的结果</li>
<li>表之间没有顺序关系</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sql92 标准 案例</span></span><br><span class="line"><span class="comment">#等值连接</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">`name`</span>, deptId</span><br><span class="line"><span class="keyword">from</span> emps,depts</span><br><span class="line"><span class="keyword">where</span> emps.deptId=depts.deptId;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果为表起了别名, 则查询的字段就不能用原来的表名去限定</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,e.jobId,jobTiele</span><br><span class="line"><span class="keyword">from</span> emps <span class="keyword">as</span> e,jobs <span class="keyword">as</span> j</span><br><span class="line"><span class="keyword">where</span> e.jobId=j.jobId;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加筛选</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,deptName,commission_pct</span><br><span class="line"><span class="keyword">from</span> emps e, dept d</span><br><span class="line"><span class="keyword">where</span> e.deptId=d.deptId</span><br><span class="line"><span class="keyword">and</span> e.commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加分组</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) 个数,city</span><br><span class="line"><span class="keyword">from</span> dept d, location l</span><br><span class="line"><span class="keyword">where</span> d.locationId=l.locationId</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> city</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非等值连接</span></span><br><span class="line"><span class="keyword">select</span> salary, gradeLevel</span><br><span class="line"><span class="keyword">from</span> employee e, jobGrade g</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> g.lowerSal <span class="keyword">and</span> g.higerSal;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自然连接</span></span><br><span class="line"><span class="keyword">select</span> e.empId, e.name, m.empId, m.name</span><br><span class="line"><span class="keyword">from</span> emps e, emps m</span><br><span class="line"><span class="keyword">where</span> e.managerId=m.empId;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sql99语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段，...</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名</span><br><span class="line">[连接类型] <span class="keyword">join</span> 表<span class="number">2</span> 别名 <span class="keyword">on</span>  连接条件</span><br><span class="line">[<span class="keyword">where</span> 筛选条件]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> 分组字段]</span><br><span class="line">[<span class="keyword">having</span> 分组后的筛选条件]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段或表达式]</span><br></pre></td></tr></table></figure>

<ul>
<li>连接类型:<ul>
<li>内连接 [inner], inner 可以直接省略</li>
<li>外连接<ul>
<li>左外 left [outer]</li>
<li>右外 right [outer]</li>
</ul>
</li>
<li>交叉连接 cross</li>
</ul>
</li>
<li>好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sql99</span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span></span><br><span class="line"><span class="keyword">where</span> e.last_name <span class="keyword">like</span> <span class="string">'_k%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># sql92</span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m  </span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左外连接</span></span><br><span class="line"><span class="keyword">select</span> b.name</span><br><span class="line"><span class="keyword">from</span> beauty b               <span class="comment"># 主表</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> boys bo</span><br><span class="line"><span class="keyword">on</span> b.boyfriendId=bo.id</span><br><span class="line"><span class="keyword">where</span> bo.id <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment"># 右外连接 等价于上面的左外连接</span></span><br><span class="line"><span class="keyword">select</span> b.name</span><br><span class="line"><span class="keyword">from</span> boys bo               <span class="comment"># 主表</span></span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> beauty b</span><br><span class="line"><span class="keyword">on</span> b.boyfriendId=bo.id</span><br><span class="line"><span class="keyword">where</span> bo.id <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全外   mysql 不支持, 但是语法是这么写</span></span><br><span class="line"><span class="keyword">select</span> b.*, bo.*</span><br><span class="line"><span class="keyword">from</span> beauty b</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">outer</span> <span class="keyword">join</span> boys bo</span><br><span class="line"><span class="keyword">on</span> b.boyfriendId=bo.id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉连接</span></span><br><span class="line"><span class="keyword">select</span> b.*, bo.*</span><br><span class="line"><span class="keyword">from</span> beauty b</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> boys bo;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><ul>
<li><p>含义：  </p>
<ul>
<li><p>出现在其他语句中的select语句，称为子查询或内查询</p>
</li>
<li><p>出现在外面的查询语句，称为主查询或外查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>                         <span class="comment"># 主查询</span></span><br><span class="line">    <span class="keyword">name</span>  </span><br><span class="line"><span class="keyword">from</span> emps  </span><br><span class="line"><span class="keyword">where</span> dept_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_id <span class="keyword">from</span> depts  <span class="comment"># 子查询</span></span><br><span class="line">    <span class="keyword">where</span> location_id=<span class="number">1700</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分类：</p>
<ol>
<li>子查询按照出现位置的分类:<ol>
<li>select后面 :<br>仅支持标量子查询, 即结果只能是一行一列</li>
<li>from后面 :<br>支持表子查询, 将子查询的结果充当一张表, 必须起别名</li>
<li><strong>where 或 having后面</strong> :<br><strong>标量子查询</strong>, <strong>列子查询</strong>, 行子查询</li>
<li>exists后面(相关子查询) :<br>表子查询<br>语法: exists(完整的查询语句)<br>结果: 1, 0</li>
</ol>
</li>
<li>子查询根据查询结果的行列数不同分为:<ol>
<li>标量子查询(单行子查询)<ul>
<li>结果集只有一行一列</li>
<li>一般搭配单行操作符使用：<code>&gt; &lt; = &lt;&gt; &gt;= &lt;=</code></li>
<li>非法使用子查询的情况：<ul>
<li>子查询的结果为一组值</li>
<li>子查询的结果为空</li>
</ul>
</li>
</ul>
</li>
<li>列子查询(多行子查询)<ul>
<li>结果集有一列多行</li>
<li>一般搭配多行操作符使用：any. all. in. not in<ul>
<li>in： 属于子查询结果中的任意一个就行</li>
<li>any|some: 和子查询中的某一个值比较</li>
<li>all: 和子查询中所有的值比较</li>
<li>any和all往往可以用其他查询代替, MIN MAX</li>
</ul>
</li>
</ul>
</li>
<li>行子查询<ul>
<li>结果集一行多列</li>
</ul>
</li>
<li>表子查询<ul>
<li>结果集一般为多行多列</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>特点:</p>
<ol>
<li><p>子查询都放在小括号内</p>
</li>
<li><p>子查询一般放在条件的右侧</p>
</li>
<li><p>子查询优先于主查询执行, 主查询使用了子查询的执行结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. where 或 having后面</span></span><br><span class="line">    <span class="comment"># 标量子查询(单行子查询) 谁的工资比 able 高</span></span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> salary&gt;(</span><br><span class="line">        <span class="keyword">select</span> salary</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'able'</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="string">`name`</span>, jobId, salary</span><br><span class="line">    <span class="keyword">FROM</span>  emps</span><br><span class="line">    <span class="keyword">WHERE</span> jobId = (</span><br><span class="line">        <span class="keyword">SELECT</span> jobId</span><br><span class="line">        <span class="keyword">FROM</span> emps</span><br><span class="line">        <span class="keyword">WHERE</span> empId = <span class="number">141</span></span><br><span class="line">    ) <span class="keyword">AND</span> salary &gt; (</span><br><span class="line">        <span class="keyword">SELECT</span> salary</span><br><span class="line">        <span class="keyword">FROM</span> emps</span><br><span class="line">        <span class="keyword">WHERE</span> empId = <span class="number">143</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="string">`name`</span>, jobId, salary</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> salary=(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">    );</span><br><span class="line">    <span class="comment"># 列子查询(多行子查询)</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">`name`</span></span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> deptId <span class="keyword">in</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">distinct</span> deptId</span><br><span class="line">        <span class="keyword">from</span> depts</span><br><span class="line">        <span class="keyword">where</span> locationId <span class="keyword">in</span> (<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="string">`name`</span>, empId, jobId, salary</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> salary &lt; <span class="keyword">ANY</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">distinct</span> salary</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">        <span class="keyword">where</span> jobId =<span class="string">'IT'</span></span><br><span class="line">    ) <span class="keyword">and</span> jobId &lt;&gt; <span class="string">'IT'</span>;</span><br><span class="line">    <span class="comment"># 上述可以简化为</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">`name`</span>, empId, jobId, salary</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> salary &lt; (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">        <span class="keyword">where</span> jobId =<span class="string">'IT'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">and</span> jobId &lt;&gt; <span class="string">'IT;'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 员工编号最小, 且工资最高</span></span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> empId=(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">MIN</span>(empId)</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">    ) <span class="keyword">and</span> salary=(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">    );</span><br><span class="line">    <span class="comment"># 行子查询</span></span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> (empId,salary)=(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">MIN</span>(empId), <span class="keyword">MAX</span>(salary)</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. select 后面</span></span><br><span class="line">    <span class="comment"># 查询每个部门的员工个数</span></span><br><span class="line">    <span class="keyword">select</span> d.*,  (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">        <span class="keyword">from</span> emps e</span><br><span class="line">        <span class="keyword">where</span> e.deptId=d.deptId</span><br><span class="line">    ) 个数</span><br><span class="line">    <span class="keyword">from</span> dept d;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询员工号为102的部门名</span></span><br><span class="line">    <span class="keyword">select</span> (</span><br><span class="line">        <span class="keyword">select</span> deptName</span><br><span class="line">        <span class="keyword">from</span> dept d</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> emp e</span><br><span class="line">        <span class="keyword">on</span> d.deptId=e.deptId</span><br><span class="line">        <span class="keyword">where</span> e.empId=<span class="number">102</span></span><br><span class="line">    ) 部门名;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. from 后面</span></span><br><span class="line">    <span class="comment"># 查询每个部门的平均工资的工资等级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> ag_dep.*, gradeLevel</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">AVG</span>(salary) ag, deptId</span><br><span class="line">        <span class="keyword">from</span> emps</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> deptId</span><br><span class="line">    ) ag_dep</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> jobGrade g</span><br><span class="line">    <span class="keyword">on</span> ag_dep.ag <span class="keyword">between</span> lowerSa <span class="keyword">and</span> higherSa</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><ul>
<li><p>应用场景：</p>
<ul>
<li>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</li>
</ul>
</li>
<li><p>语法：  </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段|表达式,...</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">[<span class="keyword">where</span> 条件]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> 分组字段]</span><br><span class="line">[<span class="keyword">having</span> 条件]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段]</span><br><span class="line"><span class="keyword">limit</span> [起始的条目索引，]条目数;  <span class="comment"># 该索引从 0 开始</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ol>
<li>起始条目索引从0开始</li>
<li>limit子句放在查询语句的最后</li>
<li>公式：<code>select * from  表 limit (page-1)*sizePerPage,sizePerPage</code>  <ul>
<li>每页显示条目数sizePerPage; 要显示的页数 page</li>
</ul>
</li>
</ol>
</li>
<li><p>例子</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emps <span class="keyword">limit</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">where</span> commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询平均工资最低的部门信息</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> department_id=(</span><br><span class="line">    <span class="keyword">SELECT</span> department_id</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><ul>
<li><p>概念：union 联合. 合并, 将多条查询语句的结果合成成一个结果</p>
</li>
<li><p>应用场景: 查询的结果来自多个表, 但多个表之间没有连接关系, 且查询的信息一致</p>
</li>
<li><p>语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段|常量|表达式|函数 [<span class="keyword">from</span> 表] [<span class="keyword">where</span> 条件] <span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段|常量|表达式|函数 [<span class="keyword">from</span> 表] [<span class="keyword">where</span> 条件] <span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段|常量|表达式|函数 [<span class="keyword">from</span> 表] [<span class="keyword">where</span> 条件] <span class="keyword">union</span>  [<span class="keyword">all</span>]</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">select</span> 字段|常量|表达式|函数 [<span class="keyword">from</span> 表] [<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ol>
<li><p>多条查询语句查询的列数必须是一致的</p>
</li>
<li><p>多条查询语句查询的列的类型和顺序最好一致</p>
</li>
<li><p>union代表去重，union all代表不去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询部门编号大于90或邮箱包含a 的员工信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emps <span class="keyword">where</span> email <span class="keyword">like</span> <span class="string">'%a%'</span> <span class="keyword">or</span> deptId&gt;<span class="number">90</span>;</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emps <span class="keyword">where</span> email <span class="keyword">like</span> <span class="string">'%a%'</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emps <span class="keyword">where</span> deptId&gt;<span class="number">90</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="3-DML语言"><a href="#3-DML语言" class="headerlink" title="3.DML语言"></a>3.DML语言</h2><ul>
<li>数据管理语言</li>
</ul>
<h3 id="1-插入-insert"><a href="#1-插入-insert" class="headerlink" title="1.插入 insert"></a>1.插入 insert</h3><ul>
<li>语法：  <ol>
<li><code>insert into 表名(字段名，...) values(值1，...);</code>  </li>
<li><code>insert into 表名 set 列名1=值1, 列名2=值2, ...</code></li>
</ol>
</li>
<li>特点：<ol>
<li>字段类型和值类型一致或兼容，而且一一对应</li>
<li>可以为空的字段，可以不用插入值，或用null填充</li>
<li>不可以为空的字段，必须插入值</li>
<li>字段个数和值的个数必须一致</li>
<li>字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</li>
<li>法1支持插入多行, 法2不支持; 法1支持子查询, 法2不支持</li>
</ol>
</li>
</ul>
<h3 id="2-修改-update"><a href="#2-修改-update" class="headerlink" title="2.修改 update"></a>2.修改 update</h3><ul>
<li><p>修改单表语法：<code>update 表名 set 字段1=新值1,字段2=新值2 [where 条件]</code></p>
</li>
<li><p>修改多表语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 92语法</span></span><br><span class="line"><span class="keyword">update</span> 表<span class="number">1</span> 别名<span class="number">1</span>,表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> 字段=新值，字段=新值</span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件</span><br><span class="line"><span class="comment"># 99语法</span></span><br><span class="line"><span class="keyword">update</span> 表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">inner</span>|<span class="keyword">left</span>|<span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span> 筛选条件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-删除-delete"><a href="#3-删除-delete" class="headerlink" title="3.删除 delete"></a>3.删除 delete</h3><ul>
<li><p>方式1：delete语句  </p>
<ul>
<li><p>单表的删除： ★<br>delete from 表名 [where 筛选条件]</p>
</li>
<li><p>多表的删除：(利用连接删除)  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 92</span></span><br><span class="line"><span class="keyword">delete</span> 别名<span class="number">1</span>，别名<span class="number">2</span>  <span class="comment"># 删谁写谁</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名<span class="number">1</span>，表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 99</span></span><br><span class="line"><span class="keyword">delete</span> 别名<span class="number">1</span>，别名<span class="number">2</span>  <span class="comment"># 删谁写谁</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名<span class="number">1</span></span><br><span class="line">[连接方式] <span class="keyword">join</span> 表<span class="number">2</span> 别名<span class="number">2</span></span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span> 筛选条件</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg 删除Java的朋友的信息</span></span><br><span class="line"><span class="keyword">delete</span> f</span><br><span class="line"><span class="keyword">from</span> friend f</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> boy b</span><br><span class="line"><span class="keyword">on</span> f.friendId=b.id</span><br><span class="line"><span class="keyword">where</span> b.name=<span class="string">'java'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式2：truncate语句</p>
<ul>
<li>truncate table 表名;  删除整个表</li>
</ul>
</li>
<li><p>两种方式的区别:</p>
<ol>
<li>truncate 不能加 where 条件，而 delete 可以加 where 条件</li>
<li>truncate 的效率高一丢丢, 因为直接全部删掉了</li>
<li>truncate 删除带自增长的列的表后，如果再插入数据，数据<strong>从1开始</strong><br>delete 删除带自增长列的表后，如果再插入数据，数据<strong>从上一次的断点处开始</strong></li>
<li>truncate 删除没有返回值，delete 删除有返回值</li>
<li>truncate 删除不能回滚，delete 删除可以回滚</li>
</ol>
</li>
</ul>
<h2 id="4-DDL语言"><a href="#4-DDL语言" class="headerlink" title="4.DDL语言"></a>4.DDL语言</h2><ul>
<li>数据定义语言</li>
</ul>
<h3 id="4-库和表的管理"><a href="#4-库和表的管理" class="headerlink" title="4.库和表的管理"></a>4.库和表的管理</h3><ul>
<li><p>库的管理：</p>
<ol>
<li>创建库<br><code>create database [if not exists] 库名</code></li>
<li>修改库的字符集<br><code>alter database books character set utf-8</code></li>
<li>删除库<br><code>drop database [if exists] 库名</code></li>
</ol>
</li>
<li><p>表的管理：</p>
<ol>
<li><p>创建表</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 表名(</span><br><span class="line">   列名 列的类型 [长度 约束],</span><br><span class="line">   列名 列的类型 [长度 约束],</span><br><span class="line">   ...</span><br><span class="line">   列名 列的类型 [长度 约束]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">    stuId <span class="built_in">INT</span>,</span><br><span class="line">    stuName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="built_in">CHAR</span>,</span><br><span class="line">    bornDate DATETIME</span><br><span class="line">);</span><br><span class="line">DESC studentinfo;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表 alter : 是修改表的结构, 不是修改数据</p>
<ul>
<li><p>语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 [字段类型];</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 修改字段名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> sex gender <span class="built_in">CHAR</span>;</span><br><span class="line"><span class="comment"># 2. 修改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">RENAME</span> [<span class="keyword">TO</span>]  studentinfo;</span><br><span class="line"><span class="comment"># 3. 修改字段类型和列级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> borndate <span class="built_in">DATE</span> ;</span><br><span class="line"><span class="comment"># 4. 添加字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> email <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">first</span>;</span><br><span class="line"><span class="comment"># 5. 删除字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>删除表  </p>
<ul>
<li>DROP TABLE [IF EXISTS] studentinfo;</li>
</ul>
</li>
<li><p>表的复制  </p>
<ul>
<li>create table 新表 like 要复制的表;   只复制表的结构</li>
<li>create table 新表 select * from 要复制的表;  复制表的结构和数据</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="5-常见类型"><a href="#5-常见类型" class="headerlink" title="5.常见类型"></a>5.常见类型</h3><ol>
<li><p>数值型</p>
<ul>
<li><p>整型：</p>
<table>
<thead>
<tr>
<th align="center">整数类型</th>
<th align="center">字节数</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tinyint</td>
<td align="center">1</td>
<td align="left">有符号 -128<del>127; 无符号0</del>255</td>
</tr>
<tr>
<td align="center">Smallint</td>
<td align="center">2</td>
<td align="left">有符号 -32768<del>32767; 无符号0</del>65535</td>
</tr>
<tr>
<td align="center">Mediumint</td>
<td align="center">3</td>
<td align="left">很大 2^24</td>
</tr>
<tr>
<td align="center">Int/Integer</td>
<td align="center">4</td>
<td align="left">很大 2^32</td>
</tr>
<tr>
<td align="center">Bigint</td>
<td align="center">8</td>
<td align="left">很大 2^64</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tabInt(</span><br><span class="line">    t1 <span class="built_in">int</span>,         <span class="comment"># 默认有符号</span></span><br><span class="line">    t2 <span class="built_in">int</span> <span class="keyword">unsigned</span>,</span><br><span class="line">    t3 <span class="built_in">int</span>(<span class="number">7</span>) zerofill</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>特点:<ul>
<li>默认是有符号的</li>
<li>插入数值超出范围会报异常(out of range), 插入临界值</li>
<li>int(长度), 不设置长度, 有默认长度, 长度的含义是显示的最大宽度, 不是范围, 可用zerofill 表示0填充, 此时为无符号</li>
</ul>
</li>
</ul>
</li>
<li><p>小数：</p>
<table>
<thead>
<tr>
<th align="center">浮点数类型</th>
<th align="center">字节数</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="left">很大</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="left">很大</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">定点型类型</th>
<th align="center">字节数</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dec(M,D) | decimal(M,D)</td>
<td align="center">M+2</td>
<td align="center">最大取值范围和double相同, 给定decimal的有效取值范围由M和D决定</td>
</tr>
<tr>
<td align="center">- 定点型的小数精度更高</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">- M, D的含义</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tabFloat(</span><br><span class="line">    f1 <span class="built_in">float</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    f2 <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    f3 <span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>M 表示整数部分加小数部分的总长度, 超过范围插入临界值</li>
<li>D 表示小数点后的位数, 不够用0补</li>
<li>M 和 D 都可以省略, decimal 默认为(10,0), float, double则根据插入值的精度来决定, 只要在取值范围内即可</li>
<li>定点型的精度较高, 如果要求插入数精度较高时才使用</li>
<li>优先选用占用空间小的和简单的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>字符型：</p>
<ul>
<li>较短的文本:<table>
<thead>
<tr>
<th align="center">字符串类型</th>
<th align="center">最多字符数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char(M)</td>
<td align="center">M</td>
<td align="left">固定长度 M: 0~255 效率稍高</td>
</tr>
<tr>
<td align="center">varchar(M)</td>
<td align="center">M</td>
<td align="left">可变长度 M: 0~65535 效率稍低</td>
</tr>
<tr>
<td align="center">- char 的 M 可以省略, 默认为1</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">- varchar 的 M 不可以省略</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">- 其他:</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">- Enum类, 枚举类型, 要求插入的值必须是列表中指定的值, 否则报错, 不区分大小写</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">- Set 类, 类似枚举, 枚举只能插入1个值, set可以插入多个值</td>
<td align="center"></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
<li>较长的文本:<ul>
<li>text</li>
<li>blob(较长的二进制数据)</li>
</ul>
</li>
</ul>
</li>
<li><p>日期型：</p>
<ol>
<li>date: 4个字节, 只能保存日期 2010-01-10</li>
<li>datetime: 8个字节, 保存日期和时间 2010-01-10 00:00:00</li>
<li>timestamp: 4个字节, 时间戳 20100110000000</li>
<li>time: 3个字节, 只有时间 21:22:00</li>
<li>year: 1个字节, 只有年份 2020</li>
</ol>
</li>
</ol>
<ul>
<li><p>timestamp 和 datetime 的区别</p>
<ul>
<li>timestamp 的范围较小, 19700101080001–2038年的某个时间</li>
<li>datetime 范围: 1000-1-1 – 9999-1-1</li>
<li>timestamp 和实际时区有关,能反映实际日期, 而datetime只能反映插入时的当地时区</li>
<li>timestamp的属性首MySQL版本和语法的影响很大</li>
</ul>
</li>
<li><p>插曲</p>
<ul>
<li>show variables like ‘time_zone’; 查看当前时区</li>
<li>set time_zone=’+9:00’; 设置时区为东9区</li>
</ul>
</li>
</ul>
<h3 id="6-常见约束"><a href="#6-常见约束" class="headerlink" title="6.常见约束"></a>6.常见约束</h3><ul>
<li><p>常见约束</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">NOT NULL     <span class="comment"># 非空约束, 该字段的值不能为空, 比如姓名,学号</span></span><br><span class="line">DEFAULT      <span class="comment"># 默认约束, 保证该字段的值有默认值, 比如性别</span></span><br><span class="line">UNIQUE       <span class="comment"># 唯一约束, 保证该字段唯一, 可以为空, 比如座位号</span></span><br><span class="line"><span class="keyword">CHECK</span>        <span class="comment"># 检查约束,(MySQL不支持, 加上没效果)</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span>  <span class="comment"># 主键约束, 该字段为主键, 具有唯一性并且非空, 比如序号</span></span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>  <span class="comment"># 外键约束, 限制两个表的关系, 在从表添加外键约束</span></span><br><span class="line">             <span class="comment"># 用于保证该字段的值必须来自主表的关联列的值, 比如学生表的专业编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名 字段类型 列级约束,</span><br><span class="line">    字段名 字段类型,</span><br><span class="line">    表级约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加约束的时机:</p>
<ol>
<li>创建表时</li>
<li>修改表时</li>
</ol>
</li>
<li><p>约束的分类:</p>
<ol>
<li>列级约束: 6大约束语法上都支持, 但外键约束没有效果</li>
<li>表级约束: 除了非空, 默认约束, 其他都支持<ul>
<li>语法: [constraint 约束名] 约束类型(字段名); 约束名m默认为字段名</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列级约束</span></span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">      <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">      stuName <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">      gender <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender <span class="keyword">IN</span> (<span class="string">'男'</span>,<span class="string">'女'</span>)),</span><br><span class="line">      seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">      age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">      majorId <span class="built_in">INT</span> <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表级约束</span></span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stu(</span><br><span class="line">      <span class="keyword">id</span> <span class="built_in">INT</span>  PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">      sName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">      gender <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">      seat <span class="built_in">INT</span>,</span><br><span class="line">      age <span class="built_in">INT</span>,</span><br><span class="line">      majorId <span class="built_in">INT</span>,</span><br><span class="line">      <span class="comment"># 表级约束</span></span><br><span class="line">      <span class="keyword">CONSTRAINT</span> uq <span class="keyword">UNIQUE</span>(seat), <span class="comment"># 唯一键</span></span><br><span class="line">      <span class="keyword">CONSTRAINT</span> ck <span class="keyword">CHECK</span>(gender <span class="keyword">IN</span>(<span class="string">'女'</span>,<span class="string">'男'</span>)),</span><br><span class="line">      <span class="keyword">CONSTRAINT</span> fk_stu_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorId) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>) <span class="comment"># 外键</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 通用写法</span></span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> stuinfo(</span><br><span class="line">      <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">      sName <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">      gender <span class="built_in">char</span>(<span class="number">1</span>),</span><br><span class="line">      age <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">18</span>,</span><br><span class="line">      <span class="keyword">set</span> <span class="built_in">int</span> <span class="keyword">unique</span>,</span><br><span class="line">      majorId <span class="built_in">int</span>,</span><br><span class="line">      <span class="keyword">constraint</span> fk_stuinfo_major <span class="keyword">foreign</span> <span class="keyword">key</span>(majorId)</span><br><span class="line">      <span class="keyword">references</span> major(<span class="keyword">id</span>)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键约束和唯一约束的区别:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">保证唯一性</th>
<th align="center">是否可以为空</th>
<th align="center">一个表中可以存在</th>
<th align="center">是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键约束</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">至多1个</td>
<td align="center">允许, 但不推荐</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">可以多个</td>
<td align="center">允许, 但不推荐</td>
</tr>
</tbody></table>
</li>
<li><p>外键的特点</p>
<ol>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要一致或兼容, 名称无所谓</li>
<li>主表的关联列必须是一个key(一般是主键或唯一键)</li>
<li>插入数据时, 先插入主表, 再插入从表, 删除数据时, 先删除从表, 再删除主表</li>
</ol>
</li>
<li><p>标识列 – 自增长列(auto_increment)</p>
<ul>
<li><p>从1开始, 每次增长1</p>
</li>
<li><p>标识列不一定是主键, 但是必须是一个key</p>
</li>
<li><p>一个表中至多有1个自增长列</p>
</li>
<li><p>标识列的类型必须是数值型(int, float, double)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时设置标识列</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> AUTO_INCREMENT, <span class="comment">-- 自增长, 从1开始</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 此时再执行 insert 时, 每次插入数据时, id可以传null, 每次会自动增长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%auto_increment%'</span> ; <span class="comment">-- 查看增长的初始值和步长</span></span><br><span class="line"><span class="comment">-- 步长可以修改, set auto_increment=3;  一般不改</span></span><br><span class="line"><span class="comment">-- 初始值不可以修改, 默认为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表时设置标识列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab <span class="keyword">modify</span> <span class="keyword">colum</span> <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除标识列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab <span class="keyword">modify</span> <span class="keyword">colum</span> <span class="keyword">id</span> <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="5-数据库事务"><a href="#5-数据库事务" class="headerlink" title="5.数据库事务"></a>5.数据库事务</h2><p>一个或一组sql语句组成一个执行单元, 这个执行单元要么全都执行成功, 要么全部执行失败</p>
<ul>
<li>TCL 事务控制语言</li>
</ul>
<h3 id="1-含义"><a href="#1-含义" class="headerlink" title="1.含义"></a>1.含义</h3><ul>
<li><p>通过一组逻辑操作单元(一组DML——sql语句)，将数据从一种状态切换到另外一种状态</p>
</li>
<li><p>不同的存储引擎的处理方式不同, 通过<code>show engines;</code>查看数据库支持的引擎</p>
</li>
<li><p>MySQL 中用的最多的是Innodb, myisam, memory等,  其中 Innodb支持事务, 其他2个不支持</p>
</li>
</ul>
<h3 id="2-事务的特点"><a href="#2-事务的特点" class="headerlink" title="2.事务的特点"></a>2.事务的特点</h3><ul>
<li><p>事务的(ACID)属性</p>
<ul>
<li>原子性(Atomicity)：要么都执行，要么都回滚</li>
<li>一致性(Consistency)：保证数据的状态操作前和操作后保持一致</li>
<li>隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</li>
<li>持久性(Durability)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</li>
</ul>
</li>
<li><p>相关步骤：</p>
<ol>
<li>开启事务</li>
<li>编写事务的一组逻辑操作单元(多条sql语句)</li>
<li>提交事务或回滚事务</li>
</ol>
</li>
</ul>
<h3 id="3-事务的分类"><a href="#3-事务的分类" class="headerlink" title="3.事务的分类"></a>3.事务的分类</h3><ul>
<li>隐式事务，没有明显的开启和结束事务的标志<ul>
<li>比如 : insert. update. delete语句就是一个隐式事务</li>
</ul>
</li>
<li>显式事务，具有明显的开启和结束事务的标志<ol>
<li>开启事务: 取消自动提交事务的功能</li>
<li>编写事务的一组逻辑操作单元(多条sql语句), insert | update | delete  </li>
<li>提交事务或回滚事务</li>
</ol>
</li>
</ul>
<h3 id="4-使用到的关键字"><a href="#4-使用到的关键字" class="headerlink" title="4.使用到的关键字"></a>4.使用到的关键字</h3><ul>
<li><p>关键字</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'autocommit'</span>; <span class="comment">-- 查看自动提交属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>; <span class="comment">-- 禁用自动提交, 只对当前会话有效, 每个事务开始前都要写</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>; <span class="comment">-- 开启事务(可选的)</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">savepoint</span>  断点名 <span class="comment">-- 设置保存点</span></span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">to</span> 断点名  <span class="comment">-- 提交到保存点</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 断点名 <span class="comment">-- 回滚到保存点的状态</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h3><ul>
<li><p>事务并发问题如何发生？<br>当多个事务同时操作同一个数据库的相同数据时</p>
</li>
<li><p>事务的并发问题有哪些？  </p>
<ul>
<li><strong>脏读</strong>：一个事务读取到了另外一个事务未提交的数据</li>
<li><strong>不可重复读</strong>：同一个事务中，多次读取到的数据不一致(强调的是另一个表的<strong>更新</strong>数据被读取到)</li>
<li><strong>幻读</strong>：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据(强调的是另一个表的<strong>插入</strong>数据被读取到)</li>
</ul>
</li>
<li><p>如何避免事务的并发问题？  </p>
<ul>
<li>通过设置事务的隔离级别<ol>
<li>READ UNCOMMITTED</li>
<li>READ COMMITTED 可以避免脏读(Oracle默认)</li>
<li>REPEATABLE READ 可以避免脏读. 不可重复读和一部分幻读(MySQL默认)</li>
<li>SERIALIZABLE可以避免脏读. 不可重复读和幻读</li>
</ol>
</li>
</ul>
</li>
<li><p>设置隔离级别：</p>
<ul>
<li><code>set session | global  transaction isolation level 隔离级别名;</code></li>
</ul>
</li>
<li><p>查看隔离级别：</p>
<ul>
<li><code>select @@tx_isolation;</code>  </li>
</ul>
</li>
</ul>
<h2 id="6-视图"><a href="#6-视图" class="headerlink" title="6.视图"></a>6.视图</h2><ul>
<li><p>含义：理解成一张虚拟的表, 和普通的表一样使用<br>通过表动态生成的数据, 只保存sql逻辑, 不保存查询结果</p>
</li>
<li><p>视图和表的区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">使用方式</th>
<th align="center">占用物理空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">视图</td>
<td align="center">完全相同</td>
<td align="center">不占用，仅仅保存的是sql逻辑</td>
</tr>
<tr>
<td align="center">表</td>
<td align="center">完全相同</td>
<td align="center">占用</td>
</tr>
</tbody></table>
</li>
<li><p>应用场景</p>
<ol>
<li>多个地方用到相同的查询结果</li>
<li>该查询结果的sql语句复杂</li>
</ol>
</li>
<li><p>视图的好处：</p>
<ol>
<li>sql语句提高重用性，效率高</li>
<li>和表实现了分离，保护数据, 提高了安全性  </li>
</ol>
</li>
</ul>
<h3 id="1-视图的创建"><a href="#1-视图的创建" class="headerlink" title="1.视图的创建"></a>1.视图的创建</h3><ul>
<li>语法：<code>CREATE VIEW  视图名  AS 查询语句;</code></li>
</ul>
<h3 id="2-视图的增删改查"><a href="#2-视图的增删改查" class="headerlink" title="2.视图的增删改查"></a>2.视图的增删改查</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 查看视图的数据</span></span><br><span class="line">    - <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_v4;</span><br><span class="line">    - <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_v1 <span class="keyword">WHERE</span> last_name=<span class="string">'Partners'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 插入视图的数据</span></span><br><span class="line">    - <span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_v4(last_name,department_id) <span class="keyword">VALUES</span>(<span class="string">'虚竹'</span>,<span class="number">90</span>); <span class="comment">-- 会对原始表插入数据, 没提提供的自动为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 修改视图的数据</span></span><br><span class="line">    - <span class="keyword">UPDATE</span> my_v4 <span class="keyword">SET</span> last_name =<span class="string">'梦姑'</span> <span class="keyword">WHERE</span> last_name=<span class="string">'虚竹'</span>; <span class="comment">-- 会对原始表更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 删除视图的数据</span></span><br><span class="line">    - <span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_v4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 一般是不会更新的</span></span><br></pre></td></tr></table></figure>

<h3 id="3-某些视图不能更新"><a href="#3-某些视图不能更新" class="headerlink" title="3.某些视图不能更新"></a>3.某些视图不能更新</h3><ul>
<li><p>包含以下关键字的sql语句：分组函数. distinct. group  by. having. union或者union all</p>
<ul>
<li>常量视图</li>
<li>Select中包含子查询</li>
<li>join</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- eg 不能更新的视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> myv1</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">Max</span>(salary), dept_id</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2 常量视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> myv2</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'john'</span> <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3 包含子查询</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> myv3</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> emps) maxSalary;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4 join</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> myv4</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> lastName, dept_name</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">on</span> emp.id = dept.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5 form一个不能更新的视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> myv5</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> myv2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6 where子句的子查询引用了from子句中的表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> myv6</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, email, salary</span><br><span class="line"><span class="keyword">from</span> emps</span><br><span class="line"><span class="keyword">where</span> empId <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span>  managerId</span><br><span class="line">    <span class="keyword">from</span> emps</span><br><span class="line">    <span class="keyword">where</span> managerId <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-视图逻辑的更新"><a href="#4-视图逻辑的更新" class="headerlink" title="4.视图逻辑的更新"></a>4.视图逻辑的更新</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方式一：</span></span><br><span class="line"><span class="comment">-- 创建或修改视图名, 如果视图名存在则修改, 不存在则创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> test_v7</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id&gt;<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式二:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> test_v7</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test_v7;</span><br></pre></td></tr></table></figure>

<h3 id="5-视图的删除"><a href="#5-视图的删除" class="headerlink" title="5.视图的删除"></a>5.视图的删除</h3><ul>
<li>DROP VIEW test_v1,test_v2,test_v3;</li>
</ul>
<h3 id="6-视图结构的查看"><a href="#6-视图结构的查看" class="headerlink" title="6.视图结构的查看"></a>6.视图结构的查看</h3><ul>
<li>DESC  test_v7;</li>
<li>SHOW CREATE VIEW test_v7;</li>
</ul>
<h2 id="7-存储过程"><a href="#7-存储过程" class="headerlink" title="7.存储过程"></a>7.存储过程</h2><ul>
<li>含义：一组经过预先编译的sql语句的集合, 类似Java中的方法</li>
<li>好处：<ol>
<li>提高了sql语句的重用性，减少了开发程序员的压力</li>
<li>简化操作</li>
<li>减少了编译次数和数据库的连接数, 提高了效率</li>
</ol>
</li>
<li>分类：<ol>
<li>无返回无参</li>
<li>仅仅带in类型，无返回有参</li>
<li>仅仅带out类型，有返回无参</li>
<li>既带in又带out，有返回有参</li>
<li>带inout，有返回有参<blockquote>
<p>注意：in. out. inout都可以在一个存储过程中带多个</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="1-创建存储过程"><a href="#1-创建存储过程" class="headerlink" title="1.创建存储过程"></a>1.创建存储过程</h3><ul>
<li><p>语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名(<span class="keyword">in</span>|<span class="keyword">out</span>|inout 参数名  参数类型,...)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    存储过程体</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数列表：</p>
<ul>
<li>参数模式, 参数名, 参数类型</li>
<li>举例:<br><code>in stuname varchar(20)</code></li>
</ul>
</li>
<li><p>注意</p>
<ol>
<li><p>需要设置新的结束标记<br>delimiter 新的结束标记</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"><span class="comment"># delimiter $</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT 参数名  参数类型,...)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">sql</span>语句<span class="number">1</span>;</span><br><span class="line">    sql语句2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end</p>
</li>
<li><p>参数前面的符号的意思  </p>
<ul>
<li>in:该参数只能作为输入 (该参数不能做返回值)</li>
<li>out：该参数只能作为输出(该参数只能做返回值)</li>
<li>inout：既能做输入又能做输出</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-调用存储过程"><a href="#2-调用存储过程" class="headerlink" title="2.调用存储过程"></a>2.调用存储过程</h3><ul>
<li><code>call 存储过程名(实参列表)</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 空参列表, 插入5条记录</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myp1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">admin</span>(username, <span class="keyword">password</span>)</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'john1'</span>,<span class="string">'0000'</span>),(<span class="string">'john2'</span>,<span class="string">'1111'</span>),(<span class="string">'john3'</span>,<span class="string">'2222'</span>),(<span class="string">'john4'</span>,<span class="string">'3333'</span>),(<span class="string">'john5'</span>,<span class="string">'4444'</span>)</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> myp1()$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 传入值</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myp2(<span class="keyword">in</span> beauty_name <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> bo.* <span class="keyword">from</span> boys bo</span><br><span class="line">    <span class="keyword">right</span> <span class="keyword">join</span> beauty b <span class="keyword">on</span> bo.id=b.boyfirend_id</span><br><span class="line">    <span class="keyword">where</span> b.name = beauty_name;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> myp2(<span class="string">'java'</span>)$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看用户是否登录成功</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myp3(<span class="keyword">in</span> username <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">in</span> <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">result</span></span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">admin</span></span><br><span class="line">    <span class="keyword">where</span> admin.username = username</span><br><span class="line">    <span class="keyword">and</span> admin.password=<span class="keyword">password</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> myp3(<span class="string">'cpp'</span>, <span class="string">'0000'</span>) $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myp4(<span class="keyword">in</span> username <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">in</span> <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">result</span></span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">admin</span></span><br><span class="line">    <span class="keyword">where</span> admin.username = username</span><br><span class="line">    <span class="keyword">and</span> admin.password=<span class="keyword">password</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">if</span>(<span class="keyword">result</span>&gt;<span class="number">0</span>, <span class="string">'成功'</span>,<span class="string">'失败'</span>);</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> myp4(<span class="string">'cpp'</span>, <span class="string">'0000'</span>) $</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 out 模式的参数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myp5(<span class="keyword">in</span> beautyname <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">out</span> boyname <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> bo.boyname <span class="keyword">into</span> boyname</span><br><span class="line">    <span class="keyword">from</span> boys bo</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> beauty b <span class="keyword">on</span> bo.id=b.boyfriend_id</span><br><span class="line">    <span class="keyword">where</span> b.name=beautyname;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @bname$</span><br><span class="line"><span class="keyword">call</span> myp5(<span class="string">'cpp'</span>, @bname)$</span><br><span class="line"><span class="keyword">select</span> @bname;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- inout 模式, 传入a, b, 返回a,b的2倍</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myp6(inout a <span class="built_in">int</span>, inout b <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">set</span> a=a*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">set</span> b=b*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @a=<span class="number">10</span>$</span><br><span class="line"><span class="keyword">set</span> @b=<span class="number">20</span>$</span><br><span class="line"><span class="keyword">call</span> myp6(@a, @b) $</span><br><span class="line"><span class="keyword">select</span> @a,@b</span><br></pre></td></tr></table></figure>

<h4 id="删除与查看存储过程"><a href="#删除与查看存储过程" class="headerlink" title="删除与查看存储过程"></a>删除与查看存储过程</h4><ul>
<li><code>drup procedure p1;</code> 一次只能删除一个</li>
<li><code>show create proecure p1;</code> 查看存储过程</li>
</ul>
<h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><h4 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1.创建函数"></a>1.创建函数</h4><ul>
<li><p>学过的函数：LENGTH. SUBSTR. CONCAT等</p>
</li>
<li><p>语法：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...) <span class="keyword">RETURNS</span> 返回类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    函数体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-调用函数"><a href="#2-调用函数" class="headerlink" title="2.调用函数"></a>2.调用函数</h4><ul>
<li>SELECT 函数名(实参列表)</li>
</ul>
<h4 id="3-函数和存储过程的区别"><a href="#3-函数和存储过程的区别" class="headerlink" title="3.函数和存储过程的区别"></a>3.函数和存储过程的区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">关键字</th>
<th align="center">调用语法</th>
<th align="center">返回值</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">函数</td>
<td align="center">function</td>
<td align="center">select 函数()</td>
<td align="center">有且仅有1个</td>
<td align="center">一般用于查询结果为一个值并返回时</td>
</tr>
<tr>
<td align="center">存储过程</td>
<td align="center">PROCEDURE</td>
<td align="center">CALL 存储过程()</td>
<td align="center">可以有0个或多个</td>
<td align="center">一般用于批量插入和更新</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例演示</span></span><br><span class="line"><span class="comment">-- 无参有返回</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> myf1() <span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> c <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>; <span class="comment">-- 定义局部变量</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> c</span><br><span class="line">    <span class="keyword">from</span> employees;</span><br><span class="line">    return c;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> myf1();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有参有返回</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> myf2(empName <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">returns</span> <span class="keyword">double</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">set</span> @sal=<span class="number">0</span>; <span class="comment">-- 用户变量</span></span><br><span class="line">    <span class="keyword">select</span> salary <span class="keyword">into</span> @sal</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">where</span> lastName=empName;</span><br><span class="line"></span><br><span class="line">    return @sal;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> myf2(<span class="string">'king'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查看和删除函数"><a href="#查看和删除函数" class="headerlink" title="查看和删除函数"></a>查看和删除函数</h4><ul>
<li><code>show create function myf3;</code> 查看函数</li>
<li><code>drop function myf3;</code>, 删除函数</li>
</ul>
<h2 id="8-流程控制结构"><a href="#8-流程控制结构" class="headerlink" title="8.流程控制结构"></a>8.流程控制结构</h2><h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1.系统变量"></a>1.系统变量</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h4><ul>
<li><p>作用域：针对于所有会话(连接)有效，但不能跨重启</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有全局变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span>;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%char%'</span>;</span><br><span class="line"><span class="comment">-- 查看指定的系统变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@global.autocommit;</span><br><span class="line"><span class="comment">-- 为某个系统变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> @@global.autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-会话变量"><a href="#2-会话变量" class="headerlink" title="2. 会话变量"></a>2. 会话变量</h4><ul>
<li><p>作用域：针对于当前会话(连接)有效</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SESSION</span> <span class="keyword">VARIABLES</span>;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SESSION</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%char%'</span>;</span><br><span class="line"><span class="comment">-- 查看指定的会话变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@autocommit;</span><br><span class="line"><span class="keyword">SELECT</span> @@session.tx_isolation;</span><br><span class="line"><span class="comment">-- 为某个会话变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> @@session.tx_isolation=<span class="string">'read-uncommitted'</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> tx_isolation=<span class="string">'read-committed'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2.自定义变量"></a>2.自定义变量</h3><h4 id="1-用户变量"><a href="#1-用户变量" class="headerlink" title="1. 用户变量"></a>1. 用户变量</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明并初始化：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @变量名=值;</span><br><span class="line"><span class="keyword">SET</span> @变量名:=值;</span><br><span class="line"><span class="keyword">SELECT</span> @变量名:=值;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋值：</span></span><br><span class="line"><span class="comment">-- 方式一：一般用于赋简单的值</span></span><br><span class="line"><span class="keyword">SET</span> 变量名=值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:=值;</span><br><span class="line"><span class="keyword">SELECT</span> 变量名:=值;</span><br><span class="line"><span class="comment">-- 方式二：一般用于赋表 中的字段值</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量</span><br><span class="line"><span class="keyword">FROM</span> 表;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用：</span></span><br><span class="line"><span class="keyword">select</span> @变量名;</span><br></pre></td></tr></table></figure>

<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明：</span></span><br><span class="line"><span class="keyword">declare</span> 变量名 类型 [<span class="keyword">default</span> 值];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋值：</span></span><br><span class="line"><span class="comment">-- 方式一：一般用于赋简单的值</span></span><br><span class="line"><span class="keyword">SET</span> 变量名=值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:=值;</span><br><span class="line"><span class="keyword">SELECT</span> 变量名:=值;</span><br><span class="line"><span class="comment">-- 方式二：一般用于赋表 中的字段值</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量</span><br><span class="line"><span class="keyword">FROM</span> 表;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用：</span></span><br><span class="line"><span class="keyword">select</span> 变量名</span><br></pre></td></tr></table></figure>

<ul>
<li>局部变量和用户变量二者的区别：</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">作用域</th>
<th align="left">定义位置</th>
<th align="left">语法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户变量</td>
<td align="left">当前会话</td>
<td align="left">会话的任何地方</td>
<td align="left">加@符号，不用指定类型</td>
</tr>
<tr>
<td align="left">局部变量</td>
<td align="left">定义它的BEGIN END中</td>
<td align="left">BEGIN END的第一句话</td>
<td align="left">一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<h3 id="3-分支结构"><a href="#3-分支结构" class="headerlink" title="3.分支结构"></a>3.分支结构</h3><h4 id="1-if函数"><a href="#1-if函数" class="headerlink" title="1. if函数"></a>1. if函数</h4><ul>
<li>语法：if(条件，表达式1，表达式2), 调用 <code>select if()</code><ul>
<li>如果条件成立,则返回表达式1的值, 否则返回表达式2的值</li>
</ul>
</li>
<li>特点：可以用在任何位置</li>
</ul>
<h4 id="2-case语句"><a href="#2-case语句" class="headerlink" title="2. case语句"></a>2. case语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="comment">-- 情况一：类似于switch</span></span><br><span class="line">case 变量|表达式|字段</span><br><span class="line">when 值1 then 结果1或语句1(如果是语句，需要加分号)</span><br><span class="line">when 值2 then 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">else 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">case</span>](如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 情况二：类似于多重if</span></span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">case</span>](如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要)</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：<ul>
<li>可以作为表达式, 嵌套在其他语句中使用, 可以放在任何位置</li>
<li>也可以作为独立的语句使用, 只能在begin end中</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 举例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test_case(<span class="keyword">in</span> score <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> score&gt;=<span class="number">90</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span> <span class="keyword">then</span> <span class="keyword">select</span> <span class="string">'A'</span>;</span><br><span class="line">    when score&gt;=80 then select 'B';</span><br><span class="line">    when score&gt;=60 then select 'C';</span><br><span class="line">    else <span class="keyword">select</span> <span class="string">'D'</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br></pre></td></tr></table></figure>

<h4 id="3-if-elseif语句"><a href="#3-if-elseif语句" class="headerlink" title="3. if elseif语句"></a>3. if elseif语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line">if 情况1 then 语句1;</span><br><span class="line">elseif 情况2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特点：只能用在begin end中！！！！！！</p>
</li>
<li><p>三者比较：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">应用场合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">if函数</td>
<td align="center">简单双分支</td>
</tr>
<tr>
<td align="center">case结构</td>
<td align="center">等值判断的多分支</td>
</tr>
<tr>
<td align="center">if结构</td>
<td align="center">区间判断的多分支</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-循环"><a href="#4-循环" class="headerlink" title="4.循环"></a>4.循环</h3><ul>
<li>分类: <strong>while</strong>, loop, repeat</li>
<li>循环控制:<br>iterate (continue)<br>leave (break)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. while 语法：</span></span><br><span class="line">[标签：]WHILE 循环条件  <span class="keyword">do</span></span><br><span class="line">    循环体;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span> [标签];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. loop , 默认死循环, 要搭配控制语句</span></span><br><span class="line">[标签：] loop</span><br><span class="line">    循环体;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">loop</span> [标签];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. repeat ( do while)</span></span><br><span class="line">[标签：] repeat</span><br><span class="line">    循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span> [标签];</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：  <ul>
<li>只能放在BEGIN END里面</li>
<li>如果要搭配leave跳转语句，需要使用标签，否则可以不用标签</li>
<li>leave类似于java中的break语句，跳出所在循环！！！</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 批量插入</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_while1(<span class="keyword">in</span> insertCount <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">    where i&lt;= insertCount do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">admin</span>(username, <span class="string">`password`</span>)</span><br><span class="line">        <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="string">'java'</span>,i), <span class="string">'asdf'</span>);</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_while1(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- eg2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_while2(<span class="keyword">in</span> insertCount <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">    a:where i&lt;= insertCount do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">admin</span>(username, <span class="string">`password`</span>) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="string">'cpp'</span>,i), <span class="string">'asdfasd'</span>);</span><br><span class="line">        if i&gt;=20 then leave a; end if;</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span> a;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_while2(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- eg3</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_while3(<span class="keyword">in</span> insertCount <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    a: where i&lt;= insertCount do</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">        if mod(i,2)!=0 then itreate a; <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">admin</span>(username, <span class="string">`password`</span>)</span><br><span class="line">        <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="string">'python'</span>,i), <span class="string">'assaddf'</span>);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span> a;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_while3(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaReview 笔记</title>
    <url>/posts/49e6f07c.html</url>
    <content><![CDATA[<h2 id="1-oop-learning-01"><a href="#1-oop-learning-01" class="headerlink" title="1. oop learning 01"></a>1. oop learning 01</h2><h3 id="1-1-OOP-thinking"><a href="#1-1-OOP-thinking" class="headerlink" title="1.1 OOP thinking"></a>1.1 OOP thinking</h3><ol>
<li>面向对象学习的3条主线<ol>
<li>Java类及类的成员： 成员变量, 方法, 构造器, 代码块, 内部类</li>
<li>面向对象的3大特征: 封装, 继承, 多态</li>
<li>其他关键字: this, super, static, final, abstract, interface, package, import,etc.  </li>
</ol>
</li>
<li>面向对象与面向过程  <ul>
<li>面向过程: 强调的是功能行为, 以函数为最小单位, 考虑怎么做</li>
<li>面向对象: 强调了具备功能的对象, 以类/对象为最小单位, 考虑谁来做</li>
</ul>
</li>
<li>面向对象分析方法问题的思路:  <ul>
<li>根据问题需要, 选择问题所针对的<strong>现实世界的实体</strong></li>
<li>从实体中寻找解决问题相关的属性和功能, 这些属性和功能构成了<strong>类</strong></li>
<li>把抽象的实体用计算机语言进行描述, 形成<strong>计算机世界中类的定义</strong>,即借助某种编程语言,把类构造成计算机能够识别和处理的数据结构</li>
<li>将<strong>类实例化成计算机世界中的对象</strong>, 对象是计算机世界中解决问题的最终工具  </li>
</ul>
</li>
<li>面向对象中两个重要概念<br> 类: 对一类事物的描述, 是抽象的, 概念上的定义<br> 对象: 对实际存在的该类事物的每个个体, 因此也称为实例(instance)<blockquote>
<p>面向对象程序设计的重点是类的设计<br>设计类, 就是设计类的成员</p>
</blockquote>
</li>
<li>面向对象思想规则落地的过程<ol>
<li>创建类, 设计类的成员</li>
<li>创建类的对象</li>
<li>调用对象的结构  <a id="more"></a>
<h3 id="1-2-对象内存解析"><a href="#1-2-对象内存解析" class="headerlink" title="1.2 对象内存解析"></a>1.2 对象内存解析</h3></li>
</ol>
</li>
</ol>
<ul>
<li>Heap:<ul>
<li>存放对象实例, 即所有new出来的东西(对象, 数组, 对象的属性(<em>非static的</em>)也加载在堆中)</li>
</ul>
</li>
<li>Stack:<ul>
<li>虚拟机栈, 用于存储局部变量等.  </li>
<li>局部变量表存放了编译期可知长度的各种基本数据类型,对象引用(reference类型,是对象在堆内存的首地址)</li>
<li>方法执行完自动释放</li>
</ul>
</li>
<li>Method Area<ul>
<li>存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据,<br>简单来说就是类的加载信息, 常量池, 静态域  </li>
</ul>
</li>
</ul>
<h3 id="1-3-属性与局部变量的对比"><a href="#1-3-属性与局部变量的对比" class="headerlink" title="1.3 属性与局部变量的对比"></a>1.3 属性与局部变量的对比</h3><p>成员变量(属性)    vs    局部变量(方法内, 方法形参, 构造器内, 构造器形参, 代码块内 )</p>
<ol>
<li><p>相同点</p>
<ol>
<li>声明格式相同</li>
<li>先声明, 后使用</li>
<li>变量都有对应的作用域</li>
</ol>
</li>
<li><p>不同点:</p>
<ol>
<li>在类中声明的位置不同<br>成员变量(属性): 直接定义在类的一对{}内<br>局部变量: 声明在方法内, 方法形参, 代码块内, 构造器形参, 构造器内部变量</li>
<li>权限修饰符的不同<br>成员变量(属性): 可以在声明属性时, 指明其权限, 使用权限修饰符<br>局部变量: 不可以使用权限修饰符  </li>
<li>默认初始化值:<br>成员变量(属性): 根据其类型, 有默认初始化值({byte, short, int, long : 0}, {float, double : 0.0}, {char : 0(‘\u0000’)}, {boolean : flase})<br>局部变量: 没有默认初始化值, 在调用前必须手动初始化(形参可以在调用时进行赋值)</li>
<li>在内存中加载的位置:<br>成员变量(属性): 加载到堆空间中(非static)<br>局部变量: 加载到栈空间</li>
</ol>
</li>
</ol>
<h3 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h3><h4 id="1-方法声明"><a href="#1-方法声明" class="headerlink" title="1. 方法声明"></a>1. 方法声明</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">      方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>权限修饰符<ul>
<li>private</li>
<li>public</li>
<li>缺省(protected)</li>
</ul>
</li>
<li>返回值类型<ul>
<li>有返回值: 必须在方法声明时指定返回值的类型, 用return关键字返回数据</li>
<li>无返回值: void</li>
</ul>
</li>
</ul>
<h4 id="2-方法的使用"><a href="#2-方法的使用" class="headerlink" title="2. 方法的使用"></a>2. 方法的使用</h4><ul>
<li>在方法中可以调用当前类的成员变量(属性)或方法</li>
<li>方法中不可以定义新的方法  </li>
</ul>
<h3 id="1-5-“万事万物皆对象”"><a href="#1-5-“万事万物皆对象”" class="headerlink" title="1.5 “万事万物皆对象”"></a>1.5 “万事万物皆对象”</h3><ol>
<li>在Java语言中, 将功能,结构等封装到实体类中, 通过类的实例化, 来调用具体的功能结构.</li>
<li>涉及到Java语言与前端HTML, 后端的数据库交互时, 前后端的结构在Java层面交互时, 都体现为类与对象.  </li>
</ol>
<h3 id="1-6-匿名对象"><a href="#1-6-匿名对象" class="headerlink" title="1.6 匿名对象"></a>1.6 匿名对象</h3><ol>
<li><p>匿名对象的使用  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        p.sendEmail();</span><br><span class="line">        p.playGame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象, 只能调用一次, 没有显式的变量名</span></span><br><span class="line">        <span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line">        <span class="keyword">new</span> Phone().playGame();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">        <span class="keyword">new</span> Phone().showPrice(); <span class="comment">// 0.0</span></span><br><span class="line"></span><br><span class="line">        PhoneFactory pf = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">        pf.show(<span class="keyword">new</span> Phone());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send emails"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play games"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"price is "</span> + <span class="keyword">this</span>.price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">        phone.showPrice();</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-7-方法重载overload"><a href="#1-7-方法重载overload" class="headerlink" title="1.7 方法重载overload"></a>1.7 方法重载overload</h3><ul>
<li>在一个类中, 允许存在一个以上的同名方法, 只要他们的参数个数或者参数类型不同即可<ul>
<li><strong>“两同一不同”</strong> : 同一个类, 相同方法名<br>参数列表不同, 参数个数不同, 参数类型不同</li>
<li>与方法的权限修饰符, 返回值类型, 形参变量名, 方法体均无关  </li>
</ul>
</li>
<li>通过对象调用方法时, 在编译期就会确定是具体调用哪个方法<ul>
<li>方法名 –&gt; 参数列表  </li>
</ul>
</li>
</ul>
<h3 id="1-8-可变个数的形参"><a href="#1-8-可变个数的形参" class="headerlink" title="1.8 可变个数的形参"></a>1.8 可变个数的形参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可变个数形参的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. jdk 5.0 新增的内容</span></span><br><span class="line"><span class="comment"> * 2. 具体使用</span></span><br><span class="line"><span class="comment"> *    1. 可变个数的形参格式: 数据类型... 变量名</span></span><br><span class="line"><span class="comment"> *    2. 调用可变个数形参的方法时, 传入的参数的个数可以是 0,1,2..</span></span><br><span class="line"><span class="comment"> *    3. 可变个数形参的方法与本类中方法名相同, 形参列表不同的方法之间构成重载  </span></span><br><span class="line"><span class="comment"> *    4. 可变个数形参的方法与本类中方法名形态, 形参类型相同的数组之间不构成重载, 即不能共存</span></span><br><span class="line"><span class="comment"> *    5. 可变个数形参在方法形参中必须声明在末尾, 且只能有一个</span></span><br><span class="line"><span class="comment"> * 3. 应用场景</span></span><br><span class="line"><span class="comment"> *    在写SQL语句时, 查询语句的条件不知道具体是几个, 可用可变参数接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodArgsTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MethodArgsTest test = <span class="keyword">new</span> MethodArgsTest();</span><br><span class="line">        test.show(<span class="number">12</span>);</span><br><span class="line">        test.show(<span class="string">"hellos"</span>);</span><br><span class="line">        test.show(<span class="string">"hellos"</span>, <span class="string">"worlds"</span>, <span class="string">"shows"</span>);</span><br><span class="line">        test.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show(int i)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show(String s)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String... strs)</span></span>&#123; <span class="comment">// 可变个数的形参</span></span><br><span class="line">        System.out.println(<span class="string">"show(String... strs)"</span>);</span><br><span class="line">        <span class="comment">// strs 可看作String[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            System.out.println(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:<br>public void test(int a, int… arr); 与 public void test(int a, int[] arr);<br>编译器看来int… 与 int[] 是一样的  </p>
</blockquote>
<h3 id="1-9-方法参数的值传递机制"><a href="#1-9-方法参数的值传递机制" class="headerlink" title="1.9 方法参数的值传递机制"></a>1.9 方法参数的值传递机制</h3><ul>
<li><p>Java的实参值是如何传入方法的呢?</p>
<ul>
<li>Java中方法的参数传递只有一种方式: <strong>值传递</strong>.<br>即将实际参数值的副本传入方法内, 参数本身不受影响</li>
</ul>
</li>
<li><p>方法的形参的传递机制:  值传递</p>
<ul>
<li>形参是基本数据类型: 将实参基本数据类型变量的”==数据值==”传递给形参</li>
<li>形参是引用数据类型: 将实参引用数据类型变量的”==地址值==”传递给形参</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = m;</span><br><span class="line"></span><br><span class="line">        System.out.println(m, n); <span class="comment">// 10, 10</span></span><br><span class="line">        n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(m, n); <span class="comment">// 10, 20</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============="</span>);  </span><br><span class="line">        Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">        o1.id = <span class="number">1001</span>;</span><br><span class="line">        Order o2 = o1;</span><br><span class="line">        System.out.println(o1.id, o2.id); <span class="comment">// 1001, 1001</span></span><br><span class="line"></span><br><span class="line">        o2.id = <span class="number">1002</span>;</span><br><span class="line">        System.out.println(o1.id, o2.id);  <span class="comment">// 1002, 1002  </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-10-面向对象的三大特征之”封装和隐藏”"><a href="#1-10-面向对象的三大特征之”封装和隐藏”" class="headerlink" title="1.10 面向对象的三大特征之”封装和隐藏”"></a>1.10 面向对象的三大特征之”封装和隐藏”</h3><ul>
<li><p>程序设计追求”高内聚, 低耦合”</p>
<ul>
<li>高内聚 : 类的内部数据操作细节自己完成, 不允许外部干涉</li>
<li>低耦合 : 仅对外暴露少量的方法用于使用.  </li>
</ul>
</li>
<li><p>隐藏对象内部的复杂性, 只对外公开简单的接口. 便于外界调用, 从而提高系统的可扩展性、可维护性. 通俗的说,  把该隐藏的隐藏起来, 该暴露的暴露出来. 这就是封装性的设计思想.  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 封装性的体现:</span></span><br><span class="line"><span class="comment">*   将类的成员变量(属性)私有化(private), 同时, 提供共有的方法来获取和设置成员变量(属性)的值, 即getter和setter方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   拓展:</span></span><br><span class="line"><span class="comment">*   封装性的体现:</span></span><br><span class="line"><span class="comment">*     1. 上述</span></span><br><span class="line"><span class="comment">*     2. 不对外暴露的私有的方法</span></span><br><span class="line"><span class="comment">*     3. 单例模式(将构造器私有化)</span></span><br><span class="line"><span class="comment">* 2. 封装性的体现,需要权限修饰符配合</span></span><br><span class="line"><span class="comment">*    1. private, 缺省, protected, public</span></span><br><span class="line"><span class="comment">*      修饰符             类内部     同一个包    不同包的子类     同一个工程</span></span><br><span class="line"><span class="comment">*      private             y</span></span><br><span class="line"><span class="comment">*      缺省                y         y</span></span><br><span class="line"><span class="comment">*      protected           y         y            y</span></span><br><span class="line"><span class="comment">*      public              y         y            y             y</span></span><br><span class="line"><span class="comment">*    2. 对class的权限修饰只可以用public或缺省</span></span><br><span class="line"><span class="comment">*       public: 可以在任意地方被访问</span></span><br><span class="line"><span class="comment">*       缺省: 只可以北同一个包内部的类访问</span></span><br><span class="line"><span class="comment">*    3. 权限修饰符可以用来修饰类的内部结构, 成员变量(属性), 方法, 构造器, 内部类.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/29 23:10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">//        a.name = "dog";</span></span><br><span class="line"><span class="comment">//        a.age = 3;</span></span><br><span class="line">        a.setName(<span class="string">"dog"</span>);</span><br><span class="line">        a.setAge(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        a.legs = 4;</span></span><br><span class="line">        a.show();</span><br><span class="line"><span class="comment">//        a.legs = -2; // 不合逻辑</span></span><br><span class="line">        a.setLegs(-<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> legs; <span class="comment">// 私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> legs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (legs &gt;= <span class="number">0</span> &amp;&amp; legs % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.legs = legs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.legs = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat foods"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", legs="</span> + legs +</span><br><span class="line">                <span class="string">'&#125;'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-11-构造器"><a href="#1-11-构造器" class="headerlink" title="1.11 构造器"></a>1.11 构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造器(constructor) / 构造方法</span></span><br><span class="line"><span class="comment"> *   1. 作用:  创建对象; 初始化对象的成员变量(属性)</span></span><br><span class="line"><span class="comment"> *   2. 如果没有显式的定义构造方法, 系统会默认提供一个空参的构造方法</span></span><br><span class="line"><span class="comment"> *   3. 一个类中的多个构造方法构成重载</span></span><br><span class="line"><span class="comment"> *   4. 一旦提供了构造方法, 系统就不会提供默认的空参构造方法</span></span><br><span class="line"><span class="comment"> *   5. 一个类中至少有1个构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/1/30 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        p1.setName(<span class="string">"hee"</span>);</span><br><span class="line">        p1.setAge(<span class="number">10</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"java"</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        p2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>成员变量(属性)赋值的先后顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 成员变量(属性)赋值的先后顺序</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 1. 默认初始化</span></span><br><span class="line"><span class="comment">* 2. 显式初始化 / 代码块, 按书写的先后顺序赋值</span></span><br><span class="line"><span class="comment">* 3. 构造器中赋值</span></span><br><span class="line"><span class="comment">* 4. 通过"对象.方法", "对象.成员变量(属性)"赋值</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 以上操作的先后顺序: 1 --&gt; 2 --&gt; 3 --&gt; 4</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/30 10:29</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(u.age);</span><br><span class="line"></span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">        System.out.println(u2.age);</span><br><span class="line">        u2.setAge(<span class="number">4</span>);</span><br><span class="line">        System.out.println(u2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-12-Java-bean-与-一些关键字的使用"><a href="#1-12-Java-bean-与-一些关键字的使用" class="headerlink" title="1.12 Java bean 与 一些关键字的使用"></a>1.12 Java bean 与 一些关键字的使用</h3><ul>
<li><p>JavaBean是一种Java语言写成的可重用组件</p>
</li>
<li><p>JavaBean是指符合以下标准的Java类</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共构造器</li>
<li>有成员变量(属性), 且有对应的get,set方法  </li>
</ul>
</li>
<li><p>this 关键字的使用:</p>
<ul>
<li>this 可以修饰成员变量(属性), 方法, 构造器<ol>
<li>this 修饰成员变量(属性)和方法:<br>this 理解为当前对象或当前正在创建的对象</li>
<li>this 调用构造器: 可以调用本类中指定的其他构造器  <ul>
<li>this(); 调用空参的构造器</li>
<li>this(参数列表); 调用相应参数的构造器  </li>
<li>不能自己调用自己, 如果一个类中有n个构造器, 最多有n-1个构造器中调用this(形参列表)</li>
<li>this(形参类别) 必须声明在当前构造器首行  </li>
<li>构造器内部最多只能声明一个this() 用来调用其他构造方法</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>package 关键字的使用</p>
<ol>
<li>为了更好的实现项目中类的管理, 提供包的概念</li>
<li>使用package声明类或接口所属的包, 声明在源文件的首行</li>
<li>包: 属于标识符, 遵循标识符的命名规则,每”.”一次, 代表一层文件目录<ul>
<li>同一个包下, 不能命名同名的接口,类</li>
<li>不同的包下, 可以命名同名的接口,类</li>
</ul>
</li>
</ol>
</li>
<li><p>import 关键字的使用</p>
<ol>
<li>在源文件中显式的使用import导入指定包下的类或接口</li>
</ol>
</li>
</ul>
<h3 id="1-13-MVC设计模式初见"><a href="#1-13-MVC设计模式初见" class="headerlink" title="1.13 MVC设计模式初见"></a>1.13 MVC设计模式初见</h3><ul>
<li>MVC是常用的设计模式之一. 将程序分为三个层次: 视图模型层(Model), 控制器层(Controller), 数据模型层(View).</li>
<li>这种将程序输入输出, 数据处理, 以及数据的展示分离开的设计模式是程序结构变得灵活且清晰, 同时也描述了程序的各个对象见的通信方式, 降低了程序的耦合性</li>
<li><strong>模型层 model</strong> 主要处理数据<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li><strong>控制层 controller</strong> 处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
<li><strong>视图层 View</strong> 显示数据<ul>
<li>相关工具类 view.utils  </li>
</ul>
</li>
</ul>
<h2 id="2-oop-learning-02"><a href="#2-oop-learning-02" class="headerlink" title="2. oop learning 02"></a>2. oop learning 02</h2><h3 id="2-1-面向对象的三大特征之继承性-inheritance"><a href="#2-1-面向对象的三大特征之继承性-inheritance" class="headerlink" title="2.1 面向对象的三大特征之继承性(inheritance)"></a>2.1 面向对象的三大特征之继承性(inheritance)</h3><ul>
<li>继承性的好处:<ol>
<li>减少了代码的冗余</li>
<li>便于功能的扩展</li>
<li>为多态性的使用, 提供了前提</li>
</ol>
</li>
<li>继承性的格式: class A extends B{}<ul>
<li>A: 子类, 派生类, subclass</li>
<li>B: 父类, 超类, 基类, superclass</li>
<li>一旦子类A继承父类B后, 子类A中就获取了B中声明的所有结构(属性, 方法)<ul>
<li>特别的, 父类中声明为private的属性或方法, 子类继承父类后, 也认为获取了父类的私有的结构, 只是因为封装性,使得子类不能直接调用父类的结构而已</li>
</ul>
</li>
<li>子类继承父类后, 还可以定义或声明自己的结构,实现功能的扩展</li>
<li>子类和父类的关系, 不同于子集和集合的关系.</li>
</ul>
</li>
<li>Java只支持单继承和多层继承, 不允许多重继承<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
<li>子父类是相对的概念</li>
<li>Java.lang.Object类是所有Java类的共有父类</li>
</ul>
</li>
</ul>
<h3 id="2-2-方法重写-Override"><a href="#2-2-方法重写-Override" class="headerlink" title="2.2 方法重写(Override)"></a>2.2 方法重写(Override)</h3><ul>
<li>重写(override):<br>子类继承父类后,可以对父类中同名同参数的方法, 进行覆盖操作  </li>
<li>重写的规定:<ol>
<li>子类重写的方法名和形参列表与被重写的方法的方法名和形参列表相同</li>
<li>子类重写的方法的权限修饰符不小于父类被重写方法的权限修饰符<ul>
<li>特殊情况, 子类中不能重写父类中private的方法</li>
</ul>
</li>
<li>返回值类型:<br>父类被重写的方法的返回值类型是void, 子类重写的方法的返回值类型只能是void<br> 父类被重写的方法的返回值类型是A类, 子类重写的方法的返回值类型可以是A类或A类的子类<br> 父类被重写的方法的返回值类型是基本数据类型, 子类重写的方法的返回值类型必须是相同的基本数据类型  </li>
<li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</li>
</ol>
</li>
<li>子类和父类中同名同参数的方法要么都是非static的(考虑重写), 要么都是static的(不是重写)</li>
</ul>
<blockquote>
<p><strong>重写与重载的区别</strong>:</p>
<ol>
<li>从二者的定义细节：<br>重载:2同一不同; 重写: 上述4点</li>
<li>从编译和运行的角度看:<br>重载: 是指允许存在多个同名方法, 而这些方法的参数不同.  编译器根据方法不同的参数表, 对同名方法的名称做修饰. 对于编译器而言, 这些同名方法就成了不同的方法. 它们的调用地址在编译期就绑定了. Java的重载是可以包括父类和子类的, 即子类可以重载父类的同名不同参数的方法.<br>所以：对于重载而言, 在方法调用之前, 编译器就已经确定了所要调用的方法, 这称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”<br>而对于重写, 即表现为多态, 只有等到方法调用的那一刻, 解释运行器才会确定所要调用的具体方法, 这称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>” .<br>引用一句Bruce Eckel的话： “*<em>不要犯傻, 如果它不是晚绑定,  它就不是多态. *</em>”</li>
</ol>
</blockquote>
<h3 id="2-3-super关键字"><a href="#2-3-super关键字" class="headerlink" title="2.3 super关键字"></a>2.3 super关键字</h3><ul>
<li>super 可以调用属性, 方法, 构造器</li>
<li>可以在子类的方法或构造器中, 通过super.属性, super.方法, 调用父类中声明的属性或方法</li>
<li>super(形参列表) 调用父类中指定的构造器, 必须写在构造方法的第一行, 且不能与this共存</li>
<li>在构造器的首行, 没有显式的声明this(形参列表) 或super(形参列表) , 默认调用super()空参构造.</li>
<li>在类的多个构造器中, 至少有一个构造器中使用了”super(形参列表)”, 调用父类的构造方法  </li>
</ul>
<h3 id="2-4-子类对象实例化的全过程"><a href="#2-4-子类对象实例化的全过程" class="headerlink" title="2.4 子类对象实例化的全过程"></a>2.4 子类对象实例化的全过程</h3><ol>
<li>从结果上看, (继承性)<br> 子类继承父类后, 就获取了父类中声明的属性或方法<br> 创建子类的对象,在堆空间中就会加载所有父类中声明的属性</li>
<li>从过程上看<br> 通过子类的构造器创建子类对象时, 一定会直接或间接的调用父类的构造器, 进而调用父类的构造器, 直到调用了Object类的空参构造为止. 所以内存中会有父类的结构, 子类对象才可以考虑调用  <blockquote>
<p>注: 虽然创建子类对象时调用了父类的构造方法, 但是自始至终只创建过一个对象, 即new的那个子类对象  </p>
</blockquote>
</li>
</ol>
<h3 id="2-5-面向对象三大特征之多态-Polymorphism"><a href="#2-5-面向对象三大特征之多态-Polymorphism" class="headerlink" title="2.5 面向对象三大特征之多态(Polymorphism)"></a>2.5 面向对象三大特征之多态(Polymorphism)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多态性:</span></span><br><span class="line"><span class="comment"> *   1. 一个事物的多种形态</span></span><br><span class="line"><span class="comment"> *   2. 父类引用指向子类对象</span></span><br><span class="line"><span class="comment"> *   3. 调用子父类同名的方法时, 执行的时子类重写的方法 ---- 虚拟方法调用</span></span><br><span class="line"><span class="comment"> *      总结; 编译看左边, 运行看右边</span></span><br><span class="line"><span class="comment"> *   4. 多态的前提: 继承和重写</span></span><br><span class="line"><span class="comment"> *   5. 对象的多态性, 只适用于方法, 不适用于属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      虚拟方法调用(Virtual Method Invocation)</span></span><br><span class="line"><span class="comment"> *   正常的方法调用</span></span><br><span class="line"><span class="comment"> *      Person e = new Person();</span></span><br><span class="line"><span class="comment"> *      e.getInfo();</span></span><br><span class="line"><span class="comment"> *      Student e = new Student();</span></span><br><span class="line"><span class="comment"> *      e.getInfo();</span></span><br><span class="line"><span class="comment"> *   虚拟方法调用(多态情况下)</span></span><br><span class="line"><span class="comment"> *      子类中定义了与父类同名同参数的方法, 在多态情况下, 将此时父类的方法称为虚拟方法, 父类根据赋给它的不同子类对象, 动态调用属于子类的该方法. 这样的方法调用在编译期是无法确定的.</span></span><br><span class="line"><span class="comment"> *      Person e = new Student();</span></span><br><span class="line"><span class="comment"> *      e.getInfo(); //调用Student类的getInfo()方法</span></span><br><span class="line"><span class="comment"> *   编译时类型和运行时类型</span></span><br><span class="line"><span class="comment"> *      编译时e为Person类型, 而方法的调用是在运行时确定的, 所以调用的是Student类的getInfo()方法.  ——动态绑定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/1/30 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.eat();</span><br><span class="line"></span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        man.eat();</span><br><span class="line">        man.age = <span class="number">20</span>;</span><br><span class="line">        man.learn();</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Man(); <span class="comment">// 对象的多态</span></span><br><span class="line">        p2.eat();</span><br><span class="line">        p2.walk();</span><br><span class="line"><span class="comment">//        p2.learn(); 不能调用Man类独有的方法</span></span><br><span class="line">        Person p3 = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line">        System.out.println(p2.id); <span class="comment">// 1001, 父类的id</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-自动向下转型"><a href="#2-6-自动向下转型" class="headerlink" title="2.6 自动向下转型"></a>2.6 自动向下转型</h3><ul>
<li><p>在多态中如何调用子类特有的属性和方法?</p>
<ul>
<li><p>向下转型: 强制类型转换  </p>
<ul>
<li>使用强制类型转换时, 可能出现ClassCastException异常<ul>
<li>为了避免异常, 在转型前使用 instanceof 关键字判断</li>
<li>a instanceof A : 判断 a对象 是否是 A类的实例, 是返回true, 反之为false.</li>
<li>若 类B是A的父类, a instanceof A 返回true, 则a instanceof B 也返回true</li>
</ul>
</li>
<li>要求a所属的类与A类必须是子父类的关系, 否则编译报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译不过</span></span><br><span class="line">Man man = <span class="keyword">new</span> Woman(); <span class="comment">// 错</span></span><br><span class="line">String str = <span class="keyword">new</span> Date(); <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译可以通过, 但是运行会报错</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line">Man m1 = (Man)p1; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Man m2 = (Man)p2; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过, 运行也通过</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Woman();</span><br><span class="line">Person p = (Person)obj; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考查多态的题目：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Sub();</span><br><span class="line">        base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 此时是 sub_1  因为调用父类的虚方法, 执行的是子类重写后的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sub s = (Sub)base;</span></span><br><span class="line">    <span class="comment">// s.add(1,2,3); // sub_2 , 因为这是子类调用自己的方法, 优先选择确定参数的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] arr)</span> </span>&#123; <span class="comment">// int[] 与 int... 在编译器看来是一样的, 所以这里是重写</span></span><br><span class="line">        System.out.println(<span class="string">"sub_1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void add(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">// System.out.println("sub_2");</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-7-Object类的使用"><a href="#2-7-Object类的使用" class="headerlink" title="2.7 Object类的使用"></a>2.7 Object类的使用</h3><ul>
<li><p>Object类是所有Java类的根父类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        System.out.println(order.getClass().getSuperclass()); <span class="comment">// class java.lang.Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object类中的功能(属性, 方法)具有通用性</p>
<ul>
<li>只有一个空参构造器</li>
<li>clone() 方法, 克隆的方法</li>
<li>equals() 方法, 比较的方法</li>
<li>finalize() 方法, 垃圾回收时自动调用的方法, 建议不要主动调用该方法</li>
<li>getClass() 方法,  获取当前类</li>
<li>hashCode() 方法 返回对象的哈希值</li>
<li>toString() 方法</li>
<li>notify() 方法</li>
<li>notifyAll() 方法</li>
<li>wait() 方法</li>
</ul>
</li>
<li><p>重写equals方法:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* == 和 equals() 区别</span></span><br><span class="line"><span class="comment">*   一. 回顾 == :</span></span><br><span class="line"><span class="comment">*      == 运算符:</span></span><br><span class="line"><span class="comment">*        1. 可以使用在基本数据类型变量和引用数据类型变量中</span></span><br><span class="line"><span class="comment">*        2. 如果比较的是基本数据类型变量, 比较的是两个变量保存的数据是否相等(数据类型不一定相同)</span></span><br><span class="line"><span class="comment">*        3. 如果比较的是引用数据类型变量, 比较的是两个变量的地址是否相同</span></span><br><span class="line"><span class="comment">*   二. equals()方法</span></span><br><span class="line"><span class="comment">*     1. 是一个方法.</span></span><br><span class="line"><span class="comment">*     2. 只适用于引用数据类型</span></span><br><span class="line"><span class="comment">*     3. Object类中定义的equals方法</span></span><br><span class="line"><span class="comment">*           public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">*              return (this == obj);</span></span><br><span class="line"><span class="comment">*           &#125;</span></span><br><span class="line"><span class="comment">*       即Object类中的equals方法和 == 是一样的</span></span><br><span class="line"><span class="comment">*     4. 像String, date, File, 包装类等都重写了Object类中的equals()方法, 重写后比较的是两个对象的"属性内容"</span></span><br><span class="line"><span class="comment">*     5. 自定义类重写equals()方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 11:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">        System.out.println(i == j); <span class="comment">// true</span></span><br><span class="line">        System.out.println(i == d); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        System.out.println( b == i); // 基本数据类型运算跟boolean无关, 其他7种都可以用 == 进行比较</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">10</span>;</span><br><span class="line">        System.out.println(c == i); <span class="comment">// true</span></span><br><span class="line">        <span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">char</span> c2 = <span class="number">65</span>;</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"tom"</span>,<span class="number">21</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"tom"</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"java"</span>);</span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">        String str3 = <span class="string">"java"</span>;</span><br><span class="line">        String str4 = <span class="string">"java"</span>;</span><br><span class="line">        System.out.printf(<span class="string">"str1 == str3 ? %s \n"</span>, str1 == str3); <span class="comment">// false</span></span><br><span class="line">        System.out.printf(<span class="string">"str3 == str4 ? %s \n"</span>,str4 == str3); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"++++++++++++++++"</span>);</span><br><span class="line">        <span class="comment">// equals() 方法</span></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(p1.equals(p2)); <span class="comment">// 没重写equals的时候, false; 重写后: true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写toString() 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* toString() 方法</span></span><br><span class="line"><span class="comment">*  1. 输出一个对象的引用时, 是调用对象的 toString()方法</span></span><br><span class="line"><span class="comment">*  2. Object类的toString()方法</span></span><br><span class="line"><span class="comment">*     public String toString() &#123;</span></span><br><span class="line"><span class="comment">*         return getClass().getName() + "@" + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*  3. 像String, date, File, 包装类等都重写了Object类中的toString()方法, 返回"实体内容"信息</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 14:19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"java"</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(p1.toString()); <span class="comment">// 没重写的时候,cn.ckh.oop02.test3.Person@6039df1</span></span><br><span class="line">        System.out.println(p1); <span class="comment">// 没重写的时候,cn.ckh.oop02.test3.Person@6039df1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写toString() 后</span></span><br><span class="line">        System.out.println(p1); <span class="comment">// 自定义的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-8-包装类的使用"><a href="#2-8-包装类的使用" class="headerlink" title="2.8 包装类的使用"></a>2.8 包装类的使用</h3><ul>
<li><p>针对八种基本数据类型定义相应的引用数据类型– 包装类(封装类)</p>
</li>
<li><p>有了类的特点, 就可以调用类的方法</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">- 前6种包装类都是继承自Number类的子类</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>基本类型, 包装类与String类之间的转换</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 包装类的使用</span></span><br><span class="line"><span class="comment">* 1. Java提供的8种基本数据类型对于的包装类, 使得基本数据类型变量具有类的特征</span></span><br><span class="line"><span class="comment">* 2. 掌握基本数据类型, 包装类, String三者之间的转换</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 14:37</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型 --&gt; 包装类 : 调用包装类的构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        Integer integer = <span class="keyword">new</span> Integer(num1);</span><br><span class="line">        System.out.println(integer.toString()); <span class="comment">// 10</span></span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(integer1); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">//        Integer integer2 = new Integer("123av"); // 报异常</span></span><br><span class="line">        Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3f</span>);</span><br><span class="line">        Float f2 = <span class="keyword">new</span> Float(<span class="string">"12.3f"</span>);</span><br><span class="line">        System.out.println(f1); <span class="comment">// 12.3</span></span><br><span class="line">        System.out.println(f2); <span class="comment">// 12.3</span></span><br><span class="line"></span><br><span class="line">        Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">        Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">"true123"</span>); <span class="comment">// false, 因为Boolean进行过优化, 不是true都是false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装类 --&gt; 基本数据类型 : 调用包装类的xxxValue()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">int</span> i1 = in1.intValue();</span><br><span class="line">        System.out.println(i1 + <span class="number">1</span>); <span class="comment">// 13</span></span><br><span class="line">        Float aFloat = <span class="keyword">new</span> Float(<span class="number">12.3f</span>);</span><br><span class="line">        <span class="keyword">float</span> v = aFloat.floatValue();</span><br><span class="line">        System.out.println(v + <span class="number">1.1</span>); <span class="comment">// 13.4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * JDK 5.0新特性, 自动装箱与自动拆箱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        method(num1); <span class="comment">// int 自动装箱为 Integer, Integer --&gt; Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动装箱 : 基本数据类型 --&gt; 包装类</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">13</span>;</span><br><span class="line">        Integer in1 = num2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean b2 = b1; <span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动拆箱 : 包装类 --&gt; 基本数据类型</span></span><br><span class="line">        System.out.println(in1.toString()); <span class="comment">// 13</span></span><br><span class="line">        <span class="keyword">int</span> num3 = in1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型, 包装类 --&gt; String类</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 方式1: 加连接符</span></span><br><span class="line">        String str1 = num1 + <span class="string">""</span>; <span class="comment">// "10"</span></span><br><span class="line">        <span class="comment">// 方式2: String类的valueOf()方法</span></span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">        String s1 = String.valueOf(f1); <span class="comment">// "12.3"</span></span><br><span class="line"></span><br><span class="line">        Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">        String.valueOf(d1); <span class="comment">// "12.4"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String类 --&gt; 基本数据类型, 包装类 : 调用包装类的parseXXX()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//        int num1 = (int)str1; // 错误</span></span><br><span class="line"><span class="comment">//        Integer in1 = (Integer)str1; // 强转必有有子父类关系</span></span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(str1);</span><br><span class="line">        System.out.println(i+<span class="number">2</span>); <span class="comment">// 125</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">"true"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = Boolean.parseBoolean(s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b1; <span class="comment">// 默认为false</span></span><br><span class="line">    Boolean b2; <span class="comment">// 默认是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试题</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(o1); <span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为三元运算符要求,编译时":"前后的类型是统一的一个类型, 所以Integer对应的int类提升为double类型</span></span><br><span class="line"><span class="comment">    所以是 1.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(o2); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y); <span class="comment">// false 常量池的原因</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul>
<li><p>Java为很多基本类型的包装类/字符串都建立了常量池<br>常量池： 相同的值值存储一份, 节省内存, 共享访问  </p>
<ul>
<li><p>基本类型的包装类：(有常量池的)<br>Boolean, Byte, Short, Integer, Long, Character<br>Boolean: true, false<br>Byte: -128<del>127,<br>Character: 0</del>127<br>Short, Integer, Long: -128~127<br>Float,Double 没有缓存(常量池)  </p>
</li>
<li><p>常量式(字面量)赋值创建, 放在方法区常量池空间(将被常量化)<br>Integer a = 10;<br>String b = “abc”;<br>String e = “abc” + “defsf”;  </p>
</li>
<li><p>new 对象进行创建, 将放在堆空间(不会常量化)<br>Integer c = new Integer(10);<br>String d = new String(“abc”);  </p>
</li>
</ul>
</li>
</ul>
<h2 id="3-oop-learing-03"><a href="#3-oop-learing-03" class="headerlink" title="3. oop learing 03"></a>3. oop learing 03</h2><h3 id="3-1-static-关键字"><a href="#3-1-static-关键字" class="headerlink" title="3.1 static 关键字"></a>3.1 static 关键字</h3><ul>
<li><p>Static 关键字的使用</p>
<ol>
<li><p>static 静态的</p>
</li>
<li><p>static可以用来修饰: 成员变量(属性), 方法, 代码块, 内部类</p>
</li>
<li><p>使用static修饰成员变量(属性): 静态变量(类变量)</p>
<ul>
<li>成员变量(属性), 按是否使用static修饰, 又分为静态变量(类变量) 和 非静态变量(实例变量)</li>
<li>实例变量: 我们创建了一个类的多个对象, 每个对象独立拥有一套类中的非静态变量<br>当修改其中一个对象的非静态变量时,不会导致其他对象中的同样的变量值修改</li>
<li>静态变量: 我们创建了一个类的多个对象, 多个对象共同拥有同一个静态变量<br>当其中一个对象修改静态变量时,其他对象调用此静态变量时,是修改过的</li>
<li>static修饰成员变量(属性)的其他说明:<ul>
<li>静态变量随着类的加载而加载, 实例变量是随着对象的创建而加载的. 可通过”类名.静态变量名”调用</li>
<li>即静态变量的加载早于对象的创建</li>
<li>由于类只会加载一次, 则静态变量在内存中也只会存在一份, 存在方法区的静态域中.  <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类对象</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
<li>静态属性举例 : System.out, Math.PI,</li>
</ul>
</li>
</ul>
</li>
<li><p>使用static修饰方法: 静态方法</p>
<ul>
<li>随着类的加载而加载, 可以通过”类名.方法名”进行调用  <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类对象</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
<li>静态方法中, 只能调用静态的方法或属性</li>
<li>非静态方法中, 可以随便调用静态或非静态的方法和属性</li>
</ul>
</li>
<li><p>static 注意点<br> 在静态的方法中, 不能使用this和super关键字.<br> 因为这两个关键字都是基于当前对象的, 而静态方法加载时还没有对象</p>
<blockquote>
<p>可以从生命周期的角度理解</p>
</blockquote>
</li>
<li><p>在开发中如何确定一个属性是否要声明为static的?  </p>
<ul>
<li>属性是可以被多个对象所共享的, 不会随着对象的不同而不同  </li>
<li>类中的常量也常常声明为static  </li>
</ul>
</li>
<li><p>在开发中如何确定一个方法是否要声明为static的?</p>
<ul>
<li>操作静态属性的方法, 通常设置为static的</li>
<li>工具类中的方法, 通常设置为static的, 比如Math, Arrays, Collections</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="单例-Singleton-设计模式"><a href="#单例-Singleton-设计模式" class="headerlink" title="单例(Singleton)设计模式"></a>单例(Singleton)设计模式</h4><ul>
<li><p><strong>设计模式</strong>是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式.<br>设计模免去我们自己再思考和摸索. 就像是经典的棋谱, 不同的棋局, 我们用不同的”套路”</p>
</li>
<li><p>所谓类的单例设计模式, 就是采取一定的方法保证在整个的软件系统中, 对某个类<strong>只能存在一个对象实例</strong>, 并且该类只提供一个取得其对象实例的方法.<br>如果我们要让类在一个虚拟机中只能产生一个对象, 我们首先必须将类的构造器的访问权限设置为private, 这样, 就不能用new操作符在类的外部产生类的对象了, 但在类内部仍可以产生该类的对象.<br>因为在类的外部开始还无法得到类的对象, 只能调用该类的某个静态方法以返回类内部创建的对象, 静态方法只能访问类中的静态成员变量, 所以, 指向类内部产生的该类对象的变量也必须定义成静态的  </p>
<blockquote>
<p>设计模式:<br>创建型模式: 5种, 工厂方法模式, 抽象工厂模式, 单例模式, 建造者模式, 原型模式<br>结构型模式: 7种, 适配器模式, 装饰器模式, 代理模式, 外观模式, 桥接模式, 组合模式, 享元模式<br>行为型模式: 11种, 策略模式, 模板方法模式, 观察者模式, 迭代子模式, 责任链模式, 命令模式, 备忘录模式, 状态模式, 访问者模式, 中介者模式, 解释器模式</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单例设计模式:</span></span><br><span class="line"><span class="comment">*    1. 采取一定的方法保证在整个的软件系统中, 对某个类**只能存在一个对象实例**, 并且该类只提供一个取得其对象实例的方法.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    2. 如何实现?</span></span><br><span class="line"><span class="comment">*          饿汉式实现</span></span><br><span class="line"><span class="comment">*          懒汉式实现</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    3. 区分 饿汉式 和 懒汉式</span></span><br><span class="line"><span class="comment">*          饿汉式:</span></span><br><span class="line"><span class="comment">*            坏处: 对象加载时间过长</span></span><br><span class="line"><span class="comment">*            好处: 线程安全</span></span><br><span class="line"><span class="comment">*          懒汉式:</span></span><br><span class="line"><span class="comment">*            好处: 延迟对象的创建</span></span><br><span class="line"><span class="comment">*            坏处: 目前的写法是线程不安全的 --&gt; 到多线程内容时,再修改</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 饿汉式实现单例设计模式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/1/31 19:52</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank instance1 = Bank.getInstance();</span><br><span class="line">        Bank instance2 = Bank.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式 实现 单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 私有化类的构造器, 为了避免在外面造对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 内部创建类的对象</span></span><br><span class="line">    <span class="comment">// 4. 要求对象必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供公共的方法,返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式 实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 声明当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此对象必须为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 声明 public static 的返回当前类对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-2-理解main方法"><a href="#3-2-理解main方法" class="headerlink" title="3.2 理解main方法"></a>3.2 理解main方法</h3><ul>
<li><p>main()方法的使用说明:</p>
<ol>
<li><p>main()方法是程序的入口</p>
</li>
<li><p>main()方法也是一个普通的静态方法</p>
</li>
<li><p>main()方法也可以作为与控制台交互的方式(之前使用的是Scanner), 了解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main.main(<span class="keyword">new</span> String[<span class="number">10</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="comment">// 普通的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = <span class="string">"args_"</span> + i;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="3-3-代码块-初始化块"><a href="#3-3-代码块-初始化块" class="headerlink" title="3.3 代码块(初始化块)"></a>3.3 代码块(初始化块)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  代码块(初始化块)</span></span><br><span class="line"><span class="comment"> *    1. 代码块的作用: 用来初始化类或对象</span></span><br><span class="line"><span class="comment"> *    2. 只能用static修饰代码块, 即静态代码块, 与非静态代码块</span></span><br><span class="line"><span class="comment"> *    3. 静态代码块</span></span><br><span class="line"><span class="comment"> *       可以有输出语句</span></span><br><span class="line"><span class="comment"> *       随着类的加载而执行, 只执行一次</span></span><br><span class="line"><span class="comment"> *       作用: 初始化类的信息</span></span><br><span class="line"><span class="comment"> *       如果一个类中有多个静态代码块, 按先后顺序执行</span></span><br><span class="line"><span class="comment"> *       静态代码块先于非静态代码块执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4. 非静态代码块</span></span><br><span class="line"><span class="comment"> *       可以有输出语句</span></span><br><span class="line"><span class="comment"> *       随着对象的创建而执行, 每创建一个对象, 就执行一次</span></span><br><span class="line"><span class="comment"> *       作用: 可以在创建对象时, 对对象的属性进行初始化</span></span><br><span class="line"><span class="comment"> *       如果一个类中有多个非静态代码块, 按先后顺序执行</span></span><br><span class="line"><span class="comment"> *       非静态代码块中可以调用静态或非静态的方法和属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/1/31 20:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String desc = Person.desc;</span><br><span class="line"><span class="comment">//        Person.info();</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String desc = <span class="string">"i'm a person"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非static代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"instance initializer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static initializer"</span>);</span><br><span class="line">        desc = <span class="string">"i'm a good people"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-final-关键字"><a href="#3-4-final-关键字" class="headerlink" title="3.4 final 关键字"></a>3.4 final 关键字</h3><ul>
<li>final 关键字 : 最终的<ol>
<li>final 可以修饰 类, 方法, 变量</li>
<li>final 修饰类 : 此类不能被其他类所继承<br> 比如String, System, StringBuffer类</li>
<li>final 修饰方法 : 表明此方法不能被重写<br> 比如Object类的getClass()方法<br> (如果有native 关键字, 表明调用的是系统底层的方法)</li>
<li>finla 修饰变量: 此时的”变量”就称为常量, 不可以再次改变<ul>
<li>final 修饰成员变量(属性): 显式初始化, 代码块初始化, 构造器初始化</li>
<li>final 修饰局部变量:  <ul>
<li>尤其是final修饰形参时, 表明此形参是一个常量, 在调用方法时一旦赋值后, 在方法体内不能修改该参数</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>static final 修饰  <ul>
<li>成员变量(属性): 全局常量</li>
<li>方法</li>
</ul>
</li>
</ul>
<h3 id="3-5-抽象类与抽象方法"><a href="#3-5-抽象类与抽象方法" class="headerlink" title="3.5 抽象类与抽象方法"></a>3.5 抽象类与抽象方法</h3><ul>
<li><p>abstract 关键字</p>
<ol>
<li>用<code>abstract</code>关键字来修饰一个类,  这个类叫做<strong>抽象类</strong><ul>
<li>抽象类不能被实例化.</li>
<li>抽象类是用来被继承的, 抽象类的子类必须重写父类的抽象方法, 并提供方法体.</li>
<li>子类重写了父类所有的抽象方法后, 此子类方可实例化<br>若没有重写全部的抽象方法, 仍为抽象类</li>
<li>抽象类中可以定义构造器</li>
</ul>
</li>
<li>用<code>abstract</code>来修饰一个方法,  该方法叫做<strong>抽象方法</strong><ul>
<li>抽象方法：只有方法的声明, 没有方法的实现. 以分号结束：<br><code>public abstract void talk();</code></li>
<li>含有抽象方法的类必须被声明为抽象类, 反之, 抽象类中可以没有抽象方法</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>不能用<code>abstract</code>修饰 变量、代码块、构造器</strong></p>
</li>
<li><p><strong>不能用<code>abstract</code>修饰 私有方法、静态方法、 <code>final</code>的方法、 <code>final</code>的类</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A类中定义的m2方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B类中定义的m1方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.m1();</span><br><span class="line">        a.m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类的匿名子类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了一个匿名子类的对象,p</span></span><br><span class="line">    Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"AnnoTest.eat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"AnnoTest.walk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    p.eat();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="多态的应用-模板方法设计模式-TemplateMethod"><a href="#多态的应用-模板方法设计模式-TemplateMethod" class="headerlink" title="多态的应用: 模板方法设计模式(TemplateMethod)"></a>多态的应用: 模板方法设计模式(TemplateMethod)</h4><ul>
<li>抽象类体现的就是一种模板模式的设计, 抽象类作为多个子类的通用模板, 子类在抽象类的基础上进行扩展、改造, 但子类总体上会保留抽象类的行为方式.</li>
<li>解决的问题:<ul>
<li>当功能内部一部分实现是确定的,  一部分实现是不确定的. 这时可以把不确定的部分暴露出去, 让子类去实现</li>
<li>换句话说, 在软件开发中实现一个算法时, 整体步骤很固定、通用, 这些步骤已经在父类中写好了. 但是某些部分易变, 易变部分可以抽象出来, 供不同子类实现. 这就是一种模板模式</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类的应用, 模板方法的设计模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/2/1 13:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubTemplate t = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">        t.spendTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFlag)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算某段代码的执行时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">// 不确定的部分</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"spend time is (ms): "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-接口-interface"><a href="#3-6-接口-interface" class="headerlink" title="3.6 接口(interface)"></a>3.6 接口(interface)</h3><blockquote>
<p>接口就是规范, 定义的是一组规则, 体现了现实世界中“如果你是/要…则必须能…”的思想.  继承是一个”是不是”的关系, 而接口实现则是 “能不能”的关系.<br>接口的本质是契约, 标准, 规范, 就像我们的法律一样. 制定好后大家都要遵守.<br>有了接口, 就可以起到多继承的关系</p>
</blockquote>
<ul>
<li>接口(<code>interface</code>)是抽象方法和常量值定义的集合</li>
<li>接口的特点:<ul>
<li>用interface来定义</li>
<li>接口中的所有成员变量都<em>默认是由public static final</em>修饰的</li>
<li>接口中的所有抽象方法都<em>默认是由public abstract</em>修饰的</li>
<li><strong>接口中没有构造器</strong></li>
<li>接口采用多继承机制</li>
</ul>
</li>
<li>接口的使用<ol>
<li>使用interface 定义</li>
<li>Java中接口和类是并列的两个结构</li>
<li>定义接口<ol>
<li><strong>JDK7及以前</strong>, 只能定义全局常量和抽象方法<ul>
<li>全局常量 : public static final, 默认就是, 可以不写</li>
<li>抽象方法 : public abstract,  默认就是, 可以不写</li>
</ul>
</li>
<li><strong>JDK8</strong>: 除了定义全局常量和抽象方法, 还可以定义静态方法, 默认方法</li>
</ol>
</li>
<li>接口中不可以定义构造器, 即接口不可以实例化</li>
<li>Java开发中, 类通过实现(implements)接口, 来遵守接口中的规则<br> 如果实现类, 实现了接口中所有的抽象方法, 则该实现类可以实例化<br> 如果实现类, 有抽象方法没有实现, 则该实现类为抽象类</li>
<li>Java中可以实现多个接口, 实现了多继承</li>
<li>接口与接口之间也可以多继承  </li>
</ol>
</li>
</ul>
<h4 id="JDK8-接口特性"><a href="#JDK8-接口特性" class="headerlink" title="JDK8 接口特性"></a>JDK8 接口特性</h4><ul>
<li><p>除了定义全局常量和抽象方法, 还可以定义静态方法, 默认方法</p>
<ul>
<li><p>接口中定义的静态方法, 只能通过接口来调用, (类似工具类的用法)</p>
</li>
<li><p>通过实现类的对象, 可以调用接口中定义的默认方法</p>
</li>
<li><p>可以在实现类中重写接口的默认方法</p>
</li>
<li><p>如果子类(实现类) 继承的父类和实现的接口中定义了同名同参数的方法, 在子类没有重写该方法的前提下, 默认调用父类中的方法 <code>--&gt;</code> 类优先原则(针对方法)</p>
</li>
<li><p>如果实现类实现了多个接口, 多个接口中定义了同名同参数的默认方法, 在实现类没有重写此方法时, 报错 <code>--&gt;</code> 接口冲突 <code>--&gt;</code> 必须在实现类中重写此方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类(实现类)的方法中, 调用父类接口中重写的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"override method2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method2(); <span class="comment">// 自己重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method2(); <span class="comment">// 父类声明的同名方法</span></span><br><span class="line">        CompareA.<span class="keyword">super</span>.method2(); <span class="comment">// 调用接口中的同名默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="接口中的代理模式-Proxy-基础知识"><a href="#接口中的代理模式-Proxy-基础知识" class="headerlink" title="接口中的代理模式(Proxy)基础知识"></a>接口中的代理模式(Proxy)基础知识</h4><ul>
<li><p>代理模式是Java开发中使用较多的一种设计模式. 代理设计就是为其他对象提供一种代理以控制对这个对象的访问</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  接口的应用: 代理模式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/1 16:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line"></span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"真实的服务器访问网络"</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.work = work;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"check service"</span>);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        work.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<ul>
<li>安全代理： 屏蔽对真实角色的直接访问</li>
<li>远程代理： 通过代理类处理远程方法调用(RMI)</li>
<li>延迟加载： 先加载轻量级的代理对象,  真正需要再加载真实对象比如你要开发一个大文档查看软件,  大文档中有大的图片,  有可能一个图片有100MB,  在打开文件时,  不可能将所有的图片都显示出来,  这样就可以使用代理模式,  当需要查看图片时,  用proxy来进行大图片的打开</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>静态代理(静态定义代理类)</li>
<li>动态代理(动态生成代理类): JDK自带的动态代理,  需要反射等知识</li>
</ul>
</li>
</ul>
<h4 id="工厂模式简介"><a href="#工厂模式简介" class="headerlink" title="工厂模式简介"></a>工厂模式简介</h4><ul>
<li>工厂模式： 实现了创建者(new对象)与调用者的分离,  即将创建对象的具体过程屏蔽隔离起来, 达到提高灵活性的目的.</li>
<li>其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护, 解决方式就是一个“分工”</li>
<li>详见文档.</li>
</ul>
<h3 id="3-7-内部类"><a href="#3-7-内部类" class="headerlink" title="3.7 内部类"></a>3.7 内部类</h3><ul>
<li><p>内部类</p>
<ol>
<li><p>Java中允许将一个类A声明在类B中, 类A就是内部类, B称为外部类</p>
</li>
<li><p>内部类的分类:<br> 成员内部类: 静态与非静态成员内部类<br> 局部内部类: (方法内, 代码块内, 构造器内)</p>
</li>
<li><p>成员内部类:</p>
<ul>
<li><p>一方面, 作为外部类的成员  </p>
<ul>
<li>可以调用外部类的结构(在权限允许的情况下)</li>
<li>可以被static修饰</li>
<li>可以被权限修饰符修饰</li>
</ul>
</li>
<li><p>另一方面, 作为一个类  </p>
<ul>
<li>类内可以定义属性, 方法, 构造器等</li>
<li>可以被final修饰, 表示此类不能被继承, 即一般情况可以被继承</li>
<li>可以把abstract修饰</li>
</ul>
</li>
</ul>
</li>
<li><p>关注的点:</p>
<ol>
<li><p>如何实例化成员内部类的对象</p>
</li>
<li><p>如果在成员内部类中区分调用外部类的结构</p>
</li>
<li><p>开发中局部内部类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  内部类  1</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/2 11:22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建静态成员内部类实例</span></span><br><span class="line">        Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建非静态成员内部类实例</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Person.Cat cat = p.<span class="keyword">new</span> Cat();</span><br><span class="line">        cat.hana();</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        cat.display(<span class="string">"maomaoma"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Dog.show"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态成员内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">        String name = <span class="string">"cat"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hana</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Cat.hana"</span>);</span><br><span class="line">            Person.<span class="keyword">this</span>.eat(); <span class="comment">// 调用外部类的非静态属性</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"name = "</span> + name); <span class="comment">// 方法的形参</span></span><br><span class="line">            System.out.println(<span class="string">"this.name = "</span> + <span class="keyword">this</span>.name); <span class="comment">// 内部类的属性</span></span><br><span class="line">            System.out.println(<span class="string">"Person.this.name = "</span> + Person.<span class="keyword">this</span>.name); <span class="comment">// 外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开发中的应用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实现了Comparable接口的类,  局部内部类</span></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    方式二</span></span><br><span class="line"><span class="comment">//    return new Comparable() &#123;</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>内部类的加载顺序</p>
<ol>
<li>外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。</li>
<li>实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。</li>
<li>直接调用静态内部类时，外部类不会加载</li>
</ol>
</li>
</ul>
<h2 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h2><h3 id="4-1-异常处理概述"><a href="#4-1-异常处理概述" class="headerlink" title="4.1 异常处理概述"></a>4.1 异常处理概述</h3><ul>
<li>异常：在Java语言中, 将程序执行中发生的不正常情况称为”异常”(开发过程中的语法错误和逻辑错误不是异常)</li>
<li>Java程序在执行过程中所发生的异常事件可分为两类:  <ul>
<li><strong>Error</strong>： Java虚拟机无法解决的严重问题<br>如： JVM系统内部错误、 资源耗尽等严重情况. 比如：StackOverflowError和OOM.  <em>一般不编写针对性的代码进行处理</em>.</li>
<li><strong>Exception</strong>: 其它因编程错误或偶然的外在因素导致的一般性问题, 可以使用针对性的代码进行处理.  <ul>
<li>空指针访问  </li>
<li>试图读取不存在的文件  </li>
<li>网络连接中断  </li>
<li>数组角标越界  </li>
</ul>
</li>
<li>对于这些错误, 一般有两种解决方法：  <ul>
<li>一是遇到错误就终止程序的运行.  </li>
<li>另一种方法是由程序员在编写程序时, 就考虑到错误的检测、 错误消息的提示, 以及错误的处理.</li>
</ul>
</li>
<li>捕获错误最理想的是在编译期间, 但有的错误只有在运行时才会发生. 比如： 除数为0, 数组下标越界等<ul>
<li>分类: <strong>编译时异常</strong>和<strong>运行时异常</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-常见异常"><a href="#4-2-常见异常" class="headerlink" title="4.2 常见异常"></a>4.2 常见异常</h3><ul>
<li><p>异常体系结构</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.lang.Throwoable</span></span><br><span class="line"><span class="comment">    |----java.lang.Error: 一般不编写代码处理</span></span><br><span class="line"><span class="comment">    |---- java.lang.Exception: 可以进行异常的处理</span></span><br><span class="line"><span class="comment">        |----编译时异常(checked)</span></span><br><span class="line"><span class="comment">            |----IOException</span></span><br><span class="line"><span class="comment">                |----FileNotFoundException</span></span><br><span class="line"><span class="comment">            |----ClassNotFoundException</span></span><br><span class="line"><span class="comment">        |----运行时异常(unchecked)</span></span><br><span class="line"><span class="comment">            |----NullPointException</span></span><br><span class="line"><span class="comment">            |----ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">            |----ClassCastExction</span></span><br><span class="line"><span class="comment">            |----NumberFormatException</span></span><br><span class="line"><span class="comment">            |----InputMismatchException</span></span><br><span class="line"><span class="comment">            |----ArithmeticException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-3-异常处理机制一-try-catch-finally"><a href="#4-3-异常处理机制一-try-catch-finally" class="headerlink" title="4.3 异常处理机制一: try-catch-finally"></a>4.3 异常处理机制一: try-catch-finally</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally 是可选的, 不是必须的, finally中是一定会执行的代码,(不管try中是否有return, catch中还有异常)<ul>
<li>一般用于释放资源</li>
</ul>
</li>
<li>常用的异常处理的方法: <code>String getMessage()</code>  <code>void printStackTrace()</code></li>
</ul>
<h3 id="4-4-异常处理机制二-throws-异常类型"><a href="#4-4-异常处理机制二-throws-异常类型" class="headerlink" title="4.4 异常处理机制二: throws + 异常类型"></a>4.4 异常处理机制二: throws + 异常类型</h3><ul>
<li>throws + 异常类型 写在方法的声明处, 指明此方法执行时, 可能会抛出的异常类型. 一旦方法执行时, 出现异常, 仍会在异常代码处生成一个异常类的对象, 此对象满足 throws 后异常类型时, 就会被抛出. 异常代码后续的代码就不再执行</li>
<li>手动抛出异常: <code>throw new RuntimeException(&quot;错误信息&quot;)</code></li>
</ul>
<h3 id="4-6-自定义异常类"><a href="#4-6-自定义异常类" class="headerlink" title="4.6 自定义异常类"></a>4.6 自定义异常类</h3><ul>
<li>如何自定义异常类<ol>
<li>继承于现有的异常结构: <code>RuntimeException</code>  <code>Exception</code></li>
<li>提供全区常量serialVersionUID, 类的唯一标识, 序列号</li>
<li>提供重载的构造器</li>
</ol>
</li>
</ul>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5. 多线程"></a>5. 多线程</h2><h3 id="5-1-基本概念-程序-进程-线程"><a href="#5-1-基本概念-程序-进程-线程" class="headerlink" title="5.1 基本概念: 程序, 进程, 线程"></a>5.1 基本概念: 程序, 进程, 线程</h3><ul>
<li><p>程序(program): 是为完成特定任务、用某种语言编写的一组指令的集合. 即指一段静态的代码, 静态对象</p>
</li>
<li><p>进程(process): 是程序的一次执行过程, 或是正在运行的一个程序. 是一个动态的过程：有它自身的产生、存在和消亡的过程.  ——生命周期</p>
<ul>
<li>程序是静态的, 进程是动态的</li>
<li>进程作为资源分配的单位,  系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li><p>线程(thread), 进程可进一步细化为线程, 是一个程序内部的一条执行路径</p>
<ul>
<li>若一个进程同一时间并行执行多个线程, 就是支持多线程的</li>
<li>线程作为调度和执行的单位, 每个线程拥有独立的运行栈和程序计数器(pc), 线程切换的开销小  </li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象, 可以访问相同的变量和对象. 这就使得线程间通信更简便、高效. 但多个线程操作共享的系统资源可能就会带来安全的隐患</li>
</ul>
</li>
<li><p>单核CPU和多核CPU的理解  </p>
<ul>
<li>单核CPU, 其实是一种假的多线程, 因为在一个时间单元内, 也只能执行一个线程的任务.</li>
<li>多核CPU, 才能更好的发挥多线程的效率. (现在的服务器都是多核的)</li>
<li>一个Java应用程序java.exe, 其实至少有三个线程： main()主线程,  gc()垃圾回收线程, 异常处理线程. 当然如果发生异常, 会影响主线程.</li>
</ul>
</li>
<li><p>并行与并发  </p>
<ul>
<li>并行： 多个CPU同时执行多个任务. 比如：多个人同时做不同的事</li>
<li>并发： 一个CPU(采用时间片)同时执行多个任务</li>
</ul>
</li>
<li><p>使用多线程的优点</p>
<ol>
<li>提高应用程序的响应. 对图形化界面更有意义, 可增强用户体验</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构. 将既长又复杂的进程分为多个线程, 独立运行, 利于理解和修改</li>
</ol>
</li>
<li><p>何时需要多线程</p>
<ul>
<li>程序需要同时执行两个或多个任务</li>
<li>程序需要实现一些需要等待的任务时, 如用户输入、文件读写操作、网络操作、搜索等</li>
<li>需要一些后台运行的程序时</li>
</ul>
</li>
</ul>
<h3 id="5-2-线程的创建和使用"><a href="#5-2-线程的创建和使用" class="headerlink" title="5.2 线程的创建和使用"></a>5.2 线程的创建和使用</h3><ul>
<li><p>Java语言的JVM允许程序运行多个线程, 它通过<code>java.lang.Thread</code>类来体现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一. 创建多线程的方法一 : 继承于Thread类</span></span><br><span class="line"><span class="comment">*    1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="comment">*    2. 重写Thread类的run()方法 --&gt; 此线程想要执行的操作</span></span><br><span class="line"><span class="comment">*    3. 创建Thread子类的对象</span></span><br><span class="line"><span class="comment">*    4. 通过此对象调用start():  </span></span><br><span class="line"><span class="comment">*       a. 启动当前前程</span></span><br><span class="line"><span class="comment">*       b. 调用当前线程的run()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    注: 不能通过直接调用run()方法的方式启动线程</span></span><br><span class="line"><span class="comment">*        再启动一个线程, 不能用已经start()的线程去执行, 会报IllegalThreadStatusException异常</span></span><br><span class="line"><span class="comment">*        需要创新创建一个线程的对象</span></span><br><span class="line"><span class="comment">* 二. 创建多线程的方法二 : 实现Runnable接口</span></span><br><span class="line"><span class="comment">*    1. 创建一个实现Runnable接口的类</span></span><br><span class="line"><span class="comment">*    2. 实现类中实现抽象方法run()</span></span><br><span class="line"><span class="comment">*    3. 创建实现类的对象</span></span><br><span class="line"><span class="comment">*    4. 将此对象作为参数传递到Thread类的构造器中, 创建Thread类的对象</span></span><br><span class="line"><span class="comment">*    5. 通过Thread类的对象调用start()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 三. 比较2种创建多线程的区别:</span></span><br><span class="line"><span class="comment">*    开发中, 优先选择实现的Runnable接口的方式,</span></span><br><span class="line"><span class="comment">*      1. 实现的方式没有类的单继承的局限性</span></span><br><span class="line"><span class="comment">*      2. 实现的方式适合处理有共享数据的情况, 不用声明为static的</span></span><br><span class="line"><span class="comment">*    联系:</span></span><br><span class="line"><span class="comment">*      Thread类本身也实现了Runnable接口</span></span><br><span class="line"><span class="comment">*      两种方式都要重写run()方法, 将线程执行的逻辑声明在方法种</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/2/3 11:16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Thread类中的常用方法</span></span><br><span class="line"><span class="comment">*    1. start() : 启动当前线程; 执行run()方法</span></span><br><span class="line"><span class="comment">*    2. run() : 通常要重写Thread类中的此����法, 将创建线程想要�����行的功能声明在该方法中</span></span><br><span class="line"><span class="comment">*    3. currentThread() : 静态方法, 返回执行当前代码的线程</span></span><br><span class="line"><span class="comment">*    4. getName() : 获取当前线程的名字</span></span><br><span class="line"><span class="comment">*    5. setName() : 设置当前线程的名字</span></span><br><span class="line"><span class="comment">*    6. yield() : 释放当前CPU的执行权, 但下一秒是谁执行就看谁抢到执行权</span></span><br><span class="line"><span class="comment">*    7. join() : 在线程A中调用线程B的join()方法, 线程A进入阻塞状态, 直到线程B执行完后, 线程A才结束阻塞状态</span></span><br><span class="line"><span class="comment">*    8. stop() : 已过时. 强制结束当前线程</span></span><br><span class="line"><span class="comment">*    9. sleep(long millisTime) : 让当前线程"睡眠"指定的millisTime毫秒, 在指定的时间内, 当前线程是阻塞状态</span></span><br><span class="line"><span class="comment">*    10. isAlive() : 判断当前线程是否还存活</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   线程的优先级:</span></span><br><span class="line"><span class="comment">*      MIN_PRIORITY = 1;  低优先级</span></span><br><span class="line"><span class="comment">*      NORM_PRIORITY = 5; 默认优先级</span></span><br><span class="line"><span class="comment">*      MAX_PRIORITY = 10; 高优先级</span></span><br><span class="line"><span class="comment">*   如何获得和设置当前线程的优先级:</span></span><br><span class="line"><span class="comment">*     getPriority() : 获取</span></span><br><span class="line"><span class="comment">*     setPriority(int p): 设置</span></span><br><span class="line"><span class="comment">*   优先级高只是有可能会优先执行, 不是优先级高的执行完后再执行优先级低的</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/2/3 11:42</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>); <span class="comment">// 该操作是在主线程中执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-3-线程的生命周期"><a href="#5-3-线程的生命周期" class="headerlink" title="5.3 线程的生命周期"></a>5.3 线程的生命周期</h3><ul>
<li><p>JDK中用Thread.State类定义了线程的几种状态</p>
<ul>
<li>新建(new): 当一个Thread类或其子类的对象被声明并创建时, 新生的线程对象处于新建状态</li>
<li>就绪: 处于新建状态的线程被start()后, 将进入线程队列等待CPU时间片, 此时它已具备了运行的条件, 只是没分配到CPU资源</li>
<li>运行: 当就绪的线程被调度并获得CPU资源时,便进入运行状态, run()方法定义了线程的操作和功能</li>
<li>阻塞: 在某种特殊情况下, 被人为挂起或执行输入输出操作时, 让出 CPU 并临时中止自己的执行, 进入阻塞状态</li>
<li>死亡: 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><img src="https://i.loli.net/2020/03/20/J24ajVgFIp5Yhvr.png" alt="线程的声明周期.png"></p>
</li>
</ul>
<h3 id="5-4-线程的同步"><a href="#5-4-线程的同步" class="headerlink" title="5.4 线程的同步"></a>5.4 线程的同步</h3><ul>
<li><p>线程安全问题  </p>
<ul>
<li><p>多个线程执行的不确定性引起执行结果的不稳定</p>
</li>
<li><p>多个线程对数据的共享, 会造成操作的不完整性, 会破坏数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  创建3个卖票窗口, 总票数 100, 存在线程安全问题</span></span><br><span class="line"><span class="comment">*    解决线程安全:</span></span><br><span class="line"><span class="comment">*      1. 问题出现的原因:</span></span><br><span class="line"><span class="comment">*        当某个线程在操作车票的过程中, 尚未完成操作时 ,其他线程参与进来, 也操作车票</span></span><br><span class="line"><span class="comment">*      2. 如何解决:</span></span><br><span class="line"><span class="comment">*        当一个线程A在操作共享数据时, 其他线程不能参与进来, 直到A操作完成, 其他线程才可以开始操作</span></span><br><span class="line"><span class="comment">*        即使A出现了阻塞也不能被改变.</span></span><br><span class="line"><span class="comment">*      3. Java中, 通过同步机制解决线程的安全问题</span></span><br><span class="line"><span class="comment">*        方式一: 同步代码块</span></span><br><span class="line"><span class="comment">*          synchronized(同步监视器)&#123;</span></span><br><span class="line"><span class="comment">*              // 需要同步的代码</span></span><br><span class="line"><span class="comment">*          &#125;</span></span><br><span class="line"><span class="comment">*          说明:</span></span><br><span class="line"><span class="comment">*            1. 操作共享数据的代码, 即是需要同步的代码, 不能括多了(出错), 也不能括少了(没有解决安全问题)</span></span><br><span class="line"><span class="comment">*            2. 共享数据 : 多个线程共同操作的变量, 比如本问题中的 ticket</span></span><br><span class="line"><span class="comment">*            3. 同步监视器 : 俗称, 锁. 任何一个类的对象, 都可以充当锁</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*               要求: 多个线程必须共用一把锁, 即只有一个锁对象</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*               补充: 在实现Runnable接口创建多线程的方式中, 可以考虑使用this充当同步监视器</span></span><br><span class="line"><span class="comment">*                    在继承Thread类创建多线程的方式中, 慎用this充当同步监视器, 考虑使用当前类充当同步监视器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        方式二: 同步方法</span></span><br><span class="line"><span class="comment">*            如果操作共享数据的代码完整的声明在一个方法中, 不妨将该方法声明为同步的, 则该方法为同步方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*            1. 同步方法仍然涉及到同步监视器, 只是不用我们显式的声明</span></span><br><span class="line"><span class="comment">*            2. 非静态的同步方法, 同步监视器是: this</span></span><br><span class="line"><span class="comment">*               静态的同步方法, 同步监视器是: 当前类本身</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        方式三: Lock锁 --- <span class="doctag">@since</span> jdk5.0</span></span><br><span class="line"><span class="comment">*           通过显式定义同步锁对象来实现同步. 同步锁使用Lock对象充当</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        synchronized 与 lock 的区别</span></span><br><span class="line"><span class="comment">*          相同 : 二者都可以解决线程安全问题</span></span><br><span class="line"><span class="comment">*          不同 : synchronized 机制在执行完相应的同步代码后, 自动释放同步监视器</span></span><br><span class="line"><span class="comment">*                 lock 需要手动的启动同步, 同时也要手动结束同步, 更灵活</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*      5. 同步优劣:</span></span><br><span class="line"><span class="comment">*         好处 : 解决了线程安全问题</span></span><br><span class="line"><span class="comment">*         局限 : 操作同步代码时, 相当于是一个单线程的过程, 效率降低</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/2/3 14:42</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window w = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123; <span class="comment">// obj  同步监视器</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">": 卖票, 票号为: "</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化lock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock(); <span class="comment">// 调用lock(); 上锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"售票, 票号为: "</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>死锁:</p>
<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃, 都在等待对方放弃自己需要的同步资源, 就形成了线程的死锁</li>
<li>出现死锁后, 不会出现异常, 不会出现提示, 只是所有的线程都处于阻塞状态, 无法继续, 使用时要注意避免出现死锁</li>
</ul>
</li>
</ul>
<h3 id="5-5-线程的通信"><a href="#5-5-线程的通信" class="headerlink" title="5.5 线程的通信"></a>5.5 线程的通信</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程通信举例: 使用两个线程打印 1-100, 线程1,2 交替打印</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 涉及到的方法:</span></span><br><span class="line"><span class="comment"> *   wait() : 一旦执行此方法, 当前线程就进入阻塞状态, 并释放同步监视器</span></span><br><span class="line"><span class="comment"> *   notify() : 一旦执行此方法, 就会唤醒被wait的一个线程, 如果有多个线程被wait, 就会唤醒优先级高那个</span></span><br><span class="line"><span class="comment"> *   notifyAll() : 一旦执行此方法, 就会唤醒被wait的所有线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *     说明:</span></span><br><span class="line"><span class="comment"> *        1. wait() notify() notifyAll() 三个方法, 必须使用在同步代码块或同步方法中</span></span><br><span class="line"><span class="comment"> *        2. wait() notify() notifyAll() 三个方法的调用者必须是同步代码块或同步方法中的同步监视器</span></span><br><span class="line"><span class="comment"> *           否则会出现IllegalMonitorStateException异常</span></span><br><span class="line"><span class="comment"> *        3. wait() notify() notifyAll() 三个方法定义在Object类中, (与之前说的任何一个类都可以当同步监视器联系起来)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/3 20:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number n = <span class="keyword">new</span> Number();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(n);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(n);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"thread-1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"thread-2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((i--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.notify();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 使得调用如下wait()方法的线程进入阻塞状态, wait()会释放锁, sleep()不会释放锁</span></span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait() 与 sleep() 方法的区别<ol>
<li>相同点: 都可以使当前线程进入阻塞状态</li>
<li>不同点:  <ol>
<li>两个方法声明的位置不同, Thread类中声明sleep(), wait()是在Object类中声明的</li>
<li>调用的范围不同:<br>sleep() 没有要求, 可以在任何需要的情况下调用<br>wait()方法必须使用同步监视器调用, 即必须在同步代码块或同步方法中调用  </li>
<li>slee()方法不会释放锁, 而wait()方法会自动释放锁对象</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="5-6-JDK-5-0新增的线程创建方式"><a href="#5-6-JDK-5-0新增的线程创建方式" class="headerlink" title="5.6 JDK 5.0新增的线程创建方式"></a>5.6 JDK 5.0新增的线程创建方式</h3><h4 id="1-实现Callable接口"><a href="#1-实现Callable接口" class="headerlink" title="1. 实现Callable接口"></a>1. 实现Callable接口</h4><ul>
<li><p>与使用Runnable相比, Callable功能更强大些</p>
<ul>
<li>相比run()方法, 可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类, 比如获取返回结果<ul>
<li>Future接口<ul>
<li>可以对具体Runnable、 Callable任务的执行结果进行取消、查询是否完成、获取结果等.  </li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口. 它既可以作为Runnable被线程执行, 又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤:</p>
<ol>
<li><p>创建一个实现Callable接口的实现类</p>
</li>
<li><p>重写call方法, 将此线程要执行的操作声明在call中</p>
</li>
<li><p>创建callable接口的实现类对象</p>
</li>
<li><p>将此callable接口的实现类对象作为参数传递到FutureTask构造器中,创建FutureTask对象</p>
</li>
<li><p>将FutureTask对象传入Thread类的构造器中, 开启线程</p>
</li>
<li><p>获取Callable中call方法的返回值(可选)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建新城的方式三: 实现Callable接口</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> jdk 5.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/4 16:55</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 1. 创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 2. 重写call方法, 将此线程要执行的操作声明在call中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3, 创建callable接口的实现类对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">// 4. 将此callable接口的实现类对象作为参数传递到FutureTask构造器中,创建FutureTask对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">// 5. 将FutureTask对象传入Thread类的构造器中, 开启线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 获取Callable中call方法的返回值(可选)</span></span><br><span class="line">            <span class="comment">// get()方法的返回值即为 futureTask构造器参数Callable实现类重写的call()方法的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"sum = "</span>+sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="2-使用线程池"><a href="#2-使用线程池" class="headerlink" title="2. 使用线程池"></a>2. 使用线程池</h4><ul>
<li><p>背景:<br>经常创建和销毁、使用量特别大的资源, 比如并发情况下的线程, 对性能影响很大</p>
</li>
<li><p>思路:<br>提前创建好多个线程, 放入线程池中, 使用时直接获取, 使用完放回池中. 可以避免频繁创建销毁、实现重复利用. 类似生活中的公共交通工具</p>
</li>
<li><p>好处:  </p>
<ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程, 不需要每次都创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK 5.0起提供了线程池相关API： <code>ExecutorService</code> 和 <code>Executors</code></p>
</li>
<li><p><code>ExecutorService</code>：真正的线程池接口.常见子类<code>ThreadPoolExecutor</code></p>
<ul>
<li><code>void execute(Runnable command)</code> ：执行任务/命令, 没有返回值, 一般用来执行<code>Runnable</code></li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务, 有返回值, 一般又来执行<code>Callable</code></li>
<li><code>void shutdown()</code> ：关闭连接池</li>
</ul>
</li>
<li><p><code>Executors</code>：工具类、线程池的工厂类, 用于创建并返回不同类型的线程池</p>
<ul>
<li><p><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</p>
</li>
<li><p><code>Executors.newFixedThreadPool(n)</code>; 创建一个可重用固定线程数的线程池</p>
</li>
<li><p><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</p>
</li>
<li><p><code>Executors.newScheduledThreadPool(n)</code>：创建一个线程池, 它可安排在给定延迟后运行命令或者定期地执行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池创建线程</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Joe</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020/2/4 17:20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 提供只当线程数量的连接池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">// 设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line">        service1.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 执行指定线程的操作, 需要提供实现Runnable或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread()); <span class="comment">// 适合Runnable</span></span><br><span class="line"><span class="comment">//        service.submit(); // 适合使用Callable</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="6-Java常用类"><a href="#6-Java常用类" class="headerlink" title="6. Java常用类"></a>6. Java常用类</h2><h3 id="6-1-字符串相关的类"><a href="#6-1-字符串相关的类" class="headerlink" title="6.1 字符串相关的类"></a>6.1 字符串相关的类</h3><ul>
<li><p>String类： 代表字符串. Java 程序中的所有字符串字面值(如 “abc” )都作为此类的实例实现</p>
<ul>
<li><p>String是一个final类, 不可被继承</p>
</li>
<li><p>字符串是常量, 用双引号引起来表示. 它们的值在创建之后不能更改</p>
</li>
<li><p>String对象的字符内容是存储在一个字符数组value[]中的</p>
</li>
<li><p>String 实现了serializable接口, 表示支持序列化</p>
<pre><code>实现了Comparable接口, 表示可以比较大小</code></pre></li>
<li><p>String内部定义了final char[] value用于存储字符串数据</p>
</li>
<li><p>String 代表不可变的字符序列, 即不可变性</p>
<ul>
<li>对字符串重新赋值时, 重写指定内区区域, 不是对原有的value进行赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// default to 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常量式(字面量)赋值创建, 放在方法区常量池空间(将被常量化)  </p>
</li>
<li><p>常量池中不会存放相同内容的字符串</p>
</li>
</ul>
</li>
<li><p>String类的创建</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>; <span class="comment">// 声明在字符串常量池中</span></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(); <span class="comment">// 在堆空间中开辟地址</span></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(String original);</span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>string创建内存结构1<br><img src="https://i.loli.net/2020/03/20/iIxaUHAV6ZcJWXO.png" alt="string1.png"></p>
</li>
<li><p>string创建内存结构2<br><img src="https://i.loli.net/2020/03/20/e3cDtNvZF8r4mnS.png" alt="string2.png"></p>
</li>
<li><p><strong>常量与常量</strong>的拼接结果在常量池中</p>
</li>
<li><p>只要其中一个是变量, 那么结果就在堆中</p>
</li>
<li><p>如果拼接的结果调用intern()方法, 返回值就在常量池中</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a7 = <span class="string">"helloWorld"</span>;</span><br><span class="line">String a3 = <span class="string">"hello"</span> + <span class="string">"World"</span>;</span><br><span class="line">String a4 = a1 + <span class="string">"World"</span>;</span><br><span class="line">String a5 = <span class="string">"hello"</span> + a2;</span><br><span class="line">String a6 = a1 + a2;</span><br><span class="line"><span class="keyword">final</span> String a9 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">String a11 = a9+ <span class="string">"World"</span>; <span class="comment">// 常量拼接常量, 在常量池中</span></span><br><span class="line">System.out.println(a11 == a7); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(a3 == a7); <span class="comment">// true</span></span><br><span class="line">System.out.println(a4 == a3); <span class="comment">// false</span></span><br><span class="line">System.out.println(a5 == a3); <span class="comment">// false</span></span><br><span class="line">System.out.println(a6 == a3); <span class="comment">// false</span></span><br><span class="line">System.out.println(a4 == a6); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String a8 = a6.intern(); <span class="comment">// 此时返回的是在常量池中存在的内容的地址</span></span><br><span class="line">System.out.println(a8 == a3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>： 返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>： 判断是否是空字符串： return value.length </span>== <span class="number">0</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>： 使用默认语言环境,  将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>： 使用默认语言环境,  将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span>： 返回字符串的副本,  忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>： 比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>： 与equals方法类似,  忽略大小写</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>： 将指定字符串连接到此字符串的结尾. 等价于用“+”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>： 比较两个字符串的大小</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>： 返回一个新的字符串,  它是此字符串的从beginIndex开始截取到最后的一个子字符串.</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ： 返回一个新字符串,  它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>： 测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>： 测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>： 测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>： 当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时, 返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>： 返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>： 返回指定子字符串在此字符串中第一次出现处的索引, 从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>： 返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>： 返回指定子字符串在此字符串中最后一次出现处的索引, 从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注： indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>： 返回一个新的字符串,  它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的.</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>： 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串.</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串.</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>： 告知此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span>： 根据给定正则表达式的匹配拆分此字符串.</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>： 根据匹配给定的正则表达式来拆分此字符串,  最多不超过limit个,  如果超过了,  剩下的全部都放到最后一个元素中</span></span><br></pre></td></tr></table></figure>

<h4 id="StringBuffer-与-StringBuilder"><a href="#StringBuffer-与-StringBuilder" class="headerlink" title="StringBuffer 与 StringBuilder"></a>StringBuffer 与 StringBuilder</h4><ul>
<li><p>String 与 StringBuffer 和 StringBuilder 的区别</p>
<ul>
<li><p>String: 不可变的字符序列, 底层使用char[]存储</p>
</li>
<li><p>StringBuffer:可变的字符序列, 线程安全的(都是同步方法),效率低, 底层使用char[]存储</p>
</li>
<li><p>StringBuilder:可变的字符序列, JDK5.0新增的, 线程不安全, 效率高, 底层使用char[]存储</p>
</li>
<li><p>源码分析</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(); <span class="comment">// char[] value = new char[0];</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// char[] value = new char[]&#123;'a', 'b', 'c'&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16]; 底层创建了长度16的数组</span></span><br><span class="line">sb1.append(<span class="string">'a'</span>); <span class="comment">// value[0] = 'a';</span></span><br><span class="line">sb1.append(<span class="string">'b'</span>); <span class="comment">// value[1] = 'b';</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">// char[] value = new char["abc".length() + 16];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容问题, 如果要添加的数据底层数组放不下, 就需要扩容底层数组</span></span><br><span class="line"><span class="comment">// 默认情况下, 扩容为原来的2倍+2, 同时将原有数组的元素复制到新的数组中</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>效率排序:<br>StringBuilder &gt; StringBuffer &gt; String</p>
</li>
</ul>
<h3 id="6-2-JDK-8之前的日期时间API"><a href="#6-2-JDK-8之前的日期时间API" class="headerlink" title="6.2 JDK 8之前的日期时间API"></a>6.2 JDK 8之前的日期时间API</h3><ul>
<li>计算世界时间的主要标准有：<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
</li>
</ul>
<ol>
<li><p>java.lang.System类  </p>
<ul>
<li>System类提供的<code>public static long currentTimeMillis()</code></li>
<li>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差 — 称为时间戳</li>
<li>此方法适于计算时间差</li>
</ul>
</li>
<li><p>java.util.Date类 : 表示特定的瞬间, 精确到毫秒</p>
<ul>
<li><p>构造器：</p>
<ul>
<li>Date()： 使用无参构造器创建的对象可以获取本地当前时间.</li>
<li>Date(long date)</li>
</ul>
</li>
<li><p>常用方法:  </p>
<ul>
<li><p>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</p>
</li>
<li><p>toString():把此 Date 对象转换为以下形式的 <code>String： dow mon ddhh:mm:ss zzz yyyy</code> 其中： <code>dow</code> 是一周中的某一天 <code>(Sun, Mon, Tue,Wed, Thu, Fri, Sat)</code>, <code>zzz</code>是时间标准</p>
</li>
<li><p>其它很多方法都过时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">System.out.println(date.getTime());</span><br><span class="line"></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date(date.getTime());</span><br><span class="line">System.out.println(date1.getTime());</span><br><span class="line">System.out.println(date1.toString());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>java.text.SimpleDateFormat类</p>
<ul>
<li><p>Date类的API不易于国际化, 大多被废弃了  </p>
</li>
<li><p><code>java.text.SimpleDateFormat</code>类是一个不与语言环境有关的方式来格式化和解析日期的具体类.</p>
<ul>
<li>格式化：日期-&gt;文本</li>
<li>解析：  文本-&gt;日期</li>
</ul>
</li>
<li><p>格式化：</p>
<ul>
<li><code>SimpleDateFormat()</code> ：默认的模式和语言环境创建对象</li>
<li><code>public SimpleDateFormat(String pattern)</code>： 该构造方法可以用参数pattern指定的格式创建一个对象</li>
<li><code>SimpleDateFormat</code>对象调用：<code>public String format(Date date)</code>： 方法格式化时间对象date</li>
</ul>
</li>
<li><p>解析：</p>
<ul>
<li><code>public Date parse(String source)</code> ： 从给定字符串的开始解析文本, 以生成一个日期.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// 产生一个Date实例</span></span><br><span class="line"><span class="comment">// 产生一个formater格式化的实例</span></span><br><span class="line">SimpleDateFormat formater = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">System.out.println(formater.format(date));<span class="comment">// 打印输出默认的格式</span></span><br><span class="line">SimpleDateFormat formater2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 EEE HH:mm:ss"</span>);</span><br><span class="line">System.out.println(formater2.format(date));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个指定的格式对象</span></span><br><span class="line">    Date date2 = formater2.parse(<span class="string">"2008年08月08日 星期一 08:08:08"</span>);</span><br><span class="line">    <span class="comment">// 将指定的日期解析后格式化按指定的格式输出</span></span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>java.util.Calendar(日历)类</p>
<ul>
<li><p><code>Calendar</code>是一个抽象基类, 主用用于完成日期字段之间相互操作的功能  </p>
</li>
<li><p>获取Calendar实例的方法</p>
<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器</li>
</ul>
</li>
<li><p>一个Calendar的实例是系统时间的抽象表示, 通过<code>get(int field)</code>方法来取得想要的时间信息.比如<code>YEAR、 MONTH、 DAY_OF_WEEK、 HOUR_OF_DAY 、MINUTE、 SECOND</code></p>
<ul>
<li><code>public void set(int field,int value)</code></li>
<li><code>public void add(int field,int amount)</code></li>
<li><code>public final Date getTime()</code></li>
<li><code>public final void setTime(Date date)</code><blockquote>
<p>注:<br>获取月份时： 一月是0, 二月是1, 以此类推,  12月是11<br>获取星期时： 周日是1, 周二是2 ,  . …周六是7</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 从一个 Calendar 对象中获取 Date 对象</span></span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line"><span class="comment">// 使用给定的 Date 设置此 Calendar 的时间</span></span><br><span class="line">date = <span class="keyword">new</span> Date(<span class="number">234234235235L</span>);</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"当前时间日设置为8后,时间是:"</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.HOUR, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"当前时间加2小时后,时间是:"</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"当前日期减2个月后,时间是:"</span> + calendar.getTime());</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="6-3-JDK-8中新日期时间API"><a href="#6-3-JDK-8中新日期时间API" class="headerlink" title="6.3 JDK 8中新日期时间API"></a>6.3 JDK 8中新日期时间API</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    如果我们可以跟别人说：“我们在1502643933071见面, 晚了！”那么就再简单不过了.但是我们希望时间与昼</span><br><span class="line">夜和四季有关, 于是事情就变复杂了.JDK 1.0中包含了一个java.util.Date类, 但是它的大多数方法已经在JDK 1.1</span><br><span class="line">引入Calendar类之后被弃用了.而Calendar并不比Date好多少.</span><br><span class="line">    它们面临的问题是：</span><br><span class="line">        可变性：像日期和时间这样的类应该是不可变的.</span><br><span class="line">        偏移性： Date中的年份是从1900开始的, 而月份都从0开始.</span><br><span class="line">        格式化：格式化只对Date有用,  Calendar则不行.</span><br><span class="line">    此外, 它们也不是线程安全的；不能处理闰秒等.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>LocalDate、 LocalTime、 LocalDateTime 类是其中较重要的几个类, 它们的实例是不可变的对象, 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间.</p>
</li>
<li><p>它们提供了简单的本地日期或时间, 并不包含当前的时间信息, 也不包含与时区相关的信息  </p>
<ul>
<li><p><code>now() / * now(ZoneId zone)</code> 静态方法,  根据当前时间创建对象/指定时区的对象</p>
</li>
<li><p><code>of()</code> 静态方法,  根据指定日期/时间创建对象</p>
</li>
<li><p><code>getDayOfMonth()/getDayOfYear()</code> 获得月份天数(1-31) /获得年份天数(1-366)</p>
</li>
<li><p><code>getDayOfWeek()</code> 获得星期几(返回一个 DayOfWeek 枚举值)</p>
</li>
<li><p><code>getMonth()</code> 获得月份, 返回一个 Month 枚举值</p>
</li>
<li><p><code>getMonthValue() / getYear()</code> 获得月份(1-12) /获得年份</p>
</li>
<li><p><code>getHour()/getMinute()/getSecond()</code> 获得当前对象对应的小时、 分钟、 秒</p>
</li>
<li><p><code>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</code> 将月份天数、 年份天数、 月份、 年份修改为指定的值并返回新的对象</p>
</li>
<li><p><code>plusDays(), plusWeeks(),plusMonths(), plusYears(),plusHours()</code> 向当前对象添加几天、 几周、 几个月、 几年、 几小时</p>
</li>
<li><p><code>minusMonths() / minusWeeks()/ minusDays()/minusYears()/minusHours()</code> 从当前对象减去几月、 几周、 几天、 几年、 几小时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  LocalDate、 LocalTime、 LocalDateTime的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now() 静态方法获取当前日期, 时间, 日期+时间</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate); <span class="comment">// 2020-02-05</span></span><br><span class="line">    System.out.println(localTime); <span class="comment">// 15:54:14.344</span></span><br><span class="line">    System.out.println(localDateTime); <span class="comment">// 2020-02-05T15:54:14.344</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// of() 指定日期时间, 没有偏移量</span></span><br><span class="line">    LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">20</span>, <span class="number">23</span>);</span><br><span class="line">    System.out.println(localDateTime1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getXXX() 获取相关属性</span></span><br><span class="line">    System.out.println(<span class="string">"localDateTime.getDayOfMonth() = "</span> + localDateTime.getDayOfMonth());</span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">    System.out.println(localDateTime.getDayOfYear());</span><br><span class="line">    System.out.println(localDateTime.getMonth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 体现不可变性</span></span><br><span class="line">    <span class="comment">// withXxx() 设置相关属性</span></span><br><span class="line">    LocalDateTime localDateTime2 = localDateTime.withDayOfMonth(<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">"localDateTime = "</span> + localDateTime);</span><br><span class="line">    System.out.println(<span class="string">"localDateTime2 = "</span> + localDateTime2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在现有的基础上进行加减操作</span></span><br><span class="line">    LocalDateTime localDateTime3 = localDateTime.plusMonths(<span class="number">2</span>); <span class="comment">// 加</span></span><br><span class="line">    System.out.println(<span class="string">"localDateTime3 = "</span> + localDateTime3);</span><br><span class="line">    LocalDateTime localDateTime4 = localDateTime.minusHours(<span class="number">20</span>); <span class="comment">// 减</span></span><br><span class="line">    System.out.println(<span class="string">"localDateTime4 = "</span> + localDateTime4);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="瞬时：-Instant"><a href="#瞬时：-Instant" class="headerlink" title="瞬时： Instant"></a>瞬时： Instant</h4><ul>
<li><p>Instant：时间线上的一个瞬时点. 这可能被用来记录应用程序中的事件时间戳.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instant 的使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now()  本初子午线的时间</span></span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"instant = "</span> + instant);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加时间偏移量</span></span><br><span class="line">        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">"offsetDateTime = "</span> + offsetDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toEpochMilli() 获取1970年1月1日0分0秒(UTC)至今的毫秒数  ==&gt; Date类的getTime()方法</span></span><br><span class="line">        <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">        System.out.println(<span class="string">"milli = "</span> + milli);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过给定的毫秒数, 获取一个  Instant 实例  ==&gt; Date(long millis)</span></span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(<span class="number">1580890452829L</span>);</span><br><span class="line">        System.out.println(<span class="string">"instant1 = "</span> + instant1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DateTimeFormat类 : 格式化与解析日期或时间</p>
<ul>
<li>详见文件…, 懒得敲了</li>
</ul>
</li>
</ul>
<h3 id="6-4-Java比较器"><a href="#6-4-Java比较器" class="headerlink" title="6.4 Java比较器"></a>6.4 Java比较器</h3><ul>
<li>Java实现对象排序的方式有两种：<ul>
<li>自然排序 : <code>java.lang.Comparable</code></li>
<li>定制排序 : <code>java.util.Comparator</code></li>
</ul>
</li>
</ul>
<ol>
<li><p>自然排序 ： java.lang.Comparable</p>
<ul>
<li><p>实现 <code>Comparable</code> 的类必须实现 <code>compareTo(Object obj)</code> 方法, 两个对象即通过 <code>compareTo(Object obj)</code> 方法的返回值来比较大小  </p>
</li>
<li><p>如果当前对象this大于形参对象obj,  则返回正整数, 如果当前对象this小于形参对象obj,  则返回负整数, 如果当前对象this等于形参对象obj,  则返回零</p>
</li>
<li><p>实现<code>Comparable</code>接口的对象列表(和数组)可以通过 <code>Collections.sort</code> 或<code>Arrays.sort</code>进行自动排序.实现此接口的对象可以用作有序映射中的键或有序集合中的元素, 无需指定比较器.</p>
</li>
<li><p>对于类 C 的每一个 e1 和 e2 来说, 当且仅当 <code>e1.compareTo(e2) == 0</code> 与<code>e1.equals(e2)</code> 具有相同的 boolean 值时, 类 C 的自然排序才叫做与 equals一致.</p>
<ul>
<li>建议(虽然不是必需的) 最好使自然排序与 equals 一致.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="comment">//按照价格, 比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            Goods other = (Goods) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.price &lt; other.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的数据类型不一致"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、 getter、 setter、 toString()方法略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goods[] all = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">        all[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"《红楼梦》 "</span>, <span class="number">100</span>);</span><br><span class="line">        all[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"《西游记》 "</span>, <span class="number">80</span>);</span><br><span class="line">        all[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"《三国演义》 "</span>, <span class="number">140</span>);</span><br><span class="line">        all[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"《水浒传》 "</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(all));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定制排序： java.util.Comparator</p>
<ul>
<li><p>当元素的类型没有实现<code>java.lang.Comparable</code>接口而又不方便修改代码, 或者实现了<code>java.lang.Comparable</code>接口的排序规则不适合当前的操作, 那么可以考虑使用 <code>Comparator</code> 的对象来排序,  强行对多个对象进行整体排序的比较</p>
</li>
<li><p>重写<code>compare(Object o1,Object o2)</code>方法, 比较o1和o2的大小： 如果方法返回正整数, 则表示o1大于o2；如果返回0, 表示相等；返回负整数, 表示o1小于o2</p>
</li>
<li><p>可以将 <code>Comparator</code> 传递给 sort 方法(如 <code>Collections.sort</code> 或 <code>Arrays.sort</code>), 从而允许在排序顺序上实现精确控制.</p>
</li>
<li><p>还可以使用 <code>Comparator</code> 来控制某些数据结构(如有序 set或有序映射)的顺序, 或者为那些没有自然顺序的对象 <code>collection</code> 提供排序.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"War and Peace"</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"Childhood"</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"Scarlet and Black"</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"Notre Dame de Paris"</span>, <span class="number">120</span>);</span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Goods g1 = (Goods) o1;</span><br><span class="line">        Goods g2 = (Goods) o2;</span><br><span class="line">        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(all));</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="7-枚举类和注解"><a href="#7-枚举类和注解" class="headerlink" title="7 枚举类和注解"></a>7 枚举类和注解</h2><h3 id="7-1-枚举类的使用"><a href="#7-1-枚举类的使用" class="headerlink" title="7.1 枚举类的使用"></a>7.1 枚举类的使用</h3><ul>
<li>类的对象只有有限个, 确定的. 举例:<ul>
<li>星期： Monday(星期一)、 ……、 Sunday(星期天)</li>
<li>性别： Man(男)、 Woman(女)</li>
<li>季节： Spring(春节)……Winter(冬天)</li>
<li>支付方式： Cash(现金)、 WeChatPay(微信)、 Alipay(支付宝)、 BankCard(银行卡)、 CreditCard(信用卡)</li>
<li>就职状态： Busy、 Free、 Vocation、 Dimission</li>
<li>订单状态： Nonpayment(未付款)、 Paid(已付款) 、 Delivered(已发货)、Return(退货)、 Checked(已确认) Fulfilled(已配货)</li>
<li>线程状态：创建、就绪、运行、阻塞、死亡</li>
</ul>
</li>
<li>当需要定义一组常量时, 强烈建议使用枚举类</li>
</ul>
<ol>
<li>枚举类的实现<ul>
<li>JDK1.5之前需要自定义枚举类</li>
<li>JDK 1.5 新增的 enum 关键字用于定义枚举类</li>
</ul>
</li>
<li>若枚举只有一个对象, 则可以作为一种单例模式的实现方式</li>
<li>枚举类的属性<ul>
<li>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰</li>
<li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</li>
<li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p>自定义枚举类</p>
<ol>
<li><p>私有化类的构造器, 保证不能在类的外部创建其对象</p>
</li>
<li><p>在类的内部创建枚举类的实例.声明为： public static final</p>
</li>
<li><p>对象如果有实例变量, 应该声明为private final, 并在构造器中初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 声明Season类的属性 private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME; <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC; <span class="comment">// 描述</span></span><br><span class="line">    <span class="comment">// 私有化构造器, 给对象赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>, <span class="string">"春暖花开"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>, <span class="string">"夏日炎炎"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>, <span class="string">"秋高气爽"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>, <span class="string">"白雪皑皑"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如何使用关键字enum定义枚举类</p>
<ul>
<li><p>使用说明:</p>
<ul>
<li>使用 enum 定义的枚举类默认继承了 <strong>java.lang.Enum</strong>类, 因此不能再继承其他类</li>
<li>枚举类的构造器只能使用 private 权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾).列出的实例系统会自动添加 public static final 修饰</li>
<li>必须在枚举类的第一行声明枚举类对象</li>
</ul>
</li>
<li><p>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</span><br><span class="line">    SPRING(<span class="string">"春天"</span>,<span class="string">"春风又绿江南岸"</span>),</span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>,<span class="string">"映日荷花别样红"</span>),</span><br><span class="line">    AUTUMN(<span class="string">"秋天"</span>,<span class="string">"秋水共长天一色"</span>),</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>,<span class="string">"窗含西岭千秋雪"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Enum类的主要方法</p>
<ul>
<li><code>values()</code>方法：返回枚举类型的对象数组.该方法可以很方便地遍历所有的枚举值.</li>
<li><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象.要求字符串必须是枚举类对象的“名字”.如不是, 会有运行时异常：<code>IllegalArgumentException</code></li>
<li><code>toString()</code>：返回当前枚举类对象常量的名称</li>
</ul>
</li>
<li><p>实现接口的枚举类</p>
<ul>
<li>和普通 Java 类一样, 枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式, 则只要统一实现该方法即可.</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法</li>
</ul>
</li>
</ol>
<h3 id="7-2-注解的使用"><a href="#7-2-注解的使用" class="headerlink" title="7.2 注解的使用"></a>7.2 注解的使用</h3><ol>
<li><p>注解 (Annotation) 概述</p>
<ul>
<li>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</li>
<li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理.通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息. 代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署.</li>
<li>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation的 “name=value” 对中</li>
<li>在JavaSE中, 注解的使用目的比较简单, 例如标记过时的功能, 忽略警告等.在JavaEE/Android中注解占据了更重要的角色, 例如用来配置应用程序的任何切面,  代替JavaEE旧版中所遗留的繁冗代码和XML配置等.</li>
<li>未来的开发模式都是基于注解的,  JPA是基于注解的,  Spring2.5以上都是基于注解的,  Hibernate3.x以后也是基于注解的, 现在的Struts2有一部分也是基于注解的了, 注解是一种趋势, 一定程度上可以说： <strong>框架 = 注解 + 反射 + 设计模式.</strong></li>
</ul>
</li>
<li><p>常见的Annotation示例</p>
<ul>
<li><p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用. 用于修饰它支持的程序元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 标明开发该类模块的作者,  多个作者之间使用,分割</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 标明该类模块的版本</span></span><br><span class="line"><span class="comment"><span class="doctag">@see</span> 参考转向,  也就是相关主题</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 从哪个版本开始增加的</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> 对方法中某参数的说明,  如果没有参数就不能写</span></span><br><span class="line"><span class="comment"><span class="doctag">@return</span> 对方法返回值的说明,  如果方法的返回值类型是void就不能写</span></span><br><span class="line"><span class="comment"><span class="doctag">@exception</span> 对方法可能抛出的异常进行说明 ,  如果方法没有用throws显式抛出的异常就不能写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以上</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> <span class="doctag">@return</span> 和 <span class="doctag">@exception</span> 这三个标记都是只用于方法的.</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span>的格式要求： <span class="doctag">@param</span> 形参名 形参类型 形参说明</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span> 的格式要求： <span class="doctag">@return</span> 返回值类型 返回值说明</span></span><br><span class="line"><span class="comment">    <span class="doctag">@exception</span>的格式要求： <span class="doctag">@exception</span> 异常类型 异常说明</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span>和<span class="doctag">@exception</span>可以并列多个</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成文档相关的注解</p>
</li>
<li><p>在编译时进行格式检查(JDK内置的三个基本注解)</p>
<ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时.通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ul>
</li>
<li><p>跟踪代码依赖性, 实现替代配置文件功能</p>
</li>
</ul>
</li>
<li><p>自定义 Annotation</p>
<ul>
<li><p>定义新的 Annotation 类型使用 @interface 关键字</p>
</li>
<li><p>自定义注解自动继承了<code>java.lang.annotation.Annotation</code>接口</p>
</li>
<li><p><code>Annotation</code> 的成员变量在 <code>Annotation</code> 定义中以无参数方法的形式来声明. 其方法名和返回值定义了该成员的名字和类型. 我们称为配置参数. 类型只能是八种基本数据类型、 String类型、 Class类型、 enum类型、 Annotation类型、以上所有类型的数组.</p>
</li>
<li><p>可以在定义 <code>Annotation</code> 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 <code>default</code> 关键字</p>
</li>
<li><p>如果只有一个参数成员,  建议使用参数名为value</p>
</li>
<li><p>如果定义的注解含有配置参数,  那么使用时必须指定参数值,  除非它有默认值. 格式是“参数名 = 参数值” ,  如果只有一个参数成员,  且名称为value, 可以省略“value=”</p>
</li>
<li><p>没有成员定义的 <code>Annotation</code> 称为标记; 包含成员变量的 <code>Annotation</code> 称为元数据 <code>Annotation</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(value=<span class="string">"尚硅谷"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = MyAnnotationTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Annotation a = clazz.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        MyAnnotation m = (MyAnnotation) a;</span><br><span class="line">        String info = m.value();</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "auguigu"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK 中的元注解</p>
<ul>
<li><p>元注解, 对现有注解修饰的注解</p>
</li>
<li><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义</p>
</li>
<li><p>JDK5.0提供了4个标准的meta-annotation类型,  分别是：</p>
<ul>
<li><p>Retention : 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期</p>
<ul>
<li>@Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值<ul>
<li>RetentionPolicy.SOURCE:在源文件中有效(即源文件保留)</li>
<li>RetentionPolicy.CLASS:在class文件中有效(即class保留)默认行为</li>
<li>RetentionPolicy.RUNTIME:在运行时有效(即运行时保留),当运行 Java 程序时, JVM 会保留注释.程序可以通过反射获取该注释.</li>
</ul>
</li>
</ul>
</li>
<li><p>Target : 指定被修饰的 Annotation 能用于修饰哪些程序元素</p>
<ul>
<li>@Target 也包含一个名为 value 的成员变量<br><img src="https://i.loli.net/2020/03/20/ixvFTZJVjOdNDqg.png" alt="target.png"></li>
</ul>
</li>
<li><p>Documented : (使用较少)用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档. 默认情况下, javadoc是不包括注解的</p>
<ul>
<li>定义为Documented的注解必须设置Retention值为RUNTIME</li>
</ul>
</li>
<li><p>Inherited : (使用较少)被它修饰的 Annotation 将具有继承性.如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解</p>
</li>
</ul>
</li>
<li><p>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上, 子类则可以继承父类类级别的注解</p>
<blockquote>
<p>元数据(对现有数据修饰的数据)的理解：<br>String name = “atguigu”; 中的String 和 name</p>
</blockquote>
</li>
<li><p>自定义注解通常会指明Retention 和 Target</p>
</li>
</ul>
</li>
<li><p>通过反射获取注解信息 — 反射时再写</p>
</li>
<li><p>jdk 8 中注解的新特性: 可重复注解, 类型注解</p>
<ol>
<li>可重复注解 : 可重复定义多个<ul>
<li>在MyAnnotation上声明@Repeatable(), 成员值为MyAnnotations.class</li>
<li>MyAnnotation的@Target,@Retention等和MyAnnotations的相同</li>
</ul>
</li>
<li>类型注解 :  <ul>
<li>在Java 8之前,  注解只能是在声明的地方所使用,  Java8开始,  注解可以应用在任何地方.<ul>
<li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中(如:泛型声明)</li>
<li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="8-Java集合"><a href="#8-Java集合" class="headerlink" title="8. Java集合"></a>8. Java集合</h2><h3 id="8-1-Java集合框架概述"><a href="#8-1-Java集合框架概述" class="headerlink" title="8.1 Java集合框架概述"></a>8.1 Java集合框架概述</h3><ol>
<li><p>集合, 数组都是对多个数据进行存储操作的结构, 是一种容器. (此时的存储指的是内存层面的存储, 不涉及到持久化的存储)</p>
</li>
<li><p>数组在存储多个数据方法的特点:</p>
<ul>
<li>一旦初始化后, 其长度就确定了, 不可修改</li>
<li>数组一旦定义好, 其元素的类型也就确定了, 也就只能操作指定类型的数据了</li>
<li>数组中提供的方法有限, 对增.删.改.查的操作不便捷, 效率不高</li>
<li>获取数组中实际元素的个数的需求, 数组没有现成的属性或方法可用</li>
<li>数组存储数据: 有序, 可重复</li>
</ul>
</li>
<li><p>集合框架</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-----Collection 接口: 单列数据, 用来存储一个一个的数据  </span><br><span class="line">   |-----List： 元素有序、可重复的数据, --&gt;&quot;动态&quot;的数组  </span><br><span class="line">      |-----ArrayList :  List的主要实现类, 线程不安全, 效率高, 底层使用Object[] elementData存储</span><br><span class="line">      |-----LinkedList : 对于频繁的插入和删除, 使用该类, 因为该类底层使用双向链表存储</span><br><span class="line">      |-----Vector : 作为List接口的古老实现类, 线程安全的, 效率低, 底层使用Object[] elementData 存储</span><br><span class="line">   |-----Set： 元素无序、不可重复的数据 --&gt; 数学上的&quot;集合&quot;定义</span><br><span class="line">      |-----HashSet : Set 接口的主要实现类, 线程不安全, 可以存储null值</span><br><span class="line">         |-----LinkedHashSet : HashSet的子类, 遍历其内部数据时, 按照添加顺序进行遍历</span><br><span class="line">      |-----TreeSet : 底层是红黑树构成的, 添加的元素必须是同一个类的对象, 可以按照指定属性进行排序</span><br><span class="line">|-----Map 接口： 双列数据, 保存具有映射关系“key-value对”的集合</span><br><span class="line">   |-----HashMap : 作为Map的主要实现类, 线程不安全, 效率高, 可以存储null的key和value</span><br><span class="line">          底层: 数组+链表(jdk7及之前)</span><br><span class="line">                数组+链表+红黑树(jdk8)</span><br><span class="line">      |-----LinkedHashMap : 保证在遍历map元素时, 可以按照添加的顺序实现遍历(在原有的hashmap底层结构基础上, 添加了一对指针, 指向前一个和后一个元素), 对于频繁的插入和删除, 使用该类</span><br><span class="line">   |-----TreeMap : 可按照指定key-value 的key进行排序, 即考虑key的自然排序和定制排序, 底层使用红黑树</span><br><span class="line">   |-----HashTable : 作为Map的古老实现类, 线程安全, 效率低, 不能存储null的key和value</span><br><span class="line">      |-----Properties : 用来处理配置文件, key和value都是String类型</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="8-2-Collection接口方法"><a href="#8-2-Collection接口方法" class="headerlink" title="8.2 Collection接口方法"></a>8.2 Collection接口方法</h3><ul>
<li>Collection 接口是 List、 Set 和 Queue 接口的父接口, 该接口里定义的方法既可用于操作 Set 集合, 也可用于操作 List 和 Queue 集合</li>
<li>JDK不提供此接口的任何直接实现, 而是提供更具体的子接口(如： Set和List)实现</li>
<li>在 Java5 之前,  Java 集合会丢失容器中所有对象的数据类型, 把所有对象都当成 Object 类型处理； 从 JDK 5.0 增加了泛型以后,  Java 集合可以记住容器中对象的数据类型</li>
</ul>
<hr>
<ul>
<li>Collection接口方法</li>
</ul>
<ol>
<li>添加<ul>
<li>add(Object obj) 将obj添加到集合中</li>
<li>addAll(Collection coll) 将coll集合中的所有元素添加到集合中</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>int size()</li>
</ul>
</li>
<li>清空集合<ul>
<li>void clear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>boolean contains(Object obj)： 是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection c)： 也是调用元素的equals方法来比较的. 拿两个集合的元素挨个比较</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj) ： 通过元素的equals方法判断是否是要删除的那个元素. 只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)： 取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)： 把交集的结果存在当前集合中, 不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
<li>数组 –&gt; 集合: Arrays类的静态方法asList()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()： 返回迭代器对象, 用于集合遍历</li>
</ul>
</li>
</ol>
<ul>
<li>注:  </li>
</ul>
<p><strong>向Collection接口的实现类的对象中添加数据obj时, 要求obj所在类重写equals()方法</strong></p>
<ul>
<li>即 List : 要重写equals()方法(做remove, compare等方法时需要用到比较)</li>
<li>HashSet,LinkedHashSet : 重写equals()方法和hashCode()方法  </li>
<li>TreeSet : Comparable接口 – compareTo(Object obj)方法<br>Comparator接口 – compare(Object o1, Object o2)方法</li>
</ul>
<h3 id="8-3-Iterator迭代器接口"><a href="#8-3-Iterator迭代器接口" class="headerlink" title="8.3 Iterator迭代器接口"></a>8.3 Iterator迭代器接口</h3><ul>
<li><p>Iterator对象称为迭代器(设计模式的一种), 主要用于遍历 Collection 集合中的元素</p>
</li>
<li><p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素, 而又不需暴露该对象的内部细节.</p>
<ul>
<li>迭代器模式, 就是为容器而生. 类似于“公交车上的售票员”、“火车上的乘务员”、 “空姐”</li>
</ul>
</li>
<li><p>Collection接口继承了java.lang.Iterable接口, 该接口有一个iterator()方法, 那么所有实现了Collection接口的集合类都有一个iterator()方法, 用以返回一个实现了Iterator接口的对象</p>
</li>
<li><p>Iterator 仅用于遍历集合,  Iterator 本身并不提供承装对象的能力.如果需要创建Iterator 对象, 则必须有一个被迭代的集合</p>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象, 默认游标都在集合的第一个元素之前</p>
</li>
<li><p>Iterator接口的方法</p>
<ul>
<li>boolean hasNext(); 判断是否还有下一个元素</li>
<li>E next():  <ol>
<li>指针下移  </li>
<li>将下移以后集合位置上的元素返回</li>
<li>如果超出个数后, 抛异常NoSuchElementException</li>
</ol>
</li>
<li>void remove(); 删除集合的元素<blockquote>
<p>Iterator可以删除集合的元素,  但是是遍历过程中通过迭代器对象的remove方法,  不是集合对象的remove方法<br>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法, 再调用remove都会报IllegalStateException</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="8-4-Collection子接口-List"><a href="#8-4-Collection子接口-List" class="headerlink" title="8.4 Collection子接口: List"></a>8.4 Collection子接口: List</h3><ul>
<li><p>List集合类中元素<strong>有序、且可重复</strong>, 集合中的每个元素都有其对应的顺序索引</p>
<ul>
<li>有序性是指: 存储的元素按照数组索引一个个存储</li>
</ul>
</li>
<li><p>List接口的实现类常用的有： ArrayList、 LinkedList和Vector</p>
<ul>
<li><strong>ArrayList</strong> : List的主要实现类, 线程不安全, 效率高, 底层使用Object[] elementData存储</li>
<li><strong>LinkedList</strong> : 对于频繁的插入和删除, 使用该类, 因为该类底层使用双向链表存储</li>
<li><strong>Vector</strong> : 作为List接口的古老实现类, 线程安全的, 效率低, 底层使用Object[] elementData 存储</li>
</ul>
</li>
<li><p>ArrayList 源码分析</p>
<ul>
<li><p>JDK 7版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层创建了长度为10的Object[]数组 elementData</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>); <span class="comment">// 当此次添加导致elementData数组容量不够, 则扩容,</span></span><br><span class="line"><span class="comment">// 默认情况下扩容至原来容量的1.5倍,即加上原来的一半, 向下取整 同时将原有数组中的数据复制到新数组中Arrays.copyOf(elementData, newCapacity);</span></span><br><span class="line"><span class="comment">// 结论: 建议开发中在使用带参构造器, ArrayList list  = new ArrayList(int capacity)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK 8中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层创建了Object[] elementData 初始化为&#123;&#125;, 并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 第一次调用add()时, 底层才创建了长度为10的数组, 并将123添加到elementData中</span></span><br><span class="line"><span class="comment">// 后续添加与扩容与jdk7相同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小结: jdk7中Array List对象的创建类似于单例的饿汉式, 而jdk8中,累死懒汉式, 延迟了数组的创建, 节省内存</p>
</li>
</ul>
</li>
<li><p>LinkedList 源码分析</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); <span class="comment">// 内部声明了Node类型的first和last属性, 默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 将123封装到node中, 创建Node对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中, Node定义为</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 体现了双向的特点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>List除了从Collection集合继承的方法外,  List 集合里添加了一些根据索引来操作集合元素的方法:</p>
<ul>
<li>void add(int index, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素, 并返回此元素<ul>
<li>注意区分和collection类中的remove方法, remove(Object obj)</li>
</ul>
</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
</ul>
<h3 id="8-5-Collection子接口-Set"><a href="#8-5-Collection子接口-Set" class="headerlink" title="8.5 Collection子接口: Set"></a>8.5 Collection子接口: Set</h3><ul>
<li><p>Set 存储<strong>无序的, 不可重复</strong>的数据</p>
</li>
<li><p>Set接口是Collection的子接口,  set接口没有提供额外的方法</p>
</li>
<li><p>Set 集合不允许包含相同的元素, 如果试把两个相同的元素加入同一个Set 集合中, 则添加操作失败</p>
</li>
<li><p>Set 判断两个对象是否相同不是使用 == 运算符, 而是根据 equals() 方法</p>
</li>
<li><p>Set 的实现类有: HashSet, LinkedHashSet, TreeSet</p>
<ul>
<li>HashSet : Set 接口的主要实现类, 线程不安全, 可以存储null值</li>
<li>LinkedHashSet : HashSet的子类, 遍历其内部数据时, 按照添加顺序进行遍历</li>
<li>TreeSet : 底层是红黑树构成的, 添加的元素必须是同一个类的对象, 可以按照指定属性进行排序</li>
</ul>
</li>
<li><p>HashSet的使用</p>
<ol>
<li>无序性:(不是随机性)<ul>
<li>以HashSet为例: 指存储的数据在底层数组中并非按照数组索引的顺序添加, 是按照数据的哈希值决定的.</li>
</ul>
</li>
<li>不可重复性:<ul>
<li>保证添加的元素按照equals()判断时, 不能返回true</li>
</ul>
</li>
<li>添加元素的过程, 以HashSet为例:<ul>
<li>向HashSet中添加元素a,首先调用a的所在类的hashCode()方法, 计算a的哈希值, 此哈希值通过某种算法计算出在HashSet底层数组中的存放位置(即为索引位置), 判断此位置上是否已经有元素, 如果没有, 则a添加成功, 如果此位置上已经有元素b(或以链表形式存在的多个元素), 则比较a与b的hash值; 如果hash值不同, 则a添加成功, 如果hash值相同, 则要调用a的所在类的equals方法, equals方法返回true, 则添加失败, 如果返回false, 则a添加成功.</li>
<li>若此位置上已经存在元素, a添加成功后, 与已有元素以链表的方式存储.<ul>
<li>jdk7: a放到数组中, 指向原来的元素</li>
<li>jdk8: 原来的元素在数组中, 指向元素a</li>
</ul>
</li>
<li>即HashSet的底层是 : 数组 + 链表实现的<blockquote>
<p>注: 添加到Set中的元素必须重写equals()和hashCode()方法</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li><p>LinkedHashSet 的使用</p>
<ul>
<li>可以按照添加的顺序遍历</li>
<li>LinkedHashSet 作为HashSet的子类, 在添加数据的同时, 还维护了2个引用, 记录此数据的前一个数据和后一个数据<ul>
<li>优点: 对于频繁的遍历操作,LindedHashSet 效率高于HashSet  </li>
</ul>
</li>
</ul>
</li>
<li><p>TreeSet 的使用</p>
<ul>
<li>按照指定属性进行排序</li>
</ul>
<ol>
<li>向TreeSet中添加的数据, 要求是相同类的对象</li>
<li>两种排序方式, 自然排序(实现comparable接口,重写compareTo()方法)和定制排序(实现comparator接口重写compare()方法)<ul>
<li>自然排序中, 比较两个对象是否相同的标准为: compareTo()返回0, 不是equals()方法</li>
<li>定制排序中, 比较标准为: compare()方法</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="8-6-Map接口"><a href="#8-6-Map接口" class="headerlink" title="8.6 Map接口"></a>8.6 Map接口</h3><ul>
<li><p>存储双列数据, 存储key-value对的数据</p>
<ul>
<li>HashSet : Set 接口的主要实现类, 线程不安全, 可以存储null值</li>
<li>LinkedHashSet : HashSet的子类, 遍历其内部数据时, 按照添加顺序进行遍历</li>
<li>TreeSet : 底层是红黑树构成的, 添加的元素必须是同一个类的对象, 可以按照指定属性进行排序</li>
<li>Map 接口： 双列数据, 保存具有映射关系“key-value对”的集合</li>
<li>HashMap : 作为Map的主要实现类, 线程不安全, 效率高, 可以存储null的key和value  <ul>
<li>底层:<br>数组+链表(jdk7及之前)<br>数组+链表+红黑树(jdk8)</li>
</ul>
</li>
</ul>
</li>
<li><p>Map结构</p>
<ul>
<li>key : 不能重复的, 无序的,用Set存储所有的key, key所在的类要重写equals()和hashcode()方法</li>
<li>value : 可以重复, 也是无序的, 用Collection存所有的value, value所在类要重写equals()</li>
<li>一个键值对Entry对象 : key-value</li>
<li>enrty : 无序的, 不可重复的, 使用Set存储</li>
</ul>
</li>
<li><p>HashMap源码分析</p>
<ul>
<li><p>jdk7</p>
<ul>
<li><p>HashMap map = new HashMap(); 在实例化后, 底层创建了长度16的数组Entry[] table</p>
</li>
<li><p>map.put(key1, value1):</p>
<ul>
<li>首先调用key1的hashCode()方法, 计算其哈希值, 经过某种算法计算后, 得到在Entry[] 中的存放位置</li>
<li>如果此位置上数据为空, key1-value1添加成功</li>
<li>如果此位置上存在1个或多个数据(链表形式存储), 比较key1和已存在数据的哈希值, 如果都不相同, 则key1-value1添加成功</li>
<li>如果key1和已存在数据哈希值相同, 调用key1的equals()方法, 返回false. 添加成功; 返回true, 使用value1替换相同key的value值</li>
</ul>
</li>
<li><p>默认扩容方式是: 超出临界值时(且要存放的位置非空时)扩容为原来的2倍, 并将原有数据复制</p>
</li>
</ul>
</li>
<li><p>jdk8</p>
<ol>
<li>new HashMap():底层没有创建长度为16的数组</li>
<li>jdk8 底层的数组是 Node[], 非Entry[]</li>
<li>首次调用put()方法时, 创建长度为16的数组</li>
<li>jdk7底层结构为 : 数组+链表; jdk8中是: 数组+链表+红黑树<ul>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且 当前数组的长度 &gt; 64时; 此索引位置上的所有数据改为红黑树存储</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>LinkedHashMap 源码分析(了解)</p>
<ul>
<li>可以根据添加的顺序进行遍历</li>
</ul>
</li>
</ul>
<h3 id="8-7-Collections工具类"><a href="#8-7-Collections工具类" class="headerlink" title="8.7 Collections工具类"></a>8.7 Collections工具类</h3><ul>
<li><p>操作集合的工具类, set, List Map</p>
</li>
<li><p>常用方法:  </p>
<ul>
<li>排序操作： (均为static方法)<ul>
<li><code>reverse(List)</code>： 反转 List 中元素的顺序<ul>
<li><code>shuffle(List)</code>： 对 List 集合元素进行随机排序</li>
</ul>
</li>
<li><code>sort(List)</code>： 根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List,  Comparator)</code>： 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List,  int,  int)</code>： 将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
</li>
<li>查找、替换<ul>
<li><code>Object max(Collection)</code>： 根据元素的自然顺序, 返回给定集合中的最大元素</li>
<li><code>Object max(Collection,  Comparator)</code>： 根据 Comparator 指定的顺序, 返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code><br><code>Object min(Collection,  Comparator)</code></li>
<li><code>int frequency(Collection,  Object)</code>： 返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list,  Object oldVal,  Object newVal)</code>： 使用新值替换 List 对象的所有旧值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-泛型与File类"><a href="#9-泛型与File类" class="headerlink" title="9. 泛型与File类"></a>9. 泛型与File类</h2><h3 id="9-1-泛型"><a href="#9-1-泛型" class="headerlink" title="9.1 泛型"></a>9.1 泛型</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li>所谓泛型,  就是允许在定义类、 接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型. 这个类型参数将在使用时（例如, 继承或实现这个接口,  用这个类型声明变量、 创建对象时） 确定（即传入实际的类型参数,  也称为类型实参）</li>
<li>从JDK1.5以后, Java引入了“参数化类型（ Parameterized type） ” 的概念, 允许我们在创建集合时再指定集合元素的类型,  正如： List&lt;String&gt;,  这表明该List只能保存字符串类型的对象</li>
<li>Java泛型可以保证如果程序在编译时没有发出警告, 运行时就不会产生<code>ClassCastException</code>异常.同时, 代码更加简洁、健壮</li>
</ul>
<h4 id="2-在集合中使用泛型"><a href="#2-在集合中使用泛型" class="headerlink" title="2. 在集合中使用泛型"></a>2. 在集合中使用泛型</h4><ul>
<li><p>代码示例</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line">list.add(<span class="number">78</span>);</span><br><span class="line">list.add(<span class="number">88</span>);</span><br><span class="line">list.add(<span class="number">77</span>);</span><br><span class="line">list.add(<span class="number">66</span>);</span><br><span class="line"><span class="comment">//遍历方式一：</span></span><br><span class="line"><span class="comment">//for(Integer i : list)&#123;</span></span><br><span class="line"><span class="comment">//不需要强转</span></span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//遍历方式二：</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"Tom1"</span>,<span class="number">34</span>);</span><br><span class="line">map.put(<span class="string">"Tom2"</span>,<span class="number">44</span>);</span><br><span class="line">map.put(<span class="string">"Tom3"</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"Tom4"</span>,<span class="number">32</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//map.put(33, "Tom");  //添加失败</span></span><br><span class="line">Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">"---&gt;"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-自定义泛型结构"><a href="#3-自定义泛型结构" class="headerlink" title="3. 自定义泛型结构"></a>3. 自定义泛型结构</h4><ul>
<li>3种自定义泛型结构的形式:<ol>
<li>自定义泛型类</li>
<li>自定义泛型接口</li>
<li>自定义泛型方法</li>
</ol>
</li>
</ul>
<ol>
<li><p>自定义泛型结构：泛型类、泛型接口</p>
<ol>
<li>泛型类可能有多个参数, 此时应将多个参数一起放在尖括号内.比如：<code>&lt;E1,E2,E3&gt;</code></li>
<li>泛型类的构造器如下： <code>public GenericClass(){}</code>.<br>而下面是错误的： <code>public GenericClass&lt;E&gt;(){}</code></li>
<li>实例化后, 操作原来泛型位置的结构必须与指定的泛型类型一致.</li>
<li>泛型不同的引用不能相互赋值.<blockquote>
<p>尽管在编译时<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>是两种类型, 但是, 在运行时只有一个ArrayList被加载到JVM中.</p>
</blockquote>
</li>
<li>泛型如果不指定, 将被擦除, 泛型对应的类型均按照Object处理, 但不等价于Object.<br>经验： 泛型要使用一路都用.要不用, 一路都不要用.</li>
<li>如果泛型结构是一个接口或抽象类, 则不可创建泛型类的对象.</li>
<li>jdk1.7, 泛型的简化操作： <code>ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</code></li>
<li>泛型的指定中不能使用基本数据类型, 可以使用包装类替换.</li>
<li>在类/接口上声明的泛型, 在本类或本接口中即代表某种类型, 可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型.<strong>但在静态方法中不能使用类的泛型.</strong></li>
<li>异常类不能是泛型的</li>
<li>不能使用<code>new E[]</code>.但是可以： <code>E[] elements = (E[])new Object[capacity];</code><br>参考： ArrayList源码中声明： <code>Object[] elementData</code>,  而非泛型参数类型数组.</li>
<li>父类有泛型, 子类可以选择保留泛型也可以选择指定泛型类型：  <ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型 擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>结论：子类必须是“富二代”, 子类除了指定或保留父类的泛型, 还可以增加自己的泛型</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、使用时：类似于Object, 不等同于Object</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// list.add(new Date());//有风险</span></span><br><span class="line">        list.add(<span class="string">"hello"</span>);</span><br><span class="line">        test(list);<span class="comment">// 泛型擦除, 编译不会类型检查</span></span><br><span class="line">        <span class="comment">// ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line">        <span class="comment">// test(list2);//一旦指定Object, 编译会类型检查, 必须按照Object处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            str += s + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"元素:"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 使用T类型定义变量</span></span><br><span class="line">    <span class="keyword">private</span> T info;</span><br><span class="line">    <span class="comment">// 使用T类型定义一般方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用T类型定义构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static的方法中不能声明泛型</span></span><br><span class="line">    <span class="comment">//public static void show(T t) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">// 不能在try-catch中使用泛型定义</span></span><br><span class="line">    <span class="comment">//public void test() &#123;</span></span><br><span class="line">    <span class="comment">//try &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125; catch (MyException&lt;T&gt; ex) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>自定义泛型结构：泛型方法</p>
<ul>
<li><p>方法: 也可以被泛型化, 不管此时定义在其中的类是不是泛型类. 在泛型方法中可以定义泛型参数, 此时, 参数的类型就是传入数据的类型.</p>
</li>
<li><p>泛型方法的格式:<br>[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</p>
</li>
<li><p>泛型方法声明泛型时也可以指定上限</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> id, E e)</span> </span>&#123;</span><br><span class="line">        E result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object[] ao = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    Collection&lt;Object&gt; co = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    fromArrayToCollection(ao, co);</span><br><span class="line">    String[] sa = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">    Collection&lt;String&gt; cs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fromArrayToCollection(sa, cs);</span><br><span class="line">    Collection&lt;Double&gt; cd = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 下面代码中T是Double类, 但sa是String类型, 编译错误.</span></span><br><span class="line">    <span class="comment">// fromArrayToCollection(sa, cd);</span></span><br><span class="line">    <span class="comment">// 下面代码中T是Object类型,  sa是String类型, 可以赋值成功.</span></span><br><span class="line">    fromArrayToCollection(sa, co);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Person&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Person());</span><br><span class="line">        test(<span class="keyword">new</span> Man());</span><br><span class="line">        <span class="comment">//The method test(T) in the type PersonTest is not</span></span><br><span class="line">        <span class="comment">//applicable for the arguments (Creature)</span></span><br><span class="line">        test(<span class="keyword">new</span> Creature());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="4-泛型在继承上的体现"><a href="#4-泛型在继承上的体现" class="headerlink" title="4. 泛型在继承上的体现"></a>4. 泛型在继承上的体现</h4><ul>
<li><p>如果B是A的一个子类型（子类或者子接口）, 而G是具有泛型声明的类或接口,  G&lt;B&gt;并不是G&lt;A&gt;的子类型！<br>比如： String是Object的子类, 但是<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenericAndSubClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person[] persons = <span class="keyword">null</span>;</span><br><span class="line">    Man[] mans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 而 Person[] 是 Man[] 的父类.</span></span><br><span class="line">    persons = mans;</span><br><span class="line">    Person p = mans[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 在泛型的集合上</span></span><br><span class="line">    List&lt;Person&gt; personList = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Man&gt; manList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// personList = manList;(报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-通配符的使用"><a href="#5-通配符的使用" class="headerlink" title="5. 通配符的使用"></a>5. 通配符的使用</h4><ul>
<li><p>概述:</p>
<ol>
<li>使用类型通配符：<code>？</code><br>比如： <code>List&lt;?&gt;</code> ,  <code>Map&lt;?,?&gt;</code><br><code>List&lt;?&gt;</code>是<code>List&lt;String&gt;</code>、 <code>List&lt;Object&gt;</code>等各种泛型List的父类.</li>
<li>读取<code>List&lt;?&gt;</code>的对象list中的元素时, 永远是安全的, 因为不管list的真实类型是什么, 它包含的都是Object.</li>
<li>写入list中的元素时, 不行.因为我们不知道c的元素类型, 我们不能向其中添加对象.</li>
</ol>
<ul>
<li><p>将任意元素加入到其中不是类型安全的：<br><code>Collection&lt;?&gt; c = new ArrayList&lt;String&gt;();</code><br><code>c.add(new Object()); // 编译时错误</code></p>
<ul>
<li>因为我们不知道c的元素类型，我们不能向其中添加对象。 add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去</li>
<li>唯一的例外的是null，它是所有类型的成员</li>
<li>另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    <span class="comment">// list.add(3);//编译不通过</span></span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    l1.add(<span class="string">"尚硅谷"</span>);</span><br><span class="line">    l2.add(<span class="number">15</span>);</span><br><span class="line">    read(l1);</span><br><span class="line">    read(l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTypeClass</span>&lt;?&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</span></span><br><span class="line">ArrayList&lt;?&gt; list2 = <span class="keyword">new</span> ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有限制的通配符:</p>
</li>
<li><p><code>&lt;?&gt;</code> :  允许所有泛型的引用调用</p>
</li>
<li><p>通配符指定上限: 上限<code>extends</code>：使用时指定的类型必须是继承某个类，或者实现某个接口，即 &lt;=</p>
</li>
<li><p>通配符指定下限: 下限<code>super</code>：使用时指定的类型不能小于操作的类，即 &gt;=</p>
</li>
<li><p>举例：</p>
<ul>
<li><p><code>&lt;? extends Number&gt;</code> (无穷小 , Number] 只允许泛型为Number及Number子类的引用调用</p>
</li>
<li><p><code>&lt;? super Number&gt;</code> [Number , 无穷大) 只允许泛型为Number及Number父类的引用调用</p>
</li>
<li><p><code>&lt;? extends Comparable&gt;</code> 只允许泛型为实现Comparable接口的实现类的引用调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection3</span><span class="params">(Collection&lt;? extends Person&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why?</span></span><br><span class="line">    Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection4</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Person&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why?</span></span><br><span class="line">        Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="9-2-File类"><a href="#9-2-File类" class="headerlink" title="9.2 File类"></a>9.2 File类</h3><ul>
<li>File类是一个与系统无关的类, 任何操作系统都可以使用这个类中的方法</li>
</ul>
<h4 id="1-File概述"><a href="#1-File概述" class="headerlink" title="1. File概述"></a>1. File概述</h4><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示, 主要用于文件和目录的创建、查找和删除等操作.</p>
<ul>
<li>File.pathSeparator 路径分隔符, windows系统中是 ; , Linux是 : .  </li>
<li>File.separator 文件名称分隔符,  windows是 反斜杠 , Linux是正斜杠/  </li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h4><ul>
<li><p><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例.  </p>
</li>
<li><p><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例.  </p>
</li>
<li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例.  </p>
</li>
<li><p>构造举例, 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">"D:\\aaa.txt"</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">"D:\\aaa\\bbb.txt"</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">String parent = <span class="string">"d:\\aaa"</span>;</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录.</li>
<li>无论该路径下是否存在文件或者目录, 都不影响File对象的创建, 也就是说创建File对象, 只是把字符串路径封装为File对象, 不考虑路径的真假情况</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3 常用方法"></a>3 常用方法</h4><h5 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h5><ul>
<li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串.</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串.</p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称.  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度.</p>
<ul>
<li><p>方法演示, 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:/aaa/bbb.java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"文件绝对路径:"</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"文件构造路径:"</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">"文件名称:"</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">"文件长度:"</span>+f.length()+<span class="string">"字节"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:/aaa"</span>);</span><br><span class="line">        System.out.println(<span class="string">"目录绝对路径:"</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"目录构造路径:"</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">"目录名称:"</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">"目录长度:"</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：length( ), 表示文件的长度.若File对象表示目录, 则返回值未指定.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h5><ul>
<li><p><strong>绝对路径</strong>：从盘符开始的路径, 这是一个完整的路径.</p>
</li>
<li><p><strong>相对路径</strong>：相对于项目目录的路径, 这是一个便捷的路径, 开发中经常使用.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\bbb.java"</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"bbb.java"</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h5><ul>
<li><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在.</p>
</li>
<li><p><code>public boolean isDirectory()</code> ：此File表示的是否为目录.</p>
</li>
<li><p><code>public boolean isFile()</code> ：此File表示的是否为文件.</p>
</li>
<li><p>方法演示, 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:\\aaa\\bbb.java"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">        <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa\\bbb.java 是否存在:"</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 是否存在:"</span>+f2.exists());</span><br><span class="line">        <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 文件?:"</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 目录?:"</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h5><ul>
<li><p><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时, 创建一个新的空文件.  </p>
</li>
<li><p><code>public boolean delete()</code> ：删除由此File表示的文件或目录.  </p>
</li>
<li><p><code>public boolean mkdir()</code> ：创建由此File表示的目录.</p>
</li>
<li><p><code>public boolean mkdirs()</code> ：创建由此File表示的目录, 包括任何必需但不存在的父目录.</p>
</li>
<li><p>方法演示, 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"aaa.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目录的创建</span></span><br><span class="line">        File f2= <span class="keyword">new</span> File(<span class="string">"newDir"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f2.mkdir()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多级目录</span></span><br><span class="line">        File f3= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件的删除</span></span><br><span class="line">        System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法, 如果此File表示目录, 则目录必须为空才能删除.</p>
</blockquote>
</li>
</ul>
<h4 id="4-目录的遍历"><a href="#4-目录的遍历" class="headerlink" title="4. 目录的遍历"></a>4. 目录的遍历</h4><ul>
<li><p><code>public String[] list()</code> ：返回一个String数组, 表示该File目录中的所有子文件或目录.</p>
</li>
<li><p><code>public File[] listFiles()</code> ：返回一个File数组, 表示该File目录中的所有的子文件或目录.  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹的名称.</span></span><br><span class="line">        String[] names = dir.list();</span><br><span class="line">        <span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象, 只要拿到了文件对象, 那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:<br>调用listFiles方法的File对象, 必须是实际存在的目录, 否则返回null, 无法进行遍历.  </p>
</blockquote>
</li>
</ul>
<h4 id="5-文件过滤器"><a href="#5-文件过滤器" class="headerlink" title="5. 文件过滤器"></a>5. 文件过滤器</h4><p>在File类中,有2个和ListFiles重载的方法,方法的参数传递的就是过滤器</p>
<ol>
<li><p><code>File[] listFiles(FileFilter filter)</code> 返回抽象路径名(File对象)数组</p>
<ul>
<li>这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录.</li>
</ul>
</li>
<li><p><code>File[] listFiles(FilenameFilter filter)</code> 返回抽象路径名(File对象)数组  </p>
<ul>
<li>这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录.</li>
</ul>
</li>
</ol>
<ul>
<li><p><code>java.io.FileFilter</code> 是一个接口, 是File对象的过滤器.  </p>
<ul>
<li>作用: 用来过滤文件(File对象)  </li>
<li>抽象方法:用来过滤文件的方法  </li>
<li><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中, 符合则返回true.  </li>
<li>参数: <code>pathname</code> 使用<code>ListFiles</code>方法遍历目录.得到每一个文件对象  </li>
</ul>
</li>
<li><p><code>java.io.FilenameFilter</code>接口: 实现此接口的类实例可用于过滤器文件名  </p>
<ul>
<li><p>作用: 用于过滤文件名称</p>
</li>
<li><p>抽象方法:用来过滤文件的方法</p>
</li>
<li><p><code>boolean accept(File dir, String name)</code> 测试指定文件是否应该包含在某一文件列表中  </p>
</li>
<li><p>参数：  </p>
<ul>
<li>dir - 被找到的文件所在的目录.  </li>
<li>name - 文件的名称.  </li>
</ul>
</li>
<li><p>返回：  </p>
<ul>
<li>当且仅当该名称应该包含在文件列表中时返回 true；否则返回 false</li>
</ul>
<blockquote>
<p>注意:<br>两个过滤器接口是没有实现类的,需要我们自己写实现类,重写过滤的方法accept,在方法中自定义过滤的规则</p>
</blockquote>
</li>
</ul>
</li>
<li><p>分析：  </p>
<ol>
<li><p>接口作为参数, 需要传递子类对象, 重写其中方法.我们选择匿名内部类方式, 比较简单.</p>
</li>
<li><p>accept方法, 参数为File, 表示当前File下所有的子文件和子目录.保留住则返回true, 过滤掉则返回false.</p>
</li>
<li><p>通过过滤器的作用, listFiles(FileFilter)返回的数组元素中, 子文件对象都是符合条件的, 可以直接打印.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterImpl</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保留住则返回true, 过滤掉则返回false.</span></span><br><span class="line">        <span class="comment">// 如果pathname是一个文件夹,也返回true, 继续遍历这个文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础学习笔记(一)</title>
    <url>/posts/ccb0c92d.html</url>
    <content><![CDATA[<h2 id="1-NoSQL-概念"><a href="#1-NoSQL-概念" class="headerlink" title="1. NoSQL 概念"></a>1. NoSQL 概念</h2><h3 id="1-NoSQL-数据模型简介"><a href="#1-NoSQL-数据模型简介" class="headerlink" title="1. NoSQL 数据模型简介"></a>1. NoSQL 数据模型简介</h3><ul>
<li><p>聚合模型</p>
<ol>
<li><p>KV键值对</p>
</li>
<li><p>Bson: JSON串的数据表达</p>
</li>
<li><p>列族:</p>
</li>
<li><p>图形</p>
<blockquote>
<p><a href="https://github.com/xingbofeng/Reading-Note/blob/master/%E3%80%8ANoSQL%E7%B2%BE%E7%B2%B9%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.md" target="_blank" rel="noopener">聚合模型</a></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="2-NoSQL数据库四大分类"><a href="#2-NoSQL数据库四大分类" class="headerlink" title="2. NoSQL数据库四大分类"></a>2. NoSQL数据库四大分类</h3><ol>
<li>KV键值对: redis, memcache, tair, BerkeleyDB</li>
<li>文档型数据库(Bson格式):CouchDB, MongoDB: 基于分布式文件存储的数据库, 介于关系型数据库和非关系数据库之间</li>
<li>列族: HBase, Cassandra, 分布式文件系统</li>
<li>图形: 放的是图谱, Neo4J, InfoGrid</li>
</ol>
<a id="more"></a>

<h3 id="3-分布式数据库中的CAP原理"><a href="#3-分布式数据库中的CAP原理" class="headerlink" title="3. 分布式数据库中的CAP原理"></a>3. 分布式数据库中的CAP原理</h3><ul>
<li><p>传统的关系型数据库是 ACID  </p>
<ul>
<li>Atomicity 原子性  要么都执行，要么都回滚</li>
<li>Consistency 一致性  保证数据的状态操作前和操作后保持一致</li>
<li>Isolation 独立性  多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</li>
<li>Durability 持久性  一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</li>
</ul>
</li>
<li><p>NoSQL 中的 CAP+BASE</p>
<p><img src="https://i.loli.net/2020/03/20/cMZRBv9VHQyEXoO.png" alt="cap.png"></p>
<ul>
<li>Consitency 强一致性 : 写操作之后的读操作，必须返回该值</li>
<li>Availability 可用性 : 只要收到用户的请求，服务器就必须给出回应</li>
<li>Partition tolerance 分区容错性 : 区间通信可能失败</li>
<li>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到</li>
<li><a href="https://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP定理含义</a></li>
</ul>
</li>
<li><p>CAP的3进2</p>
<ul>
<li>CAP理论的核心是: 一个分布式系统不可以同时很好的满足一致性, 可用性和分区容错性这3个需求.</li>
<li>最多只能同时较好的满足其中2个</li>
<li>CA 单点集群, 满足一致性和可用性, 扩展性不强, 传统的数据库, MySQL, Oracle</li>
<li>CP 满足一致性, 分区容错性, 性能不高, NoSQL, MongoDB,redis,HBase</li>
<li>AP 满足可用性, 分区容错性, 对一致性要求低, CouchDB…,大多数网站架构的选择</li>
</ul>
</li>
<li><p>BASE 是为了解决关系数据库强一致性引起的可用性降低而提出的解决方案</p>
<ul>
<li>Basically Availabel 基本可用</li>
<li>Soft state 软状态</li>
<li>Eventually consistent 最终一致</li>
<li>通过让系统对某一时刻的数据一致性的要求来换取系统整体伸缩性和性能上改观, 即牺牲C换取AP,通过BASE再达到C</li>
</ul>
</li>
</ul>
<h3 id="4-分布式-集群简介"><a href="#4-分布式-集群简介" class="headerlink" title="4. 分布式+集群简介"></a>4. 分布式+集群简介</h3><ul>
<li>分布式: 不同的多台服务器上部署不同的服务模块(工程), 他们之间通过Rpc/Rmi之间通信和调用, 对外提供服务和组内协助</li>
<li>集群: 不同的多台服务器上面部署相同的服务模块, 通过分布式调度软件进行同意的调度, 对外提供服务和访问</li>
</ul>
<h2 id="2-Redis-介绍"><a href="#2-Redis-介绍" class="headerlink" title="2. Redis 介绍"></a>2. Redis 介绍</h2><ul>
<li>REmote DIctionary Server(远程字典服务器)<ul>
<li>C语言写的, 遵守BSD协议, 是一个高性能的KV分布式内存数据库, 基于内存运行, 并支持持久化的NoSQL数据库</li>
<li>支持异步将内存中的数据写到硬盘上, 同时不影响继续服务</li>
<li>取最新N个数据</li>
<li>模拟类似HttpSession这种要设定过期时间的功能</li>
<li>发布,订阅消息系统</li>
<li>定时器, 计数器  </li>
</ul>
</li>
<li>特点:<ul>
<li>redis支持数据的持久化, 可以将内存中的数据保存再磁盘中, 重启的时候可以再次加载使用</li>
<li>redis不仅支持KV存储, 还提供了list,set,zset,hash等数据结构的存储</li>
<li>redis支持数据备份, 即master-slave模式的数据备份</li>
<li>KV + cache + persistent</li>
</ul>
</li>
</ul>
<h3 id="1-Redis的5大数据类型"><a href="#1-Redis的5大数据类型" class="headerlink" title="1. Redis的5大数据类型"></a>1. Redis的5大数据类型</h3><ul>
<li><p>String字符串</p>
<ul>
<li>一个key对应一个value</li>
<li>string 类型是二进制安全的, 可以包含任何数据, 比如图片或序列化的对象</li>
<li>string 是redis最基本的类型, 一个redis中字符串value最多可以是512M</li>
</ul>
</li>
<li><p>Hash哈希</p>
<ul>
<li>是一个键值对集合, 类似Java的Map</li>
<li>redis hash 是一个 string 类的field 和value 的映射表, 适合存储对象, 类似Object&lt;String, Object&gt;</li>
</ul>
</li>
<li><p>List列表</p>
<ul>
<li>简单的字符串列表, 按照插入的顺序排序, 可以添加一个元素到列表的头部或尾部</li>
<li>底层实际是个链表</li>
</ul>
</li>
<li><p>Set集合</p>
<ul>
<li>string类型的无序,不能重复集合, 通过hashTable实现</li>
</ul>
</li>
<li><p>Zset有序集合</p>
<ul>
<li>和set一样是string类型的集合, 不同的是每个元素关联一个double类型的分数, redis通过分数对集合中的成员进行从大到小的排序, zset的成员是唯一的, 分数却可以重复</li>
</ul>
</li>
<li><p><a href="http://redisdoc.com" target="_blank" rel="noopener">redis命令手册</a></p>
</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li>redis键(key)<ul>
<li>keys *</li>
<li>exists key, 判断key是否存在, 1存在, 0不存在</li>
<li>move key num, 移动key至num号库, 当前库没有该key</li>
<li>expire key 秒数, 给指定key设置过期时间</li>
<li>ttl key 看出key还有多少秒过期, -1永不过期, -2 已过期(自动删除了)</li>
<li>type key 查看key是什么类型</li>
<li>del key 删除该key</li>
<li>set key value 为key 设定value, 若key已存在, 覆盖旧的值</li>
</ul>
</li>
<li>redis字符串(String)<ul>
<li>set/get/del/append/strlen</li>
<li>incr/decr/incrby/decrby 是数字才可以加减</li>
<li>getrange/setrange key 0 3; 获取[0,3]</li>
<li>setex key 12 value;  key 只存活12s</li>
<li>setnx(if not exist) key value;</li>
<li>mset/mget/msetnx</li>
</ul>
</li>
<li>redis列表(List)<ul>
<li>lpush/rpush/lrange</li>
<li>lpop/rpop</li>
<li>lindex</li>
<li>llen</li>
<li>lrem key N value; 删除N个值</li>
<li>ltrim key begin edn; 截取指定范围的值在赋值给key</li>
<li>rpoplpush 源列表 目标列表</li>
<li>lset key index value</li>
<li>linsert key before/after 值1 值2</li>
</ul>
</li>
<li>redis集合(set)<ul>
<li>sadd/smember/sismember</li>
<li>scard 获取集合元素个数</li>
<li>srem key value</li>
<li>srandmember key num;  随机num个出栈</li>
<li>spop key 随机出栈</li>
<li>smove key1 key2 value1;  将key1中的value1赋给key2</li>
<li>数学集合类:<ul>
<li>sdiff 差集</li>
<li>sinter 交集</li>
<li>sunion 并集</li>
</ul>
</li>
</ul>
</li>
<li>redis哈希(Hash)<ul>
<li>KV模式不变, 但V是一个键值对</li>
<li>hset/hget/hmset/hmget/hgetall/hdel</li>
<li>hlen</li>
<li>hexists key 在key中存在的某个值的key</li>
<li>hkeys / hvals</li>
<li>hincrby/hincrbyfloat</li>
<li>hsetnx</li>
</ul>
</li>
<li>redis有序集合Zset(sorted set)<ul>
<li>在set的基础上,加一个score值, set是 k1 v1 v2 v3; zset 是 k1 score1 v1 score2 v2</li>
<li>zadd / zrange</li>
<li>zrangebyscore key 分数范围  ‘(‘ 表示不包含,  eg: 60 90 -&gt; [60,90] (60 (90 -&gt; (60,90)</li>
<li>zrem key 某score下对应的value值, 删除元素</li>
<li>zcard/zcount key score区间 / zrank key values值 作用是获得下标值/zscore key 对应值, 获得分数</li>
<li>zrevrand key values, 逆序获得下标值</li>
<li>zrevrange</li>
<li>zrevrangebyscore key</li>
</ul>
</li>
</ol>
<h3 id="2-解析配置文件-redis-conf"><a href="#2-解析配置文件-redis-conf" class="headerlink" title="2. 解析配置文件 redis.conf"></a>2. 解析配置文件 redis.conf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k &#x3D;&gt; 1000 bytes</span><br><span class="line"># 1kb &#x3D;&gt; 1024 bytes</span><br><span class="line"># 1m &#x3D;&gt; 1000000 bytes</span><br><span class="line"># 1mb &#x3D;&gt; 1024*1024 bytes</span><br><span class="line"># 1g &#x3D;&gt; 1000000000 bytes</span><br><span class="line"># 1gb &#x3D;&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order</span><br><span class="line"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn so</span><br><span class="line"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">设置tcp的backlog, backlog是一个连接队列, backlog队列总和 &#x3D; 未完成三次握手队列 + 已完成三次握手队列</span><br></pre></td></tr></table></figure>

<h2 id="3-Redis-持久化"><a href="#3-Redis-持久化" class="headerlink" title="3. Redis 持久化"></a>3. Redis 持久化</h2><h3 id="1-RDB-redis-database"><a href="#1-RDB-redis-database" class="headerlink" title="1. RDB(redis database)"></a>1. RDB(redis database)</h3><ul>
<li><p>在指定的时间间隔内将内存中的数据集快照写入磁盘, 即Snapshot快照, 它恢复时是将快照文件直接读入到内存中</p>
</li>
<li><p>特点:</p>
<ul>
<li>Redis会单独创建(fork)一个子进程来持久化, 会先将数据写入到一个临时文件中, 等到持久化过程结束了,再用这个临时文件替换上次持久化号的文件  </li>
<li>整个过程中, 主进程是不进行任何IO操作的，　这就确保了极高的性能  </li>
<li>如果需要大规模数据的回复, 且对于数据恢复的完整性不是非常敏感, RDB方式要比AOF方式更高效</li>
<li>RDB的缺点是最后一次持久化后的数据可能丢失  </li>
</ul>
</li>
<li><p>Fork: 复制一个与当前进程一样的进程, 新进程的所有数据,数值和原进程一致, 但是是一个全新的进程, 并作为原进程的子进程, 但是性能会暂时2倍膨胀</p>
</li>
<li><p>Rdb保存的是dump.rdb, 在运行目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line">################################################################################</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行直接输入 save/bgsave,flushall(清空了, 无意义) 可以立刻保存<ul>
<li>save : 阻塞式保存</li>
<li>bgsave : 后台异步保存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-AOF-append-only-file"><a href="#2-AOF-append-only-file" class="headerlink" title="2. AOF(append only file)"></a>2. AOF(append only file)</h3><ul>
<li><p>以日志的形式记录每个<strong>写</strong>操作,将redis执行过的所有写指令记录下来(读操作不记录),只可以追加文件, 不可以改写文件, redis启动之初回读取该文件重新构建数据, 即redis重启的时候根据日志文件的内容重新执行一遍写指令以恢复数据</p>
<ul>
<li>该功能默认是关闭的</li>
<li>生成的文件在dir下, appendonly.aof, 可以和dump.rdb共存, 但是首先加载aof文件  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">################### APPEND ONLY MODE ###################</span><br><span class="line">682 # By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line">683 # good enough in many applications, but an issue with the Redis process or</span><br><span class="line">684 # a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line">685 # the configured save points).</span><br><span class="line">686 #</span><br><span class="line">687 # The Append Only File is an alternative persistence mode that provides</span><br><span class="line">688 # much better durability. For instance using the default data fsync policy</span><br><span class="line">689 # (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line">690 # dramatic event like a server power outage, or a single write if something</span><br><span class="line">691 # wrong with the Redis process itself happens, but the operating system is</span><br><span class="line">692 # still running correctly.</span><br><span class="line">693 #</span><br><span class="line">694 # AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line">695 # If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line">696 # with the better durability guarantees.</span><br><span class="line">697 #</span><br><span class="line">698 # Please check http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;persistence for more information.</span><br><span class="line"></span><br><span class="line">700 appendonly no</span><br><span class="line"></span><br><span class="line">702 # The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">704 appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">706 # The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line">707 # instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line">708 # data on disk, some other OS will just try to do it ASAP.</span><br><span class="line">709 #</span><br><span class="line">710 # Redis supports three different modes:</span><br><span class="line">711 #</span><br><span class="line">712 # no: don&#39;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line">713 # always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line">714 # everysec: fsync only one time every second. Compromise.</span><br><span class="line">715 #</span><br><span class="line">716 # The default is &quot;everysec&quot;, as that&#39;s usually the right compromise between</span><br><span class="line">717 # speed and data safety. It&#39;s up to you to understand if you can relax this to</span><br><span class="line">718 # &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line">719 # it wants, for better performances (but if you can live with the idea of</span><br><span class="line">720 # some data loss consider the default persistence mode that&#39;s snapshotting),</span><br><span class="line">721 # or on the contrary, use &quot;always&quot; that&#39;s very slow but a bit safer than</span><br><span class="line">722 # everysec.</span><br><span class="line">723 #</span><br><span class="line">724 # More details please check the following article:</span><br><span class="line">725 # http:&#x2F;&#x2F;antirez.com&#x2F;post&#x2F;redis-persistence-demystified.html</span><br><span class="line">726 #</span><br><span class="line">727 # If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line">729 # appendfsync always</span><br><span class="line">730 appendfsync everysec</span><br><span class="line">731 # appendfsync no</span><br><span class="line"></span><br><span class="line">733 # When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line">734 # saving process (a background save or AOF log background rewriting) is</span><br><span class="line">735 # performing a lot of I&#x2F;O against the disk, in some Linux configurations</span><br><span class="line">745 # the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line">746 # possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line">747 # default Linux settings).</span><br><span class="line">748 #</span><br><span class="line">749 # If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line">750 # &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"></span><br><span class="line">752 no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">754 # Automatic rewrite of the append only file.</span><br><span class="line">755 # Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line">756 # BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line">757 #</span><br><span class="line">758 # This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line">759 # latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line">760 # the AOF at startup is used).</span><br><span class="line">761 #</span><br><span class="line">762 # This base size is compared to the current size. If the current size is</span><br><span class="line">763 # bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line">764 # you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line">765 # is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line">766 # is reached but it is still pretty small.</span><br><span class="line">767 #</span><br><span class="line">768 # Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line">769 # rewrite feature.</span><br><span class="line"></span><br><span class="line">771 auto-aof-rewrite-percentage 100</span><br><span class="line">772 auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">774 # An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line">775 # startup process, when the AOF data gets loaded back into memory.</span><br><span class="line">776 # This may happen when the system where Redis is running</span><br><span class="line">777 # crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line">778 # data&#x3D;ordered option (however this can&#39;t happen when Redis itself</span><br><span class="line">779 # crashes or aborts but the operating system still works correctly).</span><br><span class="line">780 #</span><br><span class="line">781 # Redis can either exit with an error when this happens, or load as much</span><br><span class="line">782 # data as possible (the default now) and start if the AOF file is found</span><br><span class="line">783 # to be truncated at the end. The following option controls this behavior.</span><br><span class="line">784 #</span><br><span class="line">785 # If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="line">786 # the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line">787 # Otherwise if the option is set to no, the server aborts with an error</span><br><span class="line">788 # and refuses to start. When the option is set to no, the user requires</span><br><span class="line">789 # to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="line">790 # the server.</span><br><span class="line">791 #</span><br><span class="line">792 # Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="line">793 # the server will still exit with an error. This option only applies when</span><br><span class="line">794 # Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="line">795 # will be found.</span><br><span class="line">796 aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">798 # When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line">799 # AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line">800 # on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line">801 #</span><br><span class="line">802 #   [RDB file][AOF tail]</span><br><span class="line">803 #</span><br><span class="line">804 # When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="line">805 # string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="line">806 # tail.</span><br><span class="line">807 aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line">809 ################## LUA SCRIPTING  ################</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结</p>
<ul>
<li>AOF文件是一个只进行追加的日志文件</li>
<li>redis可以在AOF文件体积变得过大时, 自动地在后台对AOF进行重写</li>
<li>AOF文件有序地保存了对数据库执行的所有写入操作, 这些写入操作以reids协作的格式保存, 因此,AIF文件的内容容易读懂</li>
<li>对相同的数据集来说, AOF文件的体积通常大于RDB文件</li>
<li>根据所使用的fsync策略, AOF的速度可能会慢于RDB</li>
</ul>
</li>
</ul>
<h3 id="3-小总结"><a href="#3-小总结" class="headerlink" title="3. 小总结"></a>3. 小总结</h3><ul>
<li>RDB持久化方式能在指定的时间间隔内对数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作, 当服务器重启的时候, 会重新执行这些命令来恢复原始的数据, redis可以对AOF文件后台重写, 使得AOF文件的体积不至于过大</li>
<li>只做缓存: 即数据值在服务器运行的时候存在, 可以不用持久化</li>
<li>作者建议同时开启2种持久化方式:  <ul>
<li>优先载入AOF文件, 因为通常AOF要比RDB存储的完整</li>
<li>RDB更适合于备份数据库(AOF不断变化, 不适合备份), 留一手</li>
</ul>
</li>
</ul>
<h2 id="4-Redis-事务"><a href="#4-Redis-事务" class="headerlink" title="4. Redis 事务"></a>4. Redis 事务</h2><ul>
<li><p>概念:  </p>
<ul>
<li>可以一次执行多个命令, 本质是<strong>一组命令的集合</strong>, 一个事务种的所有命令都会序列化, 按顺序的串行化执行,而不会被其他命令插入</li>
<li>一个队列中, 一次性, 顺序性,排他性的执行一系列命令</li>
</ul>
</li>
<li><p>常用命令:</p>
<ol>
<li>discard: 取消事务, 放弃执行事务块内的所有命令</li>
<li>exec: 执行事务块内的所有命令</li>
<li>multi: 标志着事务块的开启</li>
<li>unwatch: 取消watch命令对所有key的监视</li>
<li>watch key: 监视1个或多个 key, 如果在事务执行前,这个key被其他命令所改动, 那么事务将被打断</li>
</ol>
</li>
<li><p>redis 部分支持事务</p>
<ul>
<li>命令全部正确, 正常批量执行</li>
<li>discard 放弃执行所有事务</li>
<li>全体连坐 — 有严重错误命令, 直接报错, 全部失败</li>
<li>冤头寨主 — 小的错误, 比如给字母 incr 1, 只有该条命令失败</li>
<li>watch监控<ul>
<li>使用的是乐观锁</li>
<li>悲观锁/乐观锁/CAS(check and set)<ol>
<li>悲观锁:(认为一定会出事, 在MySQL中就是把整张表都锁了,每次拿数据的时候都会上锁, 并发差, 一致性好)</li>
<li>乐观锁:(认为不会出事, 不会上锁,在一张表后加一个version字段; 一旦有并发的修改, 在提交的时候,如果版本号和查询的时候不相同, 就失败, 先把数据更新到别人改好的版本, 再进行自己的修改, 直到修改成功): 提交版本必须大于当前记录版本才更新</li>
</ol>
</li>
<li>一旦执行了exec, 之前的监控锁都被取消</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="插曲-Redis-发布和订阅"><a href="#插曲-Redis-发布和订阅" class="headerlink" title="插曲: Redis 发布和订阅"></a>插曲: Redis 发布和订阅</h3><ul>
<li>进程间的一种消息通信模式: 发送者(pub)发送消息, 订阅者(sub)接收消息</li>
</ul>
<h2 id="5-Redis的复制-master-slave"><a href="#5-Redis的复制-master-slave" class="headerlink" title="5. Redis的复制(master/slave)"></a>5. Redis的复制(master/slave)</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul>
<li>主从复制, 主机数据更新后根据配置和策略, 自动同步到备机的master/slave机制, master以写为主, slave以读为主</li>
<li>读写分离, 容灾恢复  </li>
</ul>
<h3 id="2-怎么用"><a href="#2-怎么用" class="headerlink" title="2. 怎么用"></a>2. 怎么用</h3><ol>
<li>配从(库)不配主(库)</li>
<li>从库配置: slaveof 主库IP 主库端口<ul>
<li>每次从机与master断开之后, 都要重新连接, 除非配置到redis.conf文件中</li>
<li>Info replication</li>
</ul>
</li>
<li>修改配置文件细节:<ul>
<li>拷贝多个redis.conf文件</li>
<li>开启daemonize yes</li>
<li>pid文件名字</li>
<li>指定端口</li>
<li>log文件名字</li>
<li>dump.rdb名字</li>
</ul>
</li>
<li>常用3招:<ol>
<li>一主二仆<ul>
<li>如果主机主动断开, 从机默认不发生变化, 主机重新连接后, 依然保持不变, 但是从机主动断开后需要重新连接主机</li>
</ul>
</li>
<li>薪火相传</li>
<li>反客为主: slaceof no one 使当前数据库停止与其他数据库的同步,转为u主数据库</li>
</ol>
</li>
</ol>
<h3 id="3-复制原理"><a href="#3-复制原理" class="headerlink" title="3.  复制原理"></a>3.  复制原理</h3><ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>master接到命令后, 启动后台的存盘程序, 同时收集所有接收到的用于修改数据集命令, 在后台进程执行完毕后, master将传送整个数据文件到slave, 已完成一次完全同步</li>
<li>全量复制: 而slave服务在接受到数据库文件数据后, 将其存盘并加载到内存中</li>
<li>增量复制: master继续将新的所有收集到的修改命令一次传给salve, 完成同步</li>
<li>但是只要是重新连接master, 一次完全同步将被自动执行</li>
</ul>
<h3 id="4-哨兵模式-sentinel"><a href="#4-哨兵模式-sentinel" class="headerlink" title="4. 哨兵模式(sentinel)"></a>4. 哨兵模式(sentinel)</h3><ul>
<li><p>反客为主的自动版, 后台监控主机是否故障,如果故障, 根据投票数将从库转换为主库</p>
</li>
<li><p>步骤:</p>
<ul>
<li>新建sentinel.conf文件跟之前的配置文件在同一目录</li>
<li>配置哨兵, 填写内容<ul>
<li>sentinel monitor 被监控数据库名字 ip:端口号 1<br>数字1表示主机挂掉后,slave投票看让谁接替成为宿主机, 票数多的成为主机</li>
</ul>
</li>
<li>启动哨兵<ul>
<li>redis-sentinel …./sentinel.conf</li>
</ul>
</li>
<li>挂掉的主机重启回来后, 称为新的主机的slave</li>
</ul>
</li>
<li><p>复制的缺点</p>
<ul>
<li>延迟</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8中HashMap更新映射项的方法(merge)笔记</title>
    <url>/posts/85124b9.html</url>
    <content><![CDATA[<ul>
<li><p>在jdk1.8中, HashMap中更新了几个关于更新映射项的方法, 个人觉得很好用,于是写个笔记小记一下.</p>
<ul>
<li><code>public V getOrDefault(Object key, V defaultValue)</code></li>
<li><code>public V putIfAbsent(K key, V value)</code>  </li>
<li><code>public V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code></li>
</ul>
</li>
<li><p>处理映射项的一个难点是更新映射项, 也就是我们常说的键值对中的值. 正常情况下, 可以通过<code>get(key)</code>方法获得值, 然后对其进行更新, 然后再放回更新的值. 但是要考虑到键第一次出现的时候. 比如, 再统计某个单词在文件中出现的频度.  </p>
</li>
<li><p>在看到一个单词(word)时, 将对应的计数器加1, 如下所示</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">String word = <span class="string">"word"</span>;</span><br><span class="line">counts.put(word, counts.get(word)+<span class="number">1</span>); <span class="comment">// NullPointerException, 第一次获取"1"时get返回null</span></span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>在jdk8之前我们解决这个问题, 应该就会在put前进行检测, 虽然不难, 但是当jdk8后可以更加便捷的方法.  </p>
<ul>
<li><p>第一种方法就是利用<code>getOrDefault</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>api中的描述是:<blockquote>
<p>Returns the value to which the specified key is mapped, or if this map contains no mapping for the key.</p>
</blockquote>
</li>
<li>直接看源码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key)) ? v : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现这个默认方法其实就是把我们之前做的事简单封装了一下, 简单明了</p>
</li>
<li><p>第二种方法是先调用putIfAbsent方法, 只有当键存在时才放入一个值, 这跟我们之前的做法是一样的,只不过更加便捷.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.putIfAbsent(word,<span class="number">0</span>); <span class="comment">// 直接看源代码, 清楚明白</span></span><br><span class="line">counts.put(word, counts.get(word)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    V v = get(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        v = put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看到源码, 我不知道怎么形容了, 就是2个字, 清晰</li>
<li>第三种方法就是使用merge方法, 这也是最方便的方法, 强烈建议:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用方法引用传入sum方法, 当word第一次出现时, word的值被赋值为1,  </span></span><br><span class="line"><span class="comment">// 不是第一次出现时, 会将其值加1.</span></span><br><span class="line"><span class="comment">// 这是一个函数式接口, 用来写怎样处理默认值value和get方法得到的oldValue之间的关系</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,  BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span>   </span>&#123;</span><br><span class="line">    <span class="comment">// 确保remappingFunction 不是一个 null 值,  </span></span><br><span class="line">    <span class="comment">// 如果是null会直接抛异常, 不是null就返回对象本身.</span></span><br><span class="line">    Objects.requireNonNull(remappingFunction);  </span><br><span class="line">    Objects.requireNonNull(value);  </span><br><span class="line">    <span class="comment">// 获取当前key中的值, 如果是第一次出现的键, 会得到一个null</span></span><br><span class="line">    V oldValue = get(key);  </span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">                remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    当oldVlue为null时, 也就是说该键key第一次出现, 返回默认值value,</span></span><br><span class="line"><span class="comment">    不是第一次出现的时候, 交给函数式接口来处理, 在调用的时候可以用lambda表达式或方法引用来写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        remove(key); <span class="comment">// 如果经过以上处理, 得到的newValue还是null的话, 删去该key, 否则就正常的添加该键值对,  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法最终返回我们想要的值</span></span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>都在注释里写清楚了.</li>
<li>综上, 以后再更新映射项就考虑merge吧!</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>参考文献</strong>:<br>Java核心技术 卷1 原书第10版 , 第9章</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
